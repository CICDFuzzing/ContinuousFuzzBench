diff --git a/ssl/statem/statem_dtls.c b/ssl/statem/statem_dtls.c
index 564829c808..b9b180d4a9 100644
--- a/ssl/statem/statem_dtls.c
+++ b/ssl/statem/statem_dtls.c
@@ -402,6 +402,7 @@ int dtls_get_message(SSL *s, int *mt, size_t *len)
     return 1;
 }
 
+#ifdef MAGMA_ENABLE_FIXES
 /*
  * dtls1_max_handshake_message_len returns the maximum number of bytes
  * permitted in a DTLS handshake message for |s|. The minimum is 16KB, but
@@ -414,6 +415,7 @@ static size_t dtls1_max_handshake_message_len(const SSL *s)
         return s->max_cert_list;
     return max_len;
 }
+#endif
 
 static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr)
 {
@@ -422,7 +424,7 @@ static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr)
     msg_len = msg_hdr->msg_len;
     frag_off = msg_hdr->frag_off;
     frag_len = msg_hdr->frag_len;
-
+#ifdef MAGMA_ENABLE_FIXES
     /* sanity checking */
     if ((frag_off + frag_len) > msg_len
             || msg_len > dtls1_max_handshake_message_len(s)) {
@@ -430,6 +432,20 @@ static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr)
                  SSL_R_EXCESSIVE_MESSAGE_SIZE);
         return 0;
     }
+#else 
+    if ((frag_off + frag_len) > msg_len) {
+        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_DTLS1_PREPROCESS_FRAGMENT,
+                 SSL_R_EXCESSIVE_MESSAGE_SIZE);
+        return 0;
+    }
+
+    #ifdef MAGMA_ENABLE_CANARIES
+        MAGMA_LOG("MAE113",msg_len > dtls1_max_handshake_message_len(s));
+    #endif
+
+#endif
+
+        
 
     if (s->d1->r_msg_hdr.frag_off == 0) { /* first fragment */
         /*
@@ -525,6 +541,25 @@ static int dtls1_retrieve_buffered_fragment(SSL *s, size_t *len)
     } else {
         return 0;
     }
+#ifdef MAGMA_ENABLE_FIXES
+
+#else
+/*
+ * dtls1_max_handshake_message_len returns the maximum number of bytes
+ * permitted in a DTLS handshake message for |s|. The minimum is 16KB, but
+ * may be greater if the maximum certificate list size requires it.
+*/
+static unsigned long dtls1_max_handshake_message_len(const SSL *s)
+{
+    unsigned long max_len =
+    TLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;
+    if (max_len < (unsigned long)s->max_cert_list)
+    return s->max_cert_list;
+    return max_len;
+}
+
+ #endif
+
 }
 
 static int
