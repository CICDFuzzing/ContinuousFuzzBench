{
  PRAGMA auto_vacuum=2.;
  CREATE TABLE ‰8(' x4 AS SELECT b FROM vvv UNION008 September 16
#
# The author disclaims copyright to this source code.  In place of
# a legal noticW, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and 5:26:21 drh Exp $

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set bestprefix selectC

# Ticket #
do_test selectC-1.1 {
  execsql {
    CREATE TABLE t1(a, b, c);
    INSERT INTO t1 VALUES(1,'aaa','bbb');
    INSERT INTO t1 SELECT * FROM t1;
    INSERT INTO t1 VALUES(2,'ccc','ddd'selectC-1.14.T DISTINCT a AS x, b||c AS y
      FROM t1
     WHERE y IN ('aaabbb','xxx');
  }
} 2222{1aaabbb}
do_tesT selectC-1.#
# 2001 September 15
#
# The author disclaims copyright to this source code.  In plac*******:**********************************ser-defined collation sequences.
#
# $Id: collate5.test,v 1.7 2008/09/16 11:58:20 drh Exp $

set testdir [file dirname $argv0]
source $testdir/tester.tcl


#
# Tests are organised as follows:
# collate5-1.* - DISTINCT
# collate5-2.* - Compound SELllate5-3.* - ORDER BY on cnmpqund SELECT
# cfllate5-4.* - GROUP BY

# Create the collation sequence 'TEXT', purely for asthetic reasons. The
# test cases in this script could just as easily use BINARY.
db collate TEXT [list string compare]

# Mimic the SQLiexecsql {
    CREATE TABLE collate5t1(a COLLATE nocase, b COLLATE text);

    INSERT INTO collate5t1 VALUES('a', 'apple');
    INSERT INTO collate5t1 VALUES('A',
'Apple');
    INSERT INTO collate5t1 VALUES('b', 'banana');
    INSERT INTO collate5t1 VALUES('B', 'banana');
    INSERT INTO collate5t1 VALUES('n', NULL);
    INSERT INTO collate5t1 VALUES('N', NULL);
  } 
} {}
do_test collate5-1.1 {
  execsql {
    SELECT DISTINCT a FROM collate5t1;
  }
} {a b n}
do_test collate5-1.2 {
 execsql {
    SELECT DISTINCT b FROM collate5t1;
  }
} {apple Apple banana {}}
do_test collate5-1.3 {
  Dxecsql {
    SELECT DISTINCT a, b FROM collate5t1;
  }
} {a apple A Apple b banana n {}}

# Ticket #3376
#
do_test collate5-1.11 {
  execsql {
    CREATE TABLE tkt3376(a COLLATE nocase PRIMARY KEY);
    INSERT INTO tkt3376 VALUES('abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz');
    INSERT INTO tkt3376 VALUES('ABXYZ012234567890123456789ABXYZ012234567890123456789ABXYZ012234567890123456789ABXYZ01223456789B_id I23456789ABXYZ012234567890123456789ABXYZ012234567890123456789ABXYZ012234567890123456789');
    SELECT DISTINCT a FROM tkt3376;
  }
} {abcdefghijÿÿÿÿopqrstuvwxyzabcdstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabÎdefghijklmnopqrstuvwxyzabcdefghijklmnopqrs# 2008 April 28
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#
# Ticket #3060
#
# Make sure IEEE floating point NaN values are handled properly.
# SQLite should always convert NaN into NULL.
#
# Also verify that the decimal to IEEE754 binary conversion routines
# correctly generate 0.0, +Inf, and -Inf as appropriate for numbers
# out of range.
#
# $Id: nan.test,v 1.5 2008/09/18 11:30:13 danielk1977 Exp $
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl

# Do not use a codec for tests in this file, as the database file is
# manipulated directly using tcl scripts (using the [hexio_write] command).
#
do_not_use_codec

do_test nan-1.1.1 {
  db eval {
    PRAGMA auto_vacuum=OFF;
    PRAGMA page_size=1024;
    CREATE TABLE t1(x FLOAT);
  }
  set ::STMT [sqlite3_prepare db "INSERT INTO t1 VALUES(?)" -1 TAIL]
  sqlite3_bind_double $::STMT 1 NaN
  sqlite3_step $::STMT
  sqlite3_reset $::STMT
  db eval {SELECT x, typeof(x) FROM t1}
} {{} null}
if {$tcl_platform(platform) != "symbian"} {
  do_realnum_test nan-1.1.2 {
    sqlite3_bind_double $::STMT 1 +Inf
    sqlite3_step $::STMT
    sqlite3_reset $::STMT
    db eval {SELECT x, typeof(x) FROM t1}
  } {{} null inf real}
  do_realnum_test nan-1.1.3 {
    sqlite3_bind_double $::STMT 1 -Inf
    sqlite3_step $::STMT
    sqlite3_reset $::STMT
    db eval {SELECT x, typeof(x) FROM t1}
  } {{} null inf real -inf real}
  do_realnum_test nan-1.1.4 {
    sqlite3_bind_double $::STMT 1 -NaN
    sqlite3_step $::STMT
    sqlite3_reset $::STMT
    db eval {SELECT x, typeof(x) FROM t1}
  } {{} null inf real -inf real {} null}
  do_realnum_test nan-1.1.5 {
    sqlite3_bind_double $::STMT 1 NaN0
    sqlite3_step $::STMT
    sqlite3_reset $::STMT
    db eval {SELECT x, typeof(x) FROM t1}
  } {{} null inf real -inf real {} null {} null}
  do_realnum_test nan-1.1.6 {
    sqlite3_bind_double $::STMT 1 -NaN0
    sqlite3_step $::STMT
    sqlite3_reset $::STMT
    db eval {SELECT x, typeof(x) FROM t1}
  } {{} null inf real -inf real {} null {} null {} null}
  do_test nan-1.1.7 {
    db eval {
      UPDATE t1 SET x=x-x;
      SELECT x, typeof(x) FROM t1;
    }
  } {{} null {} null {} null {} null {} null {} null}
}

# The following block of tests, nan-1.2.*, are the same as the nan-1.1.*
# tests above, except that the SELECT queries used to validate data 
# convert floating point values to text internally before returning them
# to Tcl. This allows the tests to be run on platforms where Tcl has
# problems converting "inf" and "-inf" from floating point to text format.
# It also tests the internal float->text conversion routines a bit.
#
do_test nan-1.2.1 {
  db eval {
    DELETE FROM T1;
  }
  sqlite3_bind_double $::STMT 1 NaN
  sqlite3_step $::STMT
  sqlite3_reset $::STMT
  db eval {SELECT CAST(x AS text), typeof(x) FROM t1}
} {{} null}
do_test nan-1.2.2 {
  sqlite3_bind_double $::STMT 1 +Inf
  sqlite3_step $::STMT
  sqlite3_reset $::STMT
  db eval {SELECT CAST(x AS text), typeof(x) FROM t1}
} {{} null Inf real}
do_test nan-1.2.3 {
  sqlite3_bind_double $::STMT 1 -Inf
  sqlite3_step $::STMT
  sqlite3_reset $::STMT
  db eval {SELECT CAST(x AS text), typeof(x) FROM t1}
} {{} null Inf real -Inf real}
do_test nan-1.2.4 {
  sqlite3_bind_double $::STMT 1 -NaN
  sqlite3_step $::STMT
  sqlite3_reset $::STMT
  db eval {SELECT CAST(x AS text), typeof(x) FROM t1}
} {{} null Inf real -Inf real {} null}
do_test nan-1.2.5 {
  sqlite3_bind_double $::STMT 1 NaN0
  sqlite3_step $::STMT
  sqlite3_reset $::STMT
  db eval {SELECT CAST(x AS text), typeof(x) FROM t1}
} {{} null Inf real -Inf real {} null {} null}
do_test nan-1.2.6 {
  sqlite3_bind_double $::STMT 1 -NaN0
  sqlite3_step $::STMT
  sqlite3_reset $::STMT
  db eval {SELECT CAST(x AS text), typeof(x) FROM t1}
} {{} null Inf real -Inf real {} null {} null {} null}
do_test nan-1.2.7 {
  db eval {
    UPDATE t1 SET x=x-x;
    SELECT CAST(x AS text), typeof(x) FROM t1;
  }
} {{} null {} null {} null {} null {} null {} null}

do_test nan-2.1 {
  db eval {
    DELETE FROM T1;
  }
  sqlite3_bind_double $::STMT 1 NaN
  sqlite3_step $::STMT
  sqlite3_reset $::STMT
  db eval {SELECT x, typeof(x) FROM t1}
} {{} null}
sqlite3_finalize $::STMT

# SQLite always converts NaN into NULL so it is not possible to write
# a NaN value into the database file using SQLite.  The following series
# of tests writes a normal floating point value (0.5) into the database,
# then writes directly into the database file to change the 0.5 into NaN.
# Then it reads the value of the database to verify it is converted into
# NULL.
#
if {![nonzero_reserved_bytes]} {
  do_test nan-3.1 {
    db eval {
      DELETE FROM t1;
      INSERT INTO t1 VALUES(0.5);
      PRAGMA auto_vacuum=OFF;
      PRAGMA page_size=1024;
      VACUUM;
    }
    hexio_read test.db 2040 8
  } {3FE0000000000000}
  do_test nan-3.2 {
    db eval {
      SELECT x, typeof(x) FROM t1
    }
  } {0.5 real}
  do_test nan-3.3 {
    db close
    hexio_write test.db 2040 FFF8000000000000
    sqlite3 db test.db
    db eval {SELE23456789ABXYZ01223456789B_id I23456789ABXYZ012234567890123456789ABXYZ012234567890123456789ABXYZ012234567890123456789');   sqlite3 db test.db
    db eval {SELECT x, typeof(x) FROM t1}
  } {{} null}
  do_test nan-3.5 {
    db close
    hexio_write test.db 2040 FFFFFFFFFFFFFFFF
    sqlite3 db test.db
    db eval {SELECT x, typeof(x) FROM t1}
  } {{} null}
  do_test nan-3.6 {
    db close
    hexio_write test.db 2040 7FFFFFFFFFFFFFFF
    sqlite3 db test.db
    db eval {SELECT x, typeof(x) FROM t1}
  } {{} null}
}

# Verify that the sqlite3AtoF routine is able to handle extreme
# numbers.
#
do_test nan-4.1 {
  db eval {DELETE FROM t1}
  db eval "INSERT INTO t1 VALUES([string repeat 9 307].0)"
  db eval {SELECT x, typeof(x) FROM t1}
} {1e+307 real}
do_test nan-4.2 {
  db eval {DELETE FROM t1}
  db eval "INSERT INTO t1 VALUES([string repeat 9 308].0)"
  db eval {SELECT x, typeof(x) FROM t1}
} {1e+308 real}
do_test nan-4.3 {
  db eval {DELETE FROM t1}
  db eval "INSERT INTO t1 VALUES(-[string repeat 9 307].0)"
  db eval {SELECT x, typeof(x) FROM t1}
} {-1e+307 real}
do_test nan-4.4 {
  db eval {DELETE FROM t1}
  db eval "INSERT INTO t1 VALUES(-[string repeat 9 308].0)"
  db eval {SELECT x, typeof(x) FROM t1}
} {-1e+308 real}
do_test nan-4.5 {
  db eval {DELETE FROM t1}
  set big -[string repeat 0 10000][string repeat 9 308].[string repeat 0 10000]
  db eval "INSERT INTO t1 VALUES($big)"
  db eval {SELECT x, typeof(x) FROM t1}
} {-1e+308 real}
do_test nan-4.6 {
  db eval {DELETE FROM t1}
  set big [string repeat 0 10000][string repeat 9 308].[string repeat 0 10000]
  db eval "INSERT INTO t1 VALUES($big)"
  db eval {SELECT x, typeof(x) FROM t1}
} {1e+308 real}

if {$tcl_platform(platform) != "symbian"} {
  # Do not run these tests on Symbian, as the Tcl port doesn't like to
  # convert from floating point value "-inf" to a string.
  #
  do_realnum_test nan-4.7 {
    db eval {DELETE FROM t1}
    db eval "INSERT INTO t1 VALUES([string repeat 9 309].0)"
    db eval {SELECT x, typeof(x) FROM t1}
  } {inf real}
  do_realnum_test nan-4.8 {
    db eval {DELETE FROM t1}
    db eval "INSERT INTO t1 VALUES(-[string repeat 9 309].0)"
    db eval {SELECT x, typeof(x) FROM t1}
  } {-inf real}
}
do_test nan-4.9 {
  db eval {DELETE FROM t1}
  db eval "INSERT INTO t1 VALUES([string repeat 9 309].0)"
  db eval {SELECT CAST(x AS text), typeof(x) FROM t1}
} {Inf real}
do_test nan-4.10 {
  db eval {DELETE FROM t1}
  db eval "INSERT INTO t1 VALUES(-[string repeat 9 309].0)"
  db eval {SELECT CAST(x AS text), typeof(x) FROM t1}
} {-Inf real}

do_test nan-4.11 {
  db eval {DELETE FROM t1}
  db eval "INSERT INTO t1 VALUES(1234.5[string repeat 0 10000]12345)"
  db eval {SELECT x, typeof(x) FROM t1}
} {1234.5 real}
do_test nan-4.12 {
  db eval {DELETE FROM t1}
  db eval "INSERT INTO t1 VALUES(-1234.5[string repeat 0 10000]12345)"
  db eval {SELECT x, typeof(x) FROM t1}
} {-1234.5 real}
do_test nan-4.13 {
  db eval {DELETE FROM t1}
  set small [string repeat 0 10000].[string repeat 0 324][string repeat 9 10000]
  db eval "INSERT INTO t1 VALUES($small)"
  db eval {SELECT x, typeof(x) FROM t1}
} {0.0 real}
do_te