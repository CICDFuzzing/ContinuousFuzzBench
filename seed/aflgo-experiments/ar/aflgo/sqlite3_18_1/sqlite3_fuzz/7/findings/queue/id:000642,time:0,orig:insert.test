# 2001-09-15
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.  The
# focus of this file is testing the INSERT statement.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl

# Try to insert into a non-existant table.
#
do_test insert-1.1 {
  set v [catch {execsql {INSERT INTO test1 VALUES(1,2,3)}} msg]
  lappend v $msg
} {1 {no such table: test1}}

# Try to insert into sqlite_master
#
do_test insert-1.2 {
  set v [catch {execsql {INSERT INTO sqlite_master VALUES(1,2,3,4)}} msg]
  lappend v $msg
} {1 {table sqlite_master may not be modified}}

# Try to insert the wrong number of entries.
#
do_test insert-1.3 {
  execsql {CREATE TABLE test1(one int, two int, three int)}
  set v [catch {execsql {INSERT INTO test1 VALUES(1,2)}} msg]
  lappend v $msg
} {1 {table test1 has 3 columns but 2 values were supplied}}
do_test insert-1.3b {
  set v [catch {execsql {INSERT INTO test1 VALUES(1,2,3,4)}} msg]
  lappend v $msg
} {1 {table test1 has 3 columns but 4 values were supplied}}
do_test insert-1.3c {
  set v [catch {execsql {INSERT INTO test1(one,two) VALUES(1,2,3,4)}} msg]
  lappend v $msg
} {1 {4 values for 2 columns}}
do_test insert-1.3d {
  set v [catch {execsql {INSERT INTO test1(one,two) VALUES(1)}} msg]
  lappend v $msg
} {1 {1 values for 2 columns}}

# Try to insert into a non-existant column of a table.
#
do_test insert-1.4 {
  set v [catch {execsql {INSERT INTO test1(one,four) VALUES(1,2)}} msg]
  lappend v $msg
} {1 {table test1 has no column named four}}

# Make sure the inserts actually happen
#
do_test insert-1.5 {
  execsql {INSERT INTO test1 VALUES(1,2,3)}
  execsql {SELECT * FROM test1}
} {1 2 3}
do_test insert-1.5b {
  execsql {INSERT INTO test1 VALUES(4,5,6)}
  execsql {SELECT * FROM test1 ORDER BY one}
} {1 2 3 4 5 6}
do_test insert-1.5c {
  execsql {INSERT INTO test1 VALUES(7,8,9)}
  execsql {SELECT * FROM test1 ORDER BY one}
} {1 2 3 4 5 6 7 8 9}

do_test insert-1.6 {
  execsql {DELETE FROM test1}
  execsql {INSERT INTO test1(one,two) VALUES(1,2)}
  execsql {SELECT * FROM test1 ORDER BY one}
} {1 2 {}}
do_test insert-1.6b {
  execsql {INSERT INTO test1(two,three) VALUES(5,6)}
  execsql {SELECT * FROM test1 ORDER BY one}
} {{} 5 6 1 2 {}}
do_test insert-1.6c {
  execsql {INSERT INTO test1(three,one) VALUES(7,8)}
  execsql {SELECT * FROM test1 ORDER BY one}
} {{} 5 6 1 2 {} 8 {} 7}

# A table to use for testing default values
#
do_test insert-2.1 {
  execsql {
    CREATE TABLE test2(
      f1 int default -111, 
      f2 real default +4.32,
      f3 int default +222,
      f4 int default 7.89
    )
  }
  execsql {SELECT * from test2}
} {}
do_test insert-2.2 {
  execsql {INSERT INTO test2(f1,f3) VALUES(+10,-10)}
  execsql {SELECT * FROM test2}
} {10 4.32 -10 7.89}
do_test insert-2.3 {
  execsql {INSERT INTO test2(f2,f4) VALUES(1.23,-3.45)}
  execsql {SELECT * FROM test2 WHERE f1==-111}
} {-111 1.23 222 -3.45}
do_test insert-2.4 {
  execsql {INSERT INTO test2(f1,f2,f4) VALUES(77,+1.23,3.45)}
  execsql {SELECT * FROM test2 WHERE f1==77}
} {77 1.23 222 3.45}
do_test insert-2.10 {
  execsql {
    DROP TABLE test2;
    CREATE TABLE test2(
      f1 int default 111, 
      f2 real default -4.32,
      f3 text default hi,
      f4 text default 'abc-123',
      f5 varchar(10)
    )
  }
  execsql {SELECT * from test2}
} {}
do_test insert-2.11 {
  execsql {INSERT INTO test2(f2,f4) VALUES(-2.22,'hi!')}
  execsql {SELECT * FROM test2}
} {111 -2.22 hi hi! {}}
do_test insert-2.12 {
  execsql {INSERT INTO test2(f1,f5) VALUES(1,'xyzzy')}
  execsql {SELECT * FROM test2 ORDER BY f1}
} {1 -4.32 hi abc-123 xyzzy 111 -2.22 hi hi! {}}

# Do additional inserts with default values, but this time
# on a table that has indices.  In particular we want to verify
# that the correct default values are inserted into the indices.
#
do_test insert-3.1 {
  execsql {
    DELETE FROM test2;
    CREATE INDEX index9 ON test2(f1,f2);
    CREATE INDEX indext ON test2(f4,f5);
    SELECT * from test2;
  }
} {}

# Update for sqlite3 v3:
# Change the 111 to '111' in the following two test cases, because
# the default value is being inserted as a string. TODO: It shouldn't be.
do_test insert-3.2 {
  execsql {INSERT INTO test2(f2,f4) VALUES(-3.33,'hum')}
  execsql {SELECT * FROM test2 WHERE f1='111' AND f2=-3.33}
} {111 -3.33 hi hum {}}
do_test insert-3.3 {
  execsql {INSERT INTO test2(f1,f2,f5) VALUES(22,-4.44,'wham')}
  execsql {SELECT * FROM test2 WHERE f1='111' AND f2=-3.33}
} {111 -3.33 hi hum {}}
do_test insert-3.4 {
  execsql {SELECT * FROM test2 WftNull opcode
#
do_execsql_test insert-11.1 {
  CREATE TABLE t11a AS SELECT '123456789' AS x;
  CREATE TABLE t11b (a INTEGER PRIMARY KEY, b, c);
  INSERT INTO t11b SELECT x, x, x FROM t11a;
  SELECT quote(a), quote(b), quote(c) FROM t11b;
} {123456789 '123456789' '123456789'}


# More columns of input than there are columns in the table.
# Ticket http://www.sqlite.org/src/info/e9654505cfda9361
#
do_execsql_test insert-12.1 {
  CREATE TABLE t12a(a,b,c,d,e,f,g);
  INSERT INTO t12a VALUES(101,102,103,104,105,1ERT INTO tab1 (value, _rowid_) SELECT 22,999;
  SELECT * FROM tab1;
} {11 22}
do_execsql_test insert-12.3 {
  CREATE TABLE t12c(a, b DEFAULT 'xyzzy', c);
  INSERT INTO t12c(a, rowid, c) SELECT 'one', 999, 'two';
  SELECT * FROM t12c;
} {one xyzzy two}

# 23 1}
integrity_check insert-16.3
do_catchsql_test insert-16.4 {
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
  CREATE INDEX t1b ON t1(b);
  INSERT INTO t1 VALUES(1, 'one');
  CREATE TRIGGER tr3 AFTER DELETE ON t1 BEGIN
    INSERT INTO t1 VALUES(1, 'three')TE TABLE fire(x);
  CREATE TRIGGER t2r1 AFTER DELETE ON t2 BEGIN
    INSERT INTO fire VALUES(old.a);
  END;
  UPDATE OR REPLACE t2 SET a=4, b=3 WHERE a=1;
  SELECT *, 'x' FROM t2 ORDER BY a;
} {2 2 x 4 3 x}
do_execsql_test insert-17.6 {
  SELECT x FROM fire ORDER BY x;
} {3 4}
do_execsql_test insert-17.7 {
  DELETE FROM t2;
  DELETE FROM fire;
  INSERT INTO t2(a,b) VALUES(1,1),(2,2),(3,3),(4,4);
  UPDATE OR REPLACE t2 SET a=1, b=3 WHERE a=1;
  SELECT *, 'x' FROM t2 ORDER BY a;
} {1 3 x 2 2 x 4 4 x}
do_execs(a,b,c,d) VALUES(1,1,1,1),(2,1,3,2),(3,4,5,6);
  CREATE TRIGGER t3r1 AFTER DELETE ON t3 BEGIN
    SELECT 'hi';
  END;
  REPLACE INTO t3(a,b,c,d) VALUES(4,4,8,9);
} {}
do_execsql_test insert-17.11 {
  SELECT *, 'x' FROM t3 ORDER BY a;
} {1 1 1 1 x 2 1 3 2 x 4 4 8 9 x}
do_execsql_test insert-17.12 {
  REPLACE INTO t3(a,b,c,d) VALUES(5,1,11,2);
  SELECT *, 'x' FROM t3 ORDER BY a;
} {1 1 1 1 x 4 4 8 9 x 5 1 11 2 x}

do_execsql_test insert-17.13 {
  DELETE FROM t3;
  INSERT INTO t3(a,b,c,d) VALUES(1,1,1,1),(2,1, t3.b}}
do_catchsql_test insert-17.15 {
  REPLACE INTO t3(a,b,c,d) VALUES(5,1,11,2);
} {1 {UNIQUE constraint failed: t3.d}}


fi