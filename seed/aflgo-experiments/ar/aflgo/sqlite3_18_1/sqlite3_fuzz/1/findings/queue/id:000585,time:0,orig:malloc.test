# 2001 Septemberor disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#*****************************************
#
# This file attempts to check the behavior of the SQLite library in 
# an out-of-memory situation. When compiled with -DSQLITE_DEBUG=1, 
# the SQLite library accepts a special command (sqlite3_memdebug_fail N C)
# which causes the N-th malloc to fail.  This special feature is used
# to see what happens in the library if a malloc were to really fail
# due to an out-of-memory situation.
#
# $Id: malloc.test,v 1.81 2009/06/24 13:13:45 drh Exp $

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set ::testprefix malloc


# Only run these tests if memory debugging is turned on.
#
source $testdir/malloc_common.tcl
if {!$MEMDEBUG} {
   puts "Skipping malloc tests: not compiled with -DSQLITE_MEMDEBUG..."
   finish_test
   return
}

# Do a couple of memory dumps just to exercise the memory dump logic
# that that we can say that we have.
#
puts stderr "This is a test.  Ignore the error that follows:"
sqlite3_memdebug_dump $testdir
puts "Memory dump to file memdump.txt..."
sqlite3_memdebug_dump memdump.txt

ifcapable bloblit&&subquery {
  do_malloc_test 1 -tclprep {
    db close
  } -tclbody {
    if {[catch {sqlite3 db test.db}]} {
      error "out of memory"
    }
    sqlite3_extended_result_codes db 1
  } -sqlbody {
    DROP TABLE IF EXISTS t1;
    CREATE TABLE t1(
       a int, b float, c double, d text, e varchar(20),
       primary key(a,b,c)
    );
    CREATE INDEX i1 ON t1(a,b);
    INSERT INTO t1 VALUES(1,2.3,4.5,'hi',x'746865726500');
    INSERT INTO t1 VALUES(6,7.0,0.8,'hello','out yonder');
    SELECT * FROM t1;
    SELECT avg(b) FROM t1 GROUP BY a HAVING b>20.0;
    DELETE FROM t1 WHERE a IN (SELECT min(a) FROM t1);
    SELECT count(*), group_concat(e) FROM t1;
    SELECT b FROM t1 ORDER BY 1 COLLATE nocase;
  } 
}

# Ensure that no file descriptors were leaked.
do_test malloc-1.X {
  catch {db close}
  set sqlite_open_file_count
} {0}

ifcapable subquery {
  do_malloc_test 2 -sqlbody {
    CREATE TABLE t1(a int, b int default 'abc', c int default 1);
    CREATE INDEX i1 ON t1(a,b);
    INSERT INTO t1 VALUES(1,1,'99 abcdefghijklmnopqrstuvwxyz');
    INSERT INTO t1 VALUES(2,4,'98 abcdefghijklmnopqrstuvwxyz');
    INSERT INTO t1 VALUES(3,9,'97 abcdefghijklmnopqrstuvwxyz');
    INSERT INTO t1 VALUES(4,16,'96 abcdefghijklmnopqrstuvwxyz');
    INSERT INTO t1 VALUES(5,25,'95 abcdefghijklmnopqrstuvwxyz');
    INSERT INTO t1 VALUES(6,36,'94 abcdefghijklmnopqrstuvwxyz');
    SELECT 'stuff', count(*) as 'other stuff', max(a+10) FROM t1;
    UPDATE t1 SET b=b||b||b||b;
    UPDATE t1 SET b=a WHERE a in (10,12,22);
    INSERT INTO t1(c,b,a) VALUES(20,10,5);
    INSERT INTO t1 SELECT * FROM t1
        WHERE a IN (SELECT a FROM t1 WHERE a<10);
    DELETE FROM t1 WHERE a>=10;
    DROP INDEX i1;
    DELETE FROM t1;
  } 
}

# Ensure that no file descriptors were leaked.
do_test malloc-2.X {
  catch {db close}
  set sqlite_open_file_count
} {0}

do_malloc_test 3 -sqlbody {
  BEGIN TRANSACTION;
  CREATE TABLE t1(a int, b int, c int);
  CREATE INDEX i1 ON t1(a,b);
  INSERT INTO t1 VALUES(1,1,99);
  INSERT INTO t1 VALUES(2,4,98);
  INSERT INTO t1 VALUES(3,9,97);
  INSERT INTO t1 VALUES(4,16,96);
  INSERT INTO t1 VALUES(5,25,95);
  INSERT INTO t1 VALUES(6,36,94);
  INSERT INTO t1(c,b,a) VALUES(20,10,5);
  DELETE FROM t1 WHERE a>=10;
  DROP INDEX i1;
  DELETE FROM t1;
  ROLLBACK;
} 


# Ensure that no file descriptors were leaked.
do_test malloc-3.X {
  catch {db close}
  set sqlite_open_file_count
} {0}

ifcapable subquery {
  do_malloc_test 4 -sqlbody {
    BEGIN TRANSACTION;
    CREATE TABLE t1(a int, b int, c int);
    CREATE INDEX i1 ON t1(a,b);
    INSERT INTO t1 VALUES(1,1,99);
    INSERT INTO t1 VALUES(2,4,98);
    INSERT INTO t1 VALUES(3,9,97);
    INSERT INTO t1 VALUES(4,16,96);
    INSERT INTO t1 VALUES(5,25,95);
    INSERT INTO t1 VALUES(6,36,94);
    UPDATE t1 SET b=a WHERE a in (10,12,22);
    INSERT INTO t1 SELECT * FROM t1
       WHERE a IN (SELECT a FROM t1 WHERE a<10);
    DROP INDEX i1;
    DELETE FROM t1;
    COMMIT;
  } 
}

# Ensure that no file descriptors were leaked.
do_test malloc-4.X {
  catch {db close}
  set sqlite_open_file_count
} {0}

ifcapable trigger {
  do_malloc_test 5 -sqlbody {
    BEGIN TRANSACTION;
    CREATE TABLE t1(a,b);
    CREATE TABLE t2(x,y);
    CREATE TRIGGER r1 AFTER INSERT ON t1 WHEN new.a = 2 BEGIN
      INSERT INTO t2(x,y) VALUES(new.rowid,1);
      INSERT INTO t2(x,y) SELECT * FROM t2;
      INSERT INTO t2 SELECT * FROM t2;
      UPDATE t2 SET y=y+1 WHERE x=new.rowid;
      SELECT 123;
      DELETE FROM t2 WHERE x=new.rowid;
    END;
    INSERT INTO t1(a,b) VALUES(2,3);
    COMMIT;
  } 
}

# Ensure that no file descriptors were leaked.
do_test malloc-5.X {
  catch {db close}
  set sqlite_open_file_count
} {0}

ifcapable vacuum {
  do_malloc_test 6 -sqlprep {
    BEGIN TRANSACTION;
    CREATE TABLE t1(a);
    INSERT INTO t1 VALUES(1);
    INSERT INTO t1 SELECT a*2 FROM t1;
    INSERT INTO t1 SELECT a*2 FROM t1;
    INSERT INTO t1 SELECT a*2 FROM t1;
    INSERT INTO t1 SELECT a*2 FROM t1;
    INSERT INTO t1 SELECT a*2 FROM t1;
    INSERT INTO t1 SELECT a*2 FROM t1;
    INSERT INTO t1 SELECT a*2 FROM t1;
    INSERT INTO t1 SELECT a*2 FROM t1;
    INSERT INTO t1 SELECT a*2 FROM t1;
    INSERT INTO t1 SELECT a*2 FROM t1;
    DELETE FROM t1 where rowid%5 = 0;
    COMMIT;
  } -sqlbody {
    VACUUM;
  } 
}

autoinstall_test_functions
do_malloc_test 7 -sqlprep {
  CREATE TABLE t1(a, b);
  INSERT INTO t1 VALUES(1, 2);
  INSERT INTO t1 VALUES(3, 4);
  INSERT INTO t1 VALUES(5, 6);
  INSERT INTO t1 VALUES(7, randstr(1200,1200));
} -sqlbody {
  SELECT min(a) FROM t1 WHERE a<6 GROUP BY b;
  SELECT a FROM t1 WHERE a<6 ORDER BY a;
  SELECT b FROM t1 WHERE a>6;
}

# This block is designed to test that some malloc failures that may
# occur in vdbeapi.c. Specifically, if a malloc failure that occurs
# when converting UTF-16 text to integers and real numbers is handled
# correctly. 
#
# This is done by retrieving a string from the database engine and
# manipulating it using the sqlite3_column_*** APIs. This doesn't 
# actually return an error to the user when a malloc() fails.. That 
# could be viewed as a bug.
#
# These tests only run if UTF-16 support is compiled in.
#
ifcapable utf16 {
  set ::STMT {}
  do_malloc_test 8 -tclprep {
    set sql "SELECT '[string repeat abc 20]', '[string repeat def 20]', ?"
    set ::STMT [sqlite3_prepare db $sql -1 X]
    sqlite3_step $::STMT
    if { $::tcl_platform(byteOrder)=="littleEndian" } {
      set ::bomstr "\xFF\xFE"
    } else {
      set ::bomstr "\xFE\xFF"
p {
    if {$::STMT!=""} {
      sqlite3_finalize $::STMT
      set ::STMT {}
    }
  }
}

# This block tests that malloc() failures that occur whilst commiting
# a multi-file transaction are handled correctly.
#
do_malloc_test 9 -sqlprep {
  ATTACH 'test2.db' as test2;
  CREATE TABLE abc1(a, b, c);
  CREATE TABLE test2.abc2(a, b, c);
} -sqlbody {
  BEGIN;
  INSERT INTO abc1 VALUES(1, 2, 3);
  INSERT INTO abc2 VALUES(1, 2, 3);
  COMMIT;
}

# This block tests malloc() failures that occur while opening a 
# c{
    set rc [crashsql -delay 1 -file test2.db {
      ATTACH 'test2.db' as aux;
      PRAGMA cache_size = 10;
      BEGIN;
      CREATE TABLE aux.t2(a, b, c);
      CREATE TABLE t1(a, b, c);
      COMMIT;
    }]
    if {$rc!="1 {child process exited abnormally}"} {
      error "Wrong error message: $rc"
    }
  } -tclbody {
    db eval {ATTACH 'test2.db' as aux;}
    set rc [catch {db eval {
      SELECT * FROM t1; 
      SELECT * FROM t2;
    }} err]
    if {$rc && $err!="no such table: t1"} {
      errordb 1 1 1} msg]} {
      if {$msg=="SQLITE_NOMEM"} {set msg "out of memory"}
      error $msg
    }
  
    db complete {SELECT "hello """||'world"' [microsoft], * FROM anicetable;}
    db complete {-- Useful comment}
  
    execsql {
      CREATE TABLE t1(ages.
#
do_malloc_test 16 -tclbody {
  db complete {SELECT "hello """||'world"' [microsoft], * FROM anicetable;}
  db complete {-- Useful comment}
  db eval {
    SELECT * FROM sqlite_master;
  }
}

# Test handling of malloc() failures in sqlite3_open16().
out of memory"
    }
    sqlite3_extended_result_codes db 1
  } -sqlbody {
    ATTACH DATABASE 'test2.db' AS t2;
    SELECT * FROM t1;
    DETACH DATABASE t2;
  } 
}

# Test malloc failure whilst installing a foreign key.
#
ifcapable foreignkey {
  do_mallROM t1;
    ROLLBACK;
  }
} -sqlbody {
  -- This statement requires the 'no-content' pages loaded by the DELETE
  -- statement above. When requesting the pages, the content is loaded
  -- from the database file. The point of this test case is to test handlTE TABLE t1(a PRIMARY KEY, b);
    INSERT INTO t1 VALUES(1, 'one');
    INSERT INTO t1 VALUES(2, 'two');
    INSERT INTO t1 VALUES(3, 'three');
    COMMIT;
    PRAGMA locking_mode = exclusive;
  }

  # Open a second database connection. Load the table (butn its cache. If this is
  # one of the magic iterations and the change counter was not modified,
  # then it won't realize that the cached data is out of date. Since
  # the cached data won't match the up to date index data read from
  # the database file, configuration.
#
do_malloc_test 39 -tclprep {
  sqlite3 db test.db
} -sqlbody {
  SELECT test_auxdata('abc', 'def');
} -cleanup {
  db close
}

reset_db
add_test_utf16bin_collate db
do_execsql_test 40.1 {
  CREATE TABLE t1(a);
  INSERT INTO t1 VALUES('fghij');
  INSERT INTO t1 VALUES('pqrst');
  INSERT INTO t1 VALUES('abcde');
  INSERT INTO t1 VALUES('uvwxy');
  INSERT INTO t1 VALUES('klmno');
}
do_execsql_test 40.2 {
  SELECT * FROM t1 ORDER BY 1 COLLATE utf16bin;
} {abcde fghij klmno pqrst uvwxy}
do_faultring repeat x 200]
do_execsql_test 41.1 {
  DROP TABLE IF EXISTS t1;
  CREATE TABLE t1(a COLLATE utf16bin);
  INSERT INTO t1 VALUES('fghij' || $::big);
  INSERT INTO t1 VALUES('pqrst' || $::big);
  INSERT INTO t1 VALUES('abcde' || $::big);
  INSERT INTO t1 VALUES('uvwxy' || $::big);
  INSERT INTO t1 VALUES('klmno' || $::big);
  CREATE INDEX i1 ON t1(a);
}
do_faultsim_test 41.2 -faults oom* -body {
  execsql { SELECT * FROM t1 WHERE a = ('abcde' || $::big)}
} -test {
  faultsim_test_result [list 0 "abcde$::ure that no file descriptors were leaked.
do_test malloc-99.X {
  catch {db close}
  set sqlite_open_file_count
} {0}

puts open-file-count=$sqlite_open_file_count
finish_test
