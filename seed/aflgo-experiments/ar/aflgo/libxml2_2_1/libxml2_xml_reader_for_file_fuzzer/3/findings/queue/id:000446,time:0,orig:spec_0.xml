<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article [
<!-- ELEMENT declarations work around MSXML bug. -->
<!ELEMENT section ANY>
<!ATTLIST section id ID #IMPLIED>
<!ELEMENT appendix ANY>
<!ATTLIST appendix id ID #IMPLIED>
<!ELEMENT bibliomixed ANY>
<!ATTLIST bibliomixed id ID #IMPLIED>
]>
<article status="Committee Specification" xmlns:p="http://relaxng.org/ns/proofsystem">

<articleinfo>
<releaseinfo>$Id: spec.xml,v 1.159 2001/12/02 12:12:12 jjc Exp $</releaseinfo>
<title>RELAX NG Specification</title>
<authorgroup>
<editor>
  <firstname>James</firstname><surname>Clark</surname>
  <affiliation>
    <address><email>jjc@jclark.com</email></address>
  </affiliation>
</editor>
<editor>
  <surname>MURATA</surname><firstname>Mako document and translations of it may be copied and furnished
to others, and derivative works that comment on or otherwise explain
it or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to OASIS, except as needed for the
purpose of developing OASIS specifications, in which case the
procedures for copyrights defineerty
Rights document must be followed, or as required to translate it into
languages other thars or assigns.</para>

<para>This document and the informationn an <quote>AS IS</quote> basis  of the committee. Comments on this document
may be sent to <ulink
url="mailto:relax-ng-comment@lists.oasis-open.org"
>relax-ng-comment@lists.oasis-open.org</ulink>.</para>

<para>A list of known errors in this document is available at <ulink
url="htmple
schema language for XML, based on <xref linkend="relax"/> and <xref
linkend="trex"/>. A RELAX NG schema specifies a patteistory>
<revision>
  <revnumber>Committee Specification</revnudate>
</revision>
<revision>
  <revnumber>Committee Specification</revnumber>
  <date>11 August 2001</date>
</revision>
</
<section>
<title>Introduction</title>

<para>This document specifies</para>

<itemizedlist>

<listitem><para>when an XML document is a correct RELAX NG
schema</para></listitem>

<listitem><para>when an XML document is valid with respect to a
coLAX NG
schema is referred to as an instance.</para>

<para>The structure of this document is as follows.  <xref
linkend="dat.  <xref linkend="simplification"/> describes a sequence of
transformations that are applied to simplify a RELAX NG schema;
applying the transformations also involves checking certain
restrictions that must be satisfied by a correct RELAX NG
schema. <xibute consists of</para>

<itemizedlist>
<listitem><para>a name</para></listitem>
<listitem><para>a string representing the  is as defined in <xref linkend="xml-rec"/>.</para>

<para>The element for an XML document is constructed from an instance
oft are constructed from the list of child
information items first by removing information items other than
element information items, and then by
constructing an element for each element information item in the list
and a string for each maximal sequence of character information items.
An attribute is constructed from an attribute information ite the [namespace name] and [local[normalized value].  When constructing the name of
an element or attribute from the [namespace name] and [local name], if
the [namespace name] property is nothere is exactly one
infoset for which [all declarations processed] is true and which does
not contain any unexpanded entity reference information items.  This
is the infoset that is the basis for defining the RELAX NG data
model.</para>

<section id=><pre2:bar2
  xmlns:pre2="http://www.example.com/n2"/></foo>
]]></programlisting>

<para>The element representing this document has</para>

<itemizedlist>
<listitem><para>a name which has</para>
<itemizedlist>

<listitem><para>the empty string as the namespace URI, representing
the absence of any namespace</para></listitem>

<listitem><para><literal>foo</literal> as the local
name</para></listitem>

</itemizedlist>

</listitem>

<listitem><para>a context which has</para>

<itemizedlistas</para>
<itemizedlist>

<listitem><para><literal>http://www.example.com/n1</literal> as the>

<listitem><para><literal>bar1</literal> as the local
name</para></listitem>

</itemizedlist>

</listitem>

<listitemliteral>pre1</literal> to the
namespace URI
<literal>http://www.example.com/n1</literal></para></listitem>

<listitem><para>stitem>

<listitem><para>specifies the empty string as the defitem>

</itemizedlist>

</listitem>

</itemizedlist>

</listitem>

<listitem><para>an empty set of attributes</para></listitem>

<listitem><para>an empty sequence of children</para></listitem>

</itemizedlist>

<para>followed by an element which has</para>
 
<itemizedlist>
<listitem><para>a name which has</para>
<itemizedlist>

<listitem><para><literal>http://www.example.com/n2</literal> as the
namespace URI</para></listitem>

<listitem><para><literal>bar2</literal> as the local
name</para></listitem>

</itemizedlist>

</listitem>

<listiara>

<itemizedlist>
<listitem><para><literal>http://www.examara></listitem>

<listitem><para>maps the prefix <literal>xml</literal> to the
namespace URI
<literal>http://www.w3.org/XML/1998/namespace</literal></para></listitem>

<listitem><para>specifies the empty string as the default namespace
URI</para></listitem>

</itemizedlist>

</listitem>

</itemizedlist>

</listitem>

<listitem><para>an empty set of attributes</para></listitem>

<listitem><para>an empty sequence of children</para></listitem>

</itemizedlist>

</listitem>
</itemizedlises the syntax of RELAX NG.
Although we use a notation based on haracters, the grammar must be understood
as operating at the data model level.  For example, although the
syntax uses <literal><![CDATA[<text/>]]></literal>,<literal><![CDATA[<text></text>]]></literal> instead,
because the
<literal>grammar</literal> ehe preceding
paragraph) followed by the children of the <literal>include</literal>
element.  The <literal>grammar</literal> element is then renamed to
<literal>div</literal>.</para>

</section>

<section>
<title><literal>name</literal> attribute of <literal>element</literal>
and <literal>attribute</literal> elements</title>

<para>The <literal>name</literal> attribute on</section>

<section>
<title><literal>ns</literal> attribute</title>

<para>For any <literal>name</literal>, <literal>nsName</literal> or
<literal>value</literal> element that does not have an
<literal>ns</literal> attribute, an <literal>ns</literalte of the nearest ancestor
elemeral> attribute, or the empty
string if there is no such ancests role="strong">not</emphasis> transformed either by escaping
disallowed characters, or in any other way, because the value of the
<literal>ns</literal> attribute is compared against namespaare not subject to any
transforhe
prefix is removed and an <literal>ns</literal> attribute is he value of
the added <literal>ns</literal> attribute is the value to which the
namespace map of the context of the <literal>nit has
exactly two child elements. If it has one child element, then it is
replaced by its child element.  If it has more than two child
elements, then the first two child elements are combined into a new
element with the same name as the parent elemenone. The
transformation is applied repeatedly until there are exactly two child
elements.</para>

</section>

<section>
<al>mixed</literal> element is transformed into an
interleaving with a <literal>text</literal> element:</para>

<programlisting>&lt;mixed> <replaceable>p</replaceable> &lt;/mixed></programlileave></programlisting>

</section>

<section>
<title><literal>optional</literal> element</title>

<para>An <literal>optional</literal> element is transformed into
a choice with <literal>empty</literal>:</para>

<placeable>p</replaceable> &lt;/optional></programlisting>

<para>is transformed into</para>

<programlisting>&lt;choice> <repformation is performed, but various
constraints are checked.</para>

<note><para>The constraints in this section, unlike the constraints
specified in <xref linkend="restriction"/>, can be checked without
resolving any <literal>ref</literal> elements, and are accordingly
applied even to patterns that will disappear during later stages of
simpliachable (see <xref
linkend="define-ref"/>) or because of <literal>notAllowed</literal>
(see <xra></note>

<para>An <literal>not also be a
<literal>define</
<literal>interleave</literal>. Thus, for any name, if there is more
than one <literal>define</literal> element with that name,le>p2</replaceable>
  &lt;/<replaceable>c</replaceable>&gt;
&lt;/define></programlisting>

<para>where <replaceable>c</repla <literal>define</literal> element
for each name.</para>

<para>Similarly, for each <literal>grammar</literal> element all
<literal>start</literal> elements are combined together.  There must
not be more than one <literal>start</literal> element that does not
have a <literal>combine</literal> attribute.  If there is a
<literal>start</literal> element that has a <literal>combine</literal>
attribute with the value <literal>choice</literalat has a
<literal>combine</literal> attribute with the value
<literal>interleave</literal>.</para>

</section>

<section>ment that has one
<literal>empty</literal> child element is transformed into its other
child element.  A <literal>choice</literal> element whose
second child element is an <literal>empty</literal> element is
transformed by interchanging its two child elements.  A
<literal>oneOrMore<iteral>empty</literal> element. The preceding transformations are applied
repeatedly until none of them is applicable any more.on>

<section id="simple-syntax">
<title>Simple syntax</titlee rules in <xref
linkend="simplification"/>, the schema will match the following
grammar:</para>

<grammarref src="simple.rn-syntax-example"/> can be transformed into the simple
syntax:</para>

<programlisting><![CDATA[<?xml version="1.0"?>
<grammar xmlns="http://relaxng.org/ns/structure/1.0">
  <start>
    <ref name="foo.element"/>
  </start>

  <define name="foo.elemwww.example.com/n1">bar1</name>
      <empty/>
    </element>
  </define>

  <define name="bar2.element">
    <element>
      <name ns="http://www.example.com/n2">bar2</name>
      <empty/>
    </element>
  </define>
</grammar>]]></programlisting>

<note><para>Strictly speaking, the result of simplificatio  For
convenience, we use an XML document to represent an instance of the
data model.</para></note>

</section>

</sectionitle>

<para>The axioms and inference rules for patterns use t
<variablelist>

<varlistentry><term><p:var range="context"/></term><listitem><para>ranges
over contexts (as defined in <xref
linkend="data-model"/>)</paraered
the same as that member; the sequences ranged over by <p:var
range="mixed"/> may contain consecutive strings and may contain strings
that are empty; thuer by <p:var
range="mixed"/> that cannot occur as the children of an
element</para></listitem></varlistentry>

<varlistentry><term><p:var range="pattern"/></term><listitem><para>ranges
ov:rule name="choice 1">

    <p:judgement name="match">
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:var range="pattern" sub="1"/>
    t" sub="1"/>
	<p:var range="att" sub="2"/>
      </p:function></term><listitem>
<para>represents the union of <p:var range="att" sub="1"/>
and <p:var range="att" sub="2"/></para>
</listitem>
</varlistentry>

</variablelist>

<para>The semantics of the <literal>group</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="group">

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="1"/>
      <p:var range="mixed" sub="1"/>
      <p:on>
      <p:element name="oneOrMore">
        <p:var range="pattern"/>
      </p:element>
    </p:judgement>
  </p:rule>

</p:proofSystem>

</section>


<section>
<title><literal>interleave</literal> pattern</title>

<para>We use the followgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="1"/>
      <p:var range="mixed" sub="1"/>
      <p:var range="pattern" sub  <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="2"/>
      <p:var range="mixed" sub="2"/>
      <p:var range="pattern" sub="2"/>
    </p:judgemennction name="union">
	<p:var range="att" sub="1"/>
	<p:var range="att" sub="2"/>
      </p:function>
      <p:var range="mixed" sub="3"/>
      <p:element name="interleave">
	<p:var range="pattern" sub="1"/>
	<p:var range="pattern" sub="2"/>
      </p:element>
    </p:judgement>

  </p:rule>

</p:proofSystem>

<note><para>The restriction in <xref linkend="attribute-r set of attributes constructed in the consequent will
not have multiple attributes with the samment name="weakMatch">
      <p:var range="context" sub="1"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      arameters. For example, a string datatype might have a parameter
specifying the length of a string.  The datatype library determines
what parameters are applicable for each datatype.</para></listitem>

<listitem><para>It can determine whether two strinot have any
parameters.</para></listitem>

</itemizedlist>

<para>Both services may make use of the context of a string.  For
example, a datatype representing a QName would use the namespace
map.</para>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:judgement name="datatypeAllows">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="params"/>
      <p:var range="string"/>
      <p:var range="context"/>
    </p:judgement></term><listitem><para>
    
asserts that in the datatype library identified by URI <p:var range="uri"/>, the string <p:varth
context <p:var range="contextext" sub="1"/>
      <p:var range="string" sub="2"/>
      <p:var range="context" sub="2"/>
    </p:judgement>
  </p:rule>list</literal> pattern</title>

<para>We use the following add  </p:function></term><listitem><para>
      
returns a sequence of strings one for each whitespace delimited token
of <p:varn the returned sequence will
be non-empty and will not contain any
whitespace</para></listitem></varlistentry>

</variablelie <literal>list</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="list">

    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="est a pattern can contain consecu</section>

</section>

<section id="validity">
<title>Valiation:</para>

<variablelist>

<varlistentry><term><p:var ra="element">
  <p:function name="name">
    <p:function name="emptyString"/>
    <p:string>foo</p:string>
  </p:function>
  >
  <p:var range="mixed"/>
</p:function>

</p:formula>

<para>where <p:var range="mixed"/> is</para>

<p:formula>
  <p:var range="element" sub="1"/>
 ormula>
  <p:function name="element">
    <p:function name="name">
      <p:string>http://www  <p:string>bar2</p:string>
    </p:function>
    <p:var range="context" sub="2"/>
    <p:function name="emptySet"/>
    <p:function name="emptySequence"/>
  </p:function>
</p:formula>

<para>Assuming appropriate definitions of <p:var range="context"
sub="0"/>, <p:var range="context" sub="1"/> and <p:var range
      <p:string>foo</p:string>
    </p:element>
    <p:element name="group">
      <p:element name="ref">
	<p:attribute nam</p:element>
      <p:element name="ref">
	<p:attribute name=":element>
    </p:element>
  </p:judgement>
</p:formula>

<ent>
    <p:element name="empty"/>
  </p:judgement>
</p:formunt name="bind">
    <p:string>bar2.element</p:string>
    <p:element name="name">
      <p:attribute name="ns">
	<p:string>http://www.example.com/n2</p:stri/p:formula>


<para>Let name class <p:var range="nameClass" sub="1"/> be</para>

<p:formula>
  <p:element name="name">
  g>
  </p:element>
</p:formula>

<para>and let <p:var range="nameClass" sub="2"/> be</para>

<p:formula>
  <p:element namep:formula>

<para>and</para>

<p:formula>
  <p:judgement name="belongs">
    <p:function name="name">
      <p:string>http://www.example.com/n2</p:string>
      <p:string>bar2</p:string>
    </p:function>
    <p:var range="nameClass" sub="2"/>
 :formula>
  <p:judgement name="match">
    <p:var range="context" sub="1"/>
    <p:function name="emptySet"/>
    <p:function name="emptySequence"/>
    <p:element name="empty"></p:element>
  </p:judgement>
</p:formula>

<para>and</para>

<p:forme="emptySequence"/>
    <p:element name="empty"></p:element>
  </p:judgement>
</p:formula>

<para>Thus by the inference rule (element) in <xref
linkend="element-pattern"/>, we have</para>

<p:formula>
  <p:judgement name="match">
    <p:var range="context" sub="0"/>
    <p:function name="emptySet"/>
    <p:var range="element" sub="1"/>
    <p:element name="ref">
     sub="0"/>, since any context is allowed.</para>

<para>Likewise, we have</para>

<p:formula>
  <p:judgement name="match">
    <p:var range="context" sub="0"/>
    <p:function name="emptySet"/>
    <p:var range="elemame="ref">
      <p:attribute name="name">
        <p:string>bar2</p:string>
      </p:attribute>
    </p:element>
  </p:judgement>
</p:formula>

<para>By the inference rule (group) in <xref
linkend="choice-pattern"/>, we have</para>

<p:formula>
  <p:judgement name="match">
    <p:var range="context" sub=ange="element" sub="2"/>
    </p:function>
    <p:element nameme="name">
          <p:string>bar1</p:string>
        </p:att   <p:element name="ref">
     
<p:formula>
  <p:judgement name="match">
    <p:var range="context" sub="3"/>
    <p:function name="emptySet"/>
    <p:fun>
    </p:function>
    <p:element name="ref">
      <p:attribute name="name">
        <p:string>foo</p:string>
      </p:attribute>
    </p:element>
  </p:judgement>
</p:formula>

<para>Here <p:var range="context" sub="3"/> is an arbitrary
cont>
  <p:judgement name="valid">
    <p:var range="element" sub="0"/>
  </p:judgement>
</p:formula>

</section>

</sectionr has
been transformed to the simple form described in <xref
linkend="simple-syntax"/>. The purpose of these restrictions is tctions</title>

<para>In this section we describe restrictions on where elements are
allowed in the schema based on the names of the ancestor elements. We
use the concept of a <firstterm>prohibited path</firstterm> to
describe these restrictions. A paal name
of the element is <replpara></listitem>

<listitem><para>An element matches a path
<replaceable>x</replaceable><literal>//</literal><replaceable>p</replaceable>,
where <replaceable>x</replaceable> is an NCName and
<replaceable>p</replaceable> is a path, if and only if the local name
of the element is <replaceable>x</replaceable> and the element has a
descendant that matches <replaceable>p</replaceable></para></listitem>

</itemizedlist>

<para>For example, the element</para>

<programlisting><![CDATA[<foo>
  <bar>
    <baz/>
  </bar>
</foo>]]></programlisting>

<para>matches the paths <literal>foo</literal>,
<literal>foo/bar</literal>, <literal>foo//bar</literal>,
<literal>foo//baz</literal>, <literal>foo/bar/baz</literal>,
<literal>foo/bar//baz</literal> and <literal>foo//bar/baz</literal>,
but not <literal>foo/baz</litimple form, it does not contain any element
that matches a prohibited path.</para>

<section>
<title><literal>attribute</literal> pattern</title>

<para>The following paths are prohibited:</para>

<itemizedlist>
<li/ref</literal></para></listitem>
<listitem><para><literal>attribute//attribute</literal></para></listitem>
</itemizedlist>

<title><literal>list</literal> pattern</title>

<para>The following paths are prohibited:</para>

<itemizedlist>
<listitem><para><literal>list//list</literal></para></listitem>
<listitemal></para></listitem>
<listitem><para><literal>list//attribute</literal></para></listitem>
<listitem><para><literal>list//text</literal></para></listitem>
<listitem><para><literal>list//interleave</literal></para></listitem>
</itemizedlist>
</section>

<section id="context-data-exal> pattern</title>

<para>The following paths are prohibited:</para>

<itemizedlist>
<listitem><para><literal>data/except//attribute</literal></para></listitem>
<listitem><para><literal/para></listitem>
<listitem><para><literal>start//value</literal></para></listitem>
<listitem><para><literal>start//text</literal></para></listitem>
<listitem><para><literal>start//list</literal></para></listitem>
<listitem><para><literal>start//group<em>
<listitem><para><literal>start//oneOrMore</literal></para></listitem>
<listitem><para><lit</section>

</section>

<sec<para>RELAX NG does not allow a pattern such as:</para>

<programlisting><![CDATA[<element name="foo">
  <group>
    <data type="int"/>
    <element name="bar">
      <empty/>
    </ele</programlisting>

<para>Nor does it allow a pattern such as:<ra>a pattern that matches a single string (that is, a
<literal>data</literal>, <literal>value</literal> or
<literal>list</literal> pattern),</para></listitem>

</itemizedlist>

<para>then the two patterns must be alternatives to each other.</para>

<para>This rule does not apply to patterns occurring within a
<literal>list</literal> pattern.</para>

<para>To formalize this, we use the concept of a content-type.  A
pattern that is allowable as the content of an eleypes: empty, complex and simple.  We use the following
notation.</para>

<variablelist>

<varlistentry>
<term><p:function name="empty"/></term>
<listitem><para>returns the empty content-type</para></listitem>
</varlistentry>

<varlistentry>
<terlistentry>

<varlistentry><term><p:var range="contentType"/></er content-types</para></listitem>
</varlistentry>

<varlistentry><term>
  <p:judgement name="groupable">
    <p:var range="contentType" sub="1"/>
    <p:var range="contentType" sub="2"/>
  </p:judgement>
</term>
<listitem><para>asserts that the content-types <p:var
range="contDescription</ulink></citetitle>.
W3C (World Wide Web Consortium), 2001.</bibliomixed>

<bibliomixed id="tutorial"><abbrev>Tutial.html">RELAX
NG Tutorial</ulink></citetitle>.  OASIS, 2001.</bibliomixed>

</bibliodiv>

</bibliography>

</article>
