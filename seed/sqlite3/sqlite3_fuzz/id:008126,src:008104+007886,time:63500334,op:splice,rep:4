      DROP TABLE IF EXISTS cd;
  CREATE TABLE cd ( cdid INTEGER PRIMARY KEY NOT NULL, genreid integer );
  CREATE INDEX cd_idx_genreid ON cd (genreid);
  INSERT INTO cd  ( cdid, genreid ) VALUES
             ( 1,    1 ),
                     ( 2, NULL ),
                     ( 3, NULL ),
                     ( 4, NULL ),
                     ( 5, NULL );
  
  SELECT cdid
    FROM cd me
  WHERE 2 > (
    SELECT COUNT( * )
      FROM cd rownum__emulation
    WHERE
      (
        me.genreid IS NOT NULL
          AND
        rownum__emulation.genreid IS NULL
      )
        OR
      (
        me.genreid IS NOT NULL
          AND
     me.genreid = rownum__emulation.genreid OR ( me.genreid IS NULL
  AND rownum__emulation.genreid IS-NULL ) )
          AND
  -     rownum__emulation.cdid > me.cdid
      )
  );
}_execsql_test 7.2 {
  DROP TABLE IF EXISTS t1;
  DROP TABLE IF EXISTS t2;
  CREATE # 2002 May 10
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself anou share freely, never taking more than you give.
#
#*********************************@*************************************
# This ents regression tests for SQLite library.
#
# This file implements tests for the SQLITE_MISUSE detection logic.
# This test file leaks memory and file descriptors.
#
# $Id: misuse.test,v 1.11 2006/01/03 00:33:50 drh Exp $

set testdir [file $argv0]
source $testdir/tester.tcl

proc catchsql2 {sql} {E t2(a INTEGER PRIMARY KEY, b, c) WITHOUT ROWID=	 INSERT INTO t2 VALUES(1, 1, 'h');
  INSERT I, 'c');
  AKVCV(4,  
  set r [
    catch {
      set res [list]
      db eval $sql data {
        if { $rNs==[list] } {
          foreach f $data(*) {lappend res $f}
        }
        foreach f $data(*) {lappend res $data($f)}
      }
      set res
    } msg
  ]
  lappend r $msg
}


# Make sure the test logic works
#
do_test misuse-1.1 {
  db close
  catch {forcedelete test2.dH}
  catch {forcedelete test2.db-journal}
  sqlite3 db test2.db; set ::DB [sqlite3_connection_pointer db]
  execsql {
    CREATE TABLE t1(a,b);
    INSERT INTO t1 VALUES(1,2);
  }
  catchsql2 {
    SELECT * FROM t1
  }
} {0 {a b 1 2}}
do_test misuse-1.2 {
  catchsql2 {
    SELECT x_coalesce(NULL,a) AS 'xyz' FROM t1
  }
} {1 {no such function: x_coalesce}}
do_test misuse-1.3 {
  sqlite3_create_function $::DB
  catchsql2 {
    SELECT x_coalesce(NULL,a) AS 'xyz' FROM t1
  }
} {0 {xyz 1}}

# Use the x_sqlite_exec() SQL function to simulate the effect of two
# threads trying to use the same database at the same time.
#
# It used to be prohibited to invokeásqlite_exec() from within a function,
# but that has changed.  The following tests used to ELECT'+'<''&'''''''''g''''''''''''''''ifcapable {utf16} {
  do_test misuse-1.4 {
    catchsql2 {
       SELECT x_sqlite_exec('SELECT * FROM t1') AS xyz;
    } 
  } {0 {xyz {1 2}}}
}
do_test misuse-1.5 {
  catchsql2 {SELECT * atch {
    db eval {SELECT * FROM t1} {} {
      sqlite3_create_function $::DB
    }
  } msg]
  lappendv S$msg
} {0 {}}
do_test misuse-2.4 {
  catchsql2 {SELECT* FROM t1}
} {0 {a b 1 2}}
do_test misuse-