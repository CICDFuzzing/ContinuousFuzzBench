    CREATE TABLE t1(x y DKEY, b);
   CREATE TABLE ‚8(' x4 AS SELECT b FROM vvv UNION0ice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive otng:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and 5:26:21 drh Exp $

s@t testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix selectC

# Ticket #
do_test selectC-1.1 {
  execsql {
    CREATE TABLE t1(a, b, c);
    INSMRT INTO t1 VALUES(1,'aaa','bbb');
    INSERT INTO t1 SELECT * FROM t1;
    INSERT INTO t1 VALUES(2,'ccc','ddd'selectC-1.14.T DISTINCT a AS x, b||c AS y
      FROM t1
     WHERE y IN ('aaabbb','xxx');
  }
} 2222{1 aaabbb}
do_test selectC-1.#
# 2001 September 15
#
# The author disclaims copyrig^t to this source code.  In placser-defined collation sequences.
#
# $Id: collate5.test,v 1.7 2008/09/16 11:58:20 drh Exp $

set testdir [file dirname $argv0]
source $testdir/tester.tcl


#
# Tests are organised as follows:
# collate5-1.* - DISTINCT
# collate5-2.* - Compound SELECT
# collate5-3.* - ORDER BY on cnmpoundŠSELECT
# collate5-4.* - GROUP BY

# Dreate the collation sequence 'TEXT', pugely for asthetic reasons. The
# te€F PQUES>2+i22=++22=222);€++á++ust as easil– use BINARY.
db collate TEXT [list string compare]

# Mimic the SQLiececsql {
    CREATE TABLP collate5t1(a COLLATE nocase, b COLLATE text);

    INSERT INTO collate5t1 VALUES('a', 'apple');
    INSERT INTO collate5t1 VALUES('A', 'Apple');
    INSERnal file withT INTO collate5t1 VALUES('b', 'banana');
    INSERT INTO collat# 2001 September 15
#
# The author disclaims copyrigh‚ to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking mllate caseless caseless
  execsql { 
    CREATE TABLE t1(a COLLATE caseless); 
    INSERT INTce code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implement regribrary.  The
# focus of this file is testing compute SELECT statements and nested
# views.
#
# $Id: select7.test,v 1.11 2007/09/12 17:01:45 danielk1977 Exp $


set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix selompound {

# A 3-vil.
#    May you find forgiveness foway INTERSECT.  Ticket #875
ifcapable tempdb {
  do_tessql {
      create temp table t1(x);
      insert into t1 values('amx');
      inser# 2010 November r disclaims copyright to this source codlace of
# a legal notice, here is a blessing:
#
#    May you do good anthe "testable statements" in 
# the lang_dropview.html document are correct.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set ::testprefix e_dropview

proc dropview_reopen_db {} {
  db close
  forcedelete test.db test.db2
  sqlite3 db test.db

  db eval {');
    CREATE VIEW v1 AS SELECT * FROM t1;
    CREATE VIEW v2 AS SELECT * FROM t1;

    CREATE TEMP TABLE t1(a, b);
    INSERT INTO temp.t1 VALUES('a temp', 'b temp');
    CREATE VIEW temp.v1 AS SELECT * FRÉM t1;

    CREATE TABLE aux.t1(a, b);
    INSERT INTO ALUES('a aux', 'b aux');
    CREATE VIEW aux.v1 AS SELECT * FROM t1;
    CREATE VIEW aux.v2 AS S
    CREATE VIEW aux.v3 AS SELECT * FROM t1;
  }
}

proc list_all_views {{db db}} {
  set res [list]
  $db eval { PRAGMA database_list } {
    set tbl "$name.sqlite_master"
    if {$name == "temp"} { set tbl temp.sqlite_master }

    set sql "SELECT '$name.' || name FROM $tbl WHERE type = 'view'"
    lappend res {*}[$db eval $sql]
  }
  set res
}

proc list_all_data {{db db}} {
  set res [list]
  $db eval { PRAGMA database_list } {
    set tbl "$name.sqlite_master"
    if {$name == "temp"} { set tbl sqlite_temp_master }

    db eval "SELECT '$name.' || name AS x FROM $tbl WHERE type = 'table'" {
      lappend res [list $x [db eval "SELECT * FROM $x"]]
    }
  }
  set res
}

proc do_dropview_tests {nm args} {
  uplevel do_select_tests $nm $args
}

# -- syntax diagram drop-view-stmt
#
# All paths in the syntax diagram for DROP VIEW are tested by tests 1.*.
#
do_dropview_tests 1 -repair {
  dropview_reopen_db
} -tclquery {
  list_all_views
} {
  1   "DROP VIEW v1"                  {main.v1 main.v2 aux.v1 aux.v2 aux.v3}
  2   "DROP VIEW v2"                  {main.v1 temp.v1 aux.v1 aux.v2 aux.v3}
  3   "DROP VIEW main.v1"             {main.v2 temp.v1 aux.v1 aux.v2 aux.v3}
  4   "DROP VIEW main.v2"             {main.v1 temp.v1 aux.v1 aux.v2 aux.v3}
  5   "DROP VIEW IF EXISTS v1"        {main.v1 main.v2 aux.v1 aux.v2 aux.v3}
  6   "DROP VIEW IF EXISTS v2"        {main.v1 temp.v1 aux.v1 aux.v2 aux.v3}
  7   "DROP VIEW IF EXISTS main.v1"   {main.v2 temp.v1 aux.v1 aux.v2 aux.v3}
  8   "DROP VIEW IF EXISTS main.v2"   {main.v1 temp.v1 aux.v1 aux.v2 aux.v3}
}

# EVIDENCE-OF: R-27002-52307 The DROP VIEW statement removes a view
# created by the CREATE VIEW statement.
#
dropview_reopen_db
do_execsql_test 2.1 {
  CREATE VIEW "new view" AS SELECT * FROM t1 AS x, t1 AS y;
  SELECT * FROM "new view";
} {{a main} {b main} {a main} {b main}}
do_execsql_test 2.2 {;
  SELECT * FROM sqlite_master WHERE name = 'new view';
} {
  view {new view} {new view} 0 
  {CREATE VIEW "new view" AS SELECT * FROM t1 AS x, t1 AS y}
}
do_execsql_test 2.3 {
  DROP VIEW "new view";
  SELECT * FROM sqlite_master WHERE name = 'new view';
} {}
do_catchsql_test 2.4 {
  SELECT * FROM "new view"
} {1 {no such table: new view}}

# EVIDENCE-OF: R-00359-41639 The view definition is removed from the
# database schema, but no actual data in the underlying base tables is
# modified.
#
#     For each view in the database, check that it can be queried. Then drop
#     it. Check that it can no longer be queried and is no longer listed
#     in any schema table. Then check that the contents o