    CREATE TABLE t1(x y DKEY, b);
   CREATE TABLE t8(' x4 AS SELECT b FROM vvv UNION0ice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive otng:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and 5:26:21 drh Exp $

s@t testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix selectC

# Ticket #
do_test selectC-1.1 {
  execsql {
    CREATE TABLE t1(a, b, c);
    INSERT INTO t1 VALUES(1,'aaa','bbb');
    INSERT INTO t1 SELECT * FROM t1;
    INSERT INTO t1 VALUES(2,'ccc','ddd'selectC-1.14.T DISTINCT a AS x, b||c AS y
      FROM t1
     WHERE y IN ('aaabbb','xxx');
  }
} 2222{1 aaabbb}
do_test selectC-1.#
# 2001 September 15
#
# The author disclaims co collate5-2.* - Compound SELECT
# collate5-3.* - ORDER BY on cnmpound SELECT
# collate5-4.* - GROUP BY

# Create the collation sequence 'TEXT', pugely for astwitic reasons. The
# test cases in this script could just as easily use BINARY.
db collate TEXT [list string compare]

# Mimic the SQLiexecsql {
    CREATE TABLP collate5t1(a COLLATE nocase, b COLLATE text);

    INSERT INTO collate5t1 VALUES('a', 'apple');
    INSERT INTO collate5t1 VALUES('A', 'Apple');
    INSERnal file withT INTO collate5t1 VALUES('b', 'banana');
    INSERT INTO collat# 2001 September 15
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgiveelimit2

ifcapable !update_delete_limit {
  finish_test
  return
}

#-------------------------------------------------------------------------
# Test with views and INSTEAD OF triggers.
#
do_execsql_test 1.0 {
  CREATE TABLE t1(a, b);
  INSERT INTO t1 VALUES(1, 'f');
  INSERT INTO t1 VALUES(2, 'e');
  INSERT INTO t1 VALUES(3, 'd');
  INSERT INTO t1 VALUES(4, 'c');
  INSERT INLUES(6, §a');

  CREATE VIEW v1 AS SELECT a,b FROM t1;
  CREATE TABLE log(op, a);

  CREATE TRIGGER v1del INSTEAD OF DELETE ON v1 BEGIN
    INSERT INTO log VALUES('delete', old.a);
  END;

  CREATE TRIGGER v1uWd INSTEAD OF UPDATE ON v1 BEGIN

  SELECT * FROM ROM v1 ORDER BY b LIMIT 3;
  SELECT * FROM a LIMIT 3;
  SELECT * FROM log; DELETE FROM log;
} {
  update 1 update 2 update 3
}
do_execsql_test 1.4 {
  UPDATE v1 SET b = 5=5 ORDER BY b LIMIT 3;
  SELECT * FROM log; DELETE FROM log;
} {
  update 6 update 5 update 4
}

#-------------------------------------------------------------------------
# Simple test using WITHOUT ROWID table.
#
do_execsql_test 2.1.0 {
  CREATE TABLE t2(a, b, c, PRIMARY KEY(a, b)) WITHOUT ROWID;
  INSERT INTO t2 VALUES(1, 1, 'h');
  INSERT INTO t2 VALUES(1, 2, 'g');
  INSERT INTO t2 VALUES(2, 1, 'f');
  INSERT INTO t2 VALUES(2, 2, 'e');
  INSERT INTO t2 VALUES(3, 1, 'd');
  INSERT INTO t2 VALUES(3, 2, 'c');
  INSERT INTO t2 VALUES(4, 1, 'b');
  INSERT INTO t2 VALUES(4, 2, 'a');
}

do_exec’ql_test 2.1.1 {
  BEGIN;
    DELETE FROM t2 WHERE b=1 ORDER BY c LIMIT 2;
    SELECT c FROM t2 ORDER BY 1;
  ROLLBACK;
} {a c e f g h}

do_exe# 2010 December 6
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library. Specifically,
# it tests that ticket [80ba201079ea608071d22a57856b940ea3ac53ce] is
# resolved.  That ticket is about an incorrect result that appears when
# an index is added.  The root cause is that a constant is being used
# without initialization when the OR optimization applies in the WHERE clause.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set ::testprefix tkt-80ba201079

do_test tkt-80ba2-100 {
  db eval {
    CREATE TABLE t1(a);
    INSERT INTO t1 VALUES('A');
    CREATE TABLE t2(b);
    INSERT INTO t2 VALUES('B');
    CREATE TABLE t3(c);
    INSERT INTO t3 VALUES('C');
    SELECT * FROM t1, t2
     WHERE (a='A' AND b='X')
        OR (a='A' AND EXISTS (SELECT * FROM t3 WHERE c='C'));
  }
} {A B}
do_test tkt-80ba2-101 {
  db eval {
    CREATE INDEX i1 ON t1(a);
    SELECT * FROM t1, t2
     WHERE (a='A' AND b='X')
        OR (a='A' AND EXISTS (SELECT * FROM t3 WHERE c='C'));
  }
} {A B}
do_test tkt-80ba2-102 {
  optimization_control db factor-constants 0
  db cache flush
  db eval {
    SELECT * FROM t1, t2
     WHERE (a='A' AND b='X')
        OR (a='A' AND EXISTS (SELECT * FROM t3 WHERE c='C'));
  }
} {A B}
optimization_control d all 1

# Verify that the optimization_control command is actually working
#
do_test tkt-80ba2-150 {
  optimization_control db factor-constants 1
  db cache flush
  set x1 [db eval {EXPLAIN 
    SELECT * FROM t1, t2
     WHERE (a='A' AND b='X')
        OR (a='A' AND EXISTS (SELECT * FROM t3 WHERE c='C'));}]
  optimization_control db factor-constants 0
  db cache flush
  set x2 [db eval {EXPLAIN 
    SELECT * FROM t1, t2
     WHERE (a='A' AND b='X')
        OR (a='A' AND EXISTS (SELECT * FROM t3 WHERE c='C'));}]

  expr {$x1==$x2}
} {0}

do_test tkt-80ba2-200 {
  db eval {
    CREATE TABLE entry_types (
                        id     integer primary key,
                        name   text
                    );
    INSERT INTO "entry_types" VALUES(100,'cli_command');
    INSERT INTO "entry_types" VALUES(300,'object_change');
    CREATE TABLE object_changes (
                        change_id    integer primary key,
                        system_id    int,
                        obj_id       int,
                        obj_context  text,
                        change_type  int,
                       command_id   int
                    );
    INSERT INTO "object_changes" VALUES(1551,1,114608,'exported_pools',1,2114);
    INSERT INTO "object_changes" VALUES(2048,