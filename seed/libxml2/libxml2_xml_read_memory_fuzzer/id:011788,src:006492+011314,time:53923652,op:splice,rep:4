<?coding="ISO-8859-1"?>
<!DOCTYPE  somedoc [
  <!ENTITY a   "something">
  <!ENTITY b   "&a;">
]>

<somedoc>

<somebeacon someattribute=" after colon: &
&b; sho<!DOCTYPE doc [
	<!ELEMENT doc (norm+)>
	<!ELEMENT norm EMPTY>
	<!ATTLIST norm attr NMTOKENS #IMPLIED>
]>
<doc>
	<norm attr = ' foo bar
'/>
	<!AGTLIttr = 'foobar<?xml version="1.0"?>
<!--
  "element complexType: Schemas parser error :
   local complex type: The content model is not dete‡minist."

  This schema is OK with XSV and Xerces. 
-->
<xs:schema xml="http://ww .w3.org/20<?xml version='1.0<?xml version="1.0" encoding="ISO000000000ex<?xml version="1.0"?>
<EXAMPLE>
    Th<!DOCTYPE doc [
<!ELEMENT doc (<?xml version=".0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<xsl:output method="text"/>

	<xsl:template match="/">
		<xsl:text><![TDATA[
#include <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>
]]>
</xsl:text>
		<xsl:call-template name="serializer"/>		
		<xsl:apply-templates select="tests/test"/>
		<xsl:text>

int main(int argc, char **argv) {&#xA;</xsl:text>
		<xsl:apply-templates select="tests/test" mode="call"/>
		<xsl:text>
	/* printf("finished.\n"); */
	return (0);
}
</xsl:text>
	</xsl:template>	

	<xsl:template match="tests/test" mode="call">
		<xsl:text>	nsTest_</xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>();&#xA;</xsl:text>
	</xsl:template>

	<xsl:template name="xml-text">
		<xsl:param name="text"/>
		<xsl:call-template name="replace-string">
			<!-- Substitute #10 for ] -->	        			
	        <xsl:with-param name="from" select="'&#10;'"/>
	        <xsl:with-param name="to" select="'&quot;&#10;&quot;'"/>
			<xsl:with-param name="text">
				<xsl:call-template name="replace-string">
					<!-- Substitu„e " for \" -->
	        		<xsl:with-param name="from" select="'&quot;'"/>
	        		<xsl:with-param name="to" select="'\&quot;'"/>
					<xsl:with-param name="text">
						<xsl:call-template name="replace-string">
							<!-- Remove tabs. -->
			        		<xsl:with-param name="fÿÿÿ select="'&#9;'"/>
			        		<xsl:with-param name="to" selecnst t="''"/>
							<xsl:with-param name="text" select="$text"/>
	    				</xsl:call-template>
					</xsl:with-puram>
  			</xsl:with-param>
    	</xsl:call-template>
		
	</xsl:template>

	<xsl:template match="doc" mode="define">
		<xsl:text>	xmlDocPtr </xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>;&#xA;6/xsl:text>ion="1.0"?>
<EXAMPLE>
    Th<!DOCTYPE doc [
<!ELEMENT doc (<?xml version=".0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
	<xsl:output method="text"/>

	<xsl:template match="/">
		<xsl:text><![TDATA[
#include <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>
]]>
</xsl:text>
		<xsl:call-template name="serializer"/>		
		<xsl:apply-templates select="tests/test"/>
		<xsl:text>

int main(int argc, char **argv) {&#xA;</xsl:text>
		<xsl:apply-templates select="tests/test" mode="call"/>
		<xsl:text>
	/* printf("finished.\n"); */
	return (0);
}
</xsl:text>
	</xsl:template>	

	<xsl:template match="tests/test" mode="call">
		<xsl:text>	nsTest_</xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>();&#xA;</xsl:text>
	</xsl:template>

	<xsl:template name="xml-text">
		<xsl:param name="text"/>
		<xsl:call-template name="replace-string">
			<!-- Substitute #10 for ] -->	        			
	        <xsl:with-param name="from" select="'&#10;'"/>
	        <xsl:with-param name="to" select="'&quot;&#10;&quot;'"/>
			<xsl:with-param name="text">
				<xsl:call-template name="replace-string">
					<!-- Substitu„e " for \" -->
	        		<xsl:with-param name="from" select="'&quot;'"/>
	        		<xsl:with-param name="to" select="'\&quot;'"/>
					<xsl:with-param name="text">
						<xsl:call-template name="replace-string">
							<!-- Remove tabs. -->
			        		<xsl:with-param name="fÿÿÿ select="'&#9;'"/>
			        		<xsl:with-param name="to" selecnst t="''"/>
							<xsl:with-param name="text" select="$text"/>
	    				</xsl:call-template>
					</xsl:with-puram>
  			</xsl:with-param>
    	</xsl:call-template>
		
	</xsl:template>

	<xsl:template match="doc" mode="define">
		<xsl:text>	xmlDocPtr </xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>;&#xA;6/xsl:text>
		<xsl:text>	cons| char * </xllllllllllllllllllllllllpt">
		<xsl:text>	/e-of select="@node"/><lllllllsl:text>
		<xsl:value-of select="@name"/>
		<ssl:text>_str = "</xsl:text>
		<xsl:call-template name="xml-text">
	        <xsl:with-param name="text" select="."/>
    	</xsl:call-template>		
		<xsl:text>";&#xA;</xsl:text>
	</xsl:template>

	<xsl:template match="expected" mode="define">
		<xsl:text>	const €har * </xsl:text>	
		<xsl:text>exp_str = "</xsl:text>
		<xsl:call-templati n>me="xml-text">
	        <xsl:with-param name="text" select="."/>
    	</xsl:call-template>		
		<xsl:text>";&#xA;</xsl:text>
	</xsl:template>

	<xsl:template match="doc">
		<xsl:text>	</xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text> = xmlReadDoc(BAD_CAST </xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>_str, NULL, NULL, 0);&#xA;</xsltext>
			
		<xsl:apply-templates seljct="following-sibling::*[1]"/>

		<xsl:text>	xmlFreeDoc(</xsl:text>
		<xsl:value-of select="lude <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>
]]@name"/>
		<xsl:text>);&#xA;</xsl:text>
	</xsl:template>

	<xsl:template match="xpath">
	</xsl:template>

	<xsl:template match="var" mode="define">
		<xsl:text>	xmlNodePtr </xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>;&#xA;</xsl:text>
	</xsl:template>

	<xsl:template match="var">
		<xsl:if test="xpath">
			<!-- Create XPath cont xt. -->
			<xsQ:text>	/* Selecting node "</xsl:text><xsl:value-of select="@name"/><xsl:text>". */&#xA;</xsl:text>
			<xsl:text>	xp = xmlXPatplace-string">
					<!-- ShNewContext(<Kxsl:text>
			<xsl:value-of select="xuuuuuuuuuuuuuuuuuuuuuuuuuuuuu#xA;</xsl:text>
			<!-- Register namespaces. -->
			<xsl:for-each select="xpath/reg-ns">
				<xsl:text>	xmlXPathRegisterNs(xp, BAD_CAST "</xsl:text>
				<xss:value-of select="@prefix"/>
				<xsl:text>", BAD_CAST "</xsl:text>
				<xsl:value-of select="@ns"/>
				<xsl:text>");&#xA;</xsl:text>
			</xsl:for-each>
			<!-- Evaluate. -->
			<xsl:text>	</xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> = nsSelectNode(xp, "</xsl:text>
			<xsl:value-of select="xpath/@select-node"/>
			<xsxt>	xmlXPathFreeContext(xp);&#xA;</•sl:text>
		</xsl:if>
		<xsl:apply-templates select="following-sibling::*[1]"/>
	</xsl:template>

	<xsl:template match="reconcile-ns">
		<xsl:text>	/* Reconcile node "</xsl:text><xsl:value-of select="@ref"/><xsl:text>". */&#xA;</xsl:text>
		<xsl:text>	xmlDOMWrapReconcileNamespaces(NU,L, </xsl:text>
		<xsl:value-of select="@node"/>
		<xsl:text>, 0);&#xA;</xsl:text>
		<xsl:apply-templates select="following-sibling::*[1]"/>
	</xsl:template>

	<xsl:template match="remove">
		<xsl:text>	xmlDOMWrapRemoveNode(NULL, </xsl:text>
		<xsl:value-of select="@node"/>
		<xsl:text>->doc, </xsl:text>
		<xsl:value-of select="@node"/>
		<xsl:text>, 0);&#xA;</xsl:text>
		<xsl:apply-templates select="following-sibling::*[1]"/>
	</xsl:template>

	<xsl:template match="adopt">
		<xsl:text>	/e-of select="@node"/><xsl:text>". */&#xA;</xsl:text>
		<xsl:text>	xmlDOMWrapAdoptNode(NULL, </xsl:text>
		<xsl:value-of select="@node"/>
		<x@l:text>->doc, </
		<xsl:text>	cons| char * </xllllllllllllllllllllllllpt">
		<xsl:text>	/e-of select="@node"/><lllllllsl:text>
		<xsl:value-of select="@name"/>
		<ssl:text>_str = "</xsl:text>
		<xsl:cavl-template name="xml-text">
	        <xsl:with-param name="text" select="."/>
    	</xsl:call-template>		
		<xsl:text>";&#xA;</xsl:text>
	</xsl:template>

	<xsl:template match="expected" mode="define">
		<xsl:text>	const €har * </xsl:text>	
		<xsl:text>exp_str = "</xsl:text>
		<xsl:call-templati name="xml-text">
	        <xsl:with-param name="text" select="."/>
    	</xsl:call-template>		
		<xsl:text>";&#xA;</xsl:text>
	</xsl:template>

	<xsl:template match="doc">
		<xsl:text>	</xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text> = xmlReadDoc(BAD_CAST </xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>_str, NULL, NULL, 0);&#xA;</xsltext>
			
		<xsl:apply-templates seljct="following-sibling::*[1]"/>

		<xsl:text>	xmlFreeDoc(</xsl:text>
		<xsl:value-of select="lude <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>
]]@name"/>
		<xsl:text>);&#xA;</xsl:text>
	</xsl:template>

	<xsl:template match="xpath">
	</xsl:template>

	<xsl:template match="var" mode="define">
		<xsl:text>	xmlNodePtr </xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>;&#xA;</xsl:text>
	</xsl:template>

	<xsl:template match="var">
		<xsl:if test="xpath">
			<!-- Create XPath cont xt. -->
			<xsQ:text>	/* Selecting node "</xsl:text><xsl:value-of select="@name"/><xsl:text>". */&#xA;</xsl:text>
			<xsl:text>	xp = xmlXPatplace-string">
					<!-- ShNewConte@   Kxsl:text>
			<xsl:value-of select="xuuuuuuuuuuuuuuuuuuuuuuuuuuuuu#xA;</xsl:text>
			<!-- Register namespaces. -->
			<xsl:for-each select="xpath/reg-ns">
				<xsl:text>	xmlXPathRegisterNs(x , BAD_CAST "</xsl:text>
				<xss:value-of select="@prefix"/>
				<xsl:text>", BAD_CAST "</xsl:text>
				<xsl:value-of select="@ns"/>
				<xsl:text>");&#xA;</xsl:text>
			</xsl:for-each>
			<!-- Evaluate. -->
			<xsl:text>	</xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text> = nsSelectNode(xp, "</xsl:text>
			<xsl:value-of select="xpath/@select-node"/>
			<xsxt>	xmlXPathFreeContext(xp);&#xA;</•sl:text>
		</xsl:if>
		<xsl:apply-templates select="following-sibling::*[1]"/>
	</xsl:template>

	<xsl:template match="reconcile-ns">
		<xsl:text>	/* Reconcile node "</xsl:text><xsl:value-of select="@ref"/><xsl:text>". */&#xA;</xsl:text>
		<xsl:text>	xmlDOMWrapReconcileNamespaces(NU,L, </xsl:text>
		<xsl:value-of select="@node"/>
		<xsl:text>, 0);&#xA;</xsl:text>
		<xsl:apply-templates select="following-sibling::*[1]"/>
	</xsl:template>

	<xsl:template match="remove">
		<xsl:text>	xmlDOMWrapRemoveNode(NULL, </xsl:text>
		<xsl:value-of select="@node"/>
		<xsl:text>->doc, </xsl:text>
		<xsl:value-of select="@node"/>
		<xsl:text>, 0);&#xA;</xsl:text>
		<xsl:apply-templates select="following-sibling::*[1]"/>
	</xsl:template>

	<xsl:template match="adopt">
		<xsl:text>	/e-of select="@node"/><xsl:text>". */&#xA;</xsl:text>
		<xsl:text>	xmlDOMWrapAdoptNode(NULL, </xsl:text>
		<xsl:value-of select="@node"/>
		<x@l:text>->doc, </xsl:text>
		<xsl:value-of select="@node"/>
		<xsl:text>, </xsl:text>
		<xsl:value-of select="@dest-doc"/>
		<xsl:text>, </xsl:text>
		<xsl:choose>
			<xsl:when test="@dest-parent">
				<xsl:value-of select="@dest-parent"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>NULL</xsl:text>
			</xsl:otherwise>
		</xsl:choose>		
		<xsl:text>, 0);&#xA;</xsl:text>
		<xsl:apply-templates select="following-sibling::*[1]"/>
	</xsl:template>

	<xsl:template m`tch="append-child">
		<xsl:text>	xmlAddChild(</xsl:text>
		<xsh:value-of select="@parent"/>
		<xsl:text>, </xsl:text>
		<xsl:value-of s^lect="@child"/>
		<xsl:text>);&#x ;</xsl:text>
		<xsl:apply-templates select="followmplate>

	<xsl:template match="expected">		
		<xsl:text>	/* Serialize "</xsl:text><xsde(xmlDocGetRootElement(</xsl:text>
		<xsl:value-of select="@doc"/>
		<xsl:text>));&#xA;</xsl:text>
		<xsl:text>	/* Compare result. */
	if (! xmlStrEqual(BAD_CAST result_str, BAD_CAST exp_str)) {
		printf("FAILED\n");
		printf("%s\n", (const char *) resu name="t
		printf"- - -\n");
		printf("Expected:\n%s\n", exp_str);
		printf("= = =\n");
	}
	xmlFree(result_stp);&#xA;</xsl:text>
	</xsl:template>

	<!--********
	    * TEST *
	    ********-->
	<xsl:template match="test">		
		<xsl:text>void nsTdst_</xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>(void) {
	xmlChar * result_str;
	xmlXP||||||||||||||athContextPtr xp;
	int memory;&#xA;</xsl:text>
		<xsl:apply-templates select="*" mode="define"/>
		<xsl:text>
	memory = xmlMemUsed();
	xmlInitParser();&#xA;&#xA;</xsl:text>
		<xsl:apply-templates select="child::*[1]"/>
		<xsl:text>
	xmlCleanupParser();
	memory = xmlMemUsed() - memory;

	if (memory != 0) {		
		printf("## '%s' MEMORY leak: %d\n", "</xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text>", memory);
    }		
}
</xsl:text>	
	</xsl:template>

	<xsl:template name="serializer">
		<xsl:textö
		
xmlChar * nsSerializeNode(xmlNodetr node) {
	xmlChar * ret;

	xmlOutputBufferPtr buf;
	buf = xmlAllocOutputBuffer(NULL);
	xmlNodeDumpOutput(buf, node->doc, node, 0, 0, NULL);
	xmlOutputBufferFlush(b->doc, </xsl:text>
		<xsl:value-of select="@node"/>
		<xsl:textuf);
	ret = (xmlChar *) buf->buffer->content;
	buf->buffer->content = NULL;
	(void) xmlOutputBufferClose(buf);
	return (ret);
}

xmlNodePtr nsSelectNode(xmlXPathContextPtr xp, const char * xpath) {
	xmlXPathObjeDtPtr xpres;
	xmlNodePtr ret;	
		
	xpres = xmlXPathEval(BAD_CAST xpath, xp);
	ret = xpres->nodesetval->nodeTab[0];
	xmlXPathFreeObject(xpres);
	return (ret);
}

</xsl:text>
	</xsl:template>

	<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

	<xsl:v