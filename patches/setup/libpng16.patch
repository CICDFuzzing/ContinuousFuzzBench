diff --git a/codebase/libpng16/Makefile.am b/codebase/libpng16/Makefile.am
index f21107e..4fd05f4 100644
--- a/codebase/libpng16/Makefile.am
+++ b/codebase/libpng16/Makefile.am
@@ -18,7 +18,7 @@ check_PROGRAMS += timepng
 endif
 
 # Utilities - installed
-bin_PROGRAMS= pngfix png-fix-itxt
+bin_PROGRAMS= readpng pngfix png-fix-itxt
 
 # This ensures that pnglibconf.h gets built at the start of 'make all' or
 # 'make check', but it does not add dependencies to the individual programs,
@@ -30,6 +30,10 @@ bin_PROGRAMS= pngfix png-fix-itxt
 # always wrong and always very confusing.
 BUILT_SOURCES = pnglibconf.h
 
+readpng_SOURCES = readpng.c
+readpng_LDADD = libpng@PNGLIB_MAJOR@@PNGLIB_MINOR@.la
+readpng_LDFLAGS = -static
+
 pngtest_SOURCES = pngtest.c
 pngtest_LDADD = libpng@PNGLIB_MAJOR@@PNGLIB_MINOR@.la
 
@@ -238,6 +242,8 @@ $(srcdir)/scripts/pnglibconf.h.prebuilt:
 # here:
 pngtest.o: pnglibconf.h
 
+readpng.o: pnglibconf.h
+
 contrib/libtests/makepng.o: pnglibconf.h
 contrib/libtests/pngstest.o: pnglibconf.h
 contrib/libtests/pngunknown.o: pnglibconf.h
diff --git a/codebase/libpng16/configure b/codebase/libpng16/configure
index 574bfae..1b592d8 100755
--- a/codebase/libpng16/configure
+++ b/codebase/libpng16/configure
@@ -590,8 +590,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='libpng'
 PACKAGE_TARNAME='libpng'
-PACKAGE_VERSION='1.6.38.git'
-PACKAGE_STRING='libpng 1.6.38.git'
+PACKAGE_VERSION='1.6.38.magma'
+PACKAGE_STRING='libpng 1.6.38.magma'
 PACKAGE_BUGREPORT='png-mng-implement@lists.sourceforge.net'
 PACKAGE_URL=''
 
@@ -2825,7 +2837,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='libpng'
- VERSION='1.6.38.git'
+ VERSION='1.6.38.magma'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -2946,7 +2958,7 @@ fi
 
 
 
-PNGLIB_VERSION=1.6.38.git
+PNGLIB_VERSION=1.6.38.magma
 PNGLIB_MAJOR=1
 PNGLIB_MINOR=6
 PNGLIB_RELEASE=38
diff --git a/codebase/libpng16/configure.ac b/codebase/libpng16/configure.ac
index 17a6a2f..0d2a82e 100644
--- a/codebase/libpng16/configure.ac
+++ b/codebase/libpng16/configure.ac
@@ -25,7 +25,7 @@ AC_PREREQ([2.68])
 
 dnl Version number stuff here:
 
-AC_INIT([libpng],[1.6.38.git],[png-mng-implement@lists.sourceforge.net])
+AC_INIT([libpng],[1.6.38.magma],[png-mng-implement@lists.sourceforge.net])
 AC_CONFIG_MACRO_DIR([scripts])
 
 # libpng does not follow GNU file name conventions (hence 'foreign')
@@ -46,7 +46,7 @@ dnl automake, so the following is not necessary (and is not defined anyway):
 dnl AM_PREREQ([1.11.2])
 dnl stop configure from automagically running automake
 
-PNGLIB_VERSION=1.6.38.git
+PNGLIB_VERSION=1.6.38.magma
 PNGLIB_MAJOR=1
 PNGLIB_MINOR=6
 PNGLIB_RELEASE=38
diff --git a/codebase/libpng16/readpng.c b/codebase/libpng16/readpng.c
new file mode 100644
index 0000000..26a6979
--- /dev/null
+++ b/codebase/libpng16/readpng.c
@@ -0,0 +1,371 @@
+/*---------------------------------------------------------------------------
+
+   rpng - simple PNG display program                              readpng.c
+
+  ---------------------------------------------------------------------------
+
+      Copyright (c) 1998-2007,2017 Greg Roelofs.  All rights reserved.
+
+      This software is provided "as is," without warranty of any kind,
+      express or implied.  In no event shall the author or contributors
+      be held liable for any damages arising in any way from the use of
+      this software.
+
+      The contents of this file are DUAL-LICENSED.  You may modify and/or
+      redistribute this software according to the terms of one of the
+      following two licenses (at your option):
+
+
+      LICENSE 1 ("BSD-like with advertising clause"):
+
+      Permission is granted to anyone to use this software for any purpose,
+      including commercial applications, and to alter it and redistribute
+      it freely, subject to the following restrictions:
+
+      1. Redistributions of source code must retain the above copyright
+         notice, disclaimer, and this list of conditions.
+      2. Redistributions in binary form must reproduce the above copyright
+         notice, disclaimer, and this list of conditions in the documenta-
+         tion and/or other materials provided with the distribution.
+      3. All advertising materials mentioning features or use of this
+         software must display the following acknowledgment:
+
+            This product includes software developed by Greg Roelofs
+            and contributors for the book, "PNG: The Definitive Guide,"
+            published by O'Reilly and Associates.
+
+
+      LICENSE 2 (GNU GPL v2 or later):
+
+      This program is free software; you can redistribute it and/or modify
+      it under the terms of the GNU General Public License as published by
+      the Free Software Foundation; either version 2 of the License, or
+      (at your option) any later version.
+
+      This program is distributed in the hope that it will be useful,
+      but WITHOUT ANY WARRANTY; without even the implied warranty of
+      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+      GNU General Public License for more details.
+
+      You should have received a copy of the GNU General Public License
+      along with this program; if not, write to the Free Software Foundation,
+      Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+  ---------------------------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <zlib.h>
+
+#include "png.h"        /* libpng header */
+#include "contrib/gregbook/readpng.h"    /* typedefs, common macros, public prototypes */
+
+/* future versions of libpng will provide this macro: */
+#ifndef png_jmpbuf
+#  define png_jmpbuf(png_ptr)   ((png_ptr)->jmpbuf)
+#endif
+
+
+static png_structp png_ptr = NULL;
+static png_infop info_ptr = NULL;
+
+png_uint_32  width, height;
+int  bit_depth, color_type;
+uch  *image_data = NULL;
+
+
+void readpng_version_info(void)
+{
+    fprintf(stderr, "   Compiled with libpng %s; using libpng %s.\n",
+      PNG_LIBPNG_VER_STRING, png_libpng_ver);
+    fprintf(stderr, "   Compiled with zlib %s; using zlib %s.\n",
+      ZLIB_VERSION, zlib_version);
+}
+
+
+/* return value = 0 for success, 1 for bad sig, 2 for bad IHDR, 4 for no mem */
+
+int readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight)
+{
+    uch sig[8];
+
+
+    /* first do a quick check that the file really is a PNG image; could
+     * have used slightly more general png_sig_cmp() function instead */
+
+    fread(sig, 1, 8, infile);
+    if (png_sig_cmp(sig, 0, 8))
+        return 1;   /* bad signature */
+
+
+    /* could pass pointers to user-defined error handlers instead of NULLs: */
+
+    png_ptr = png_create_read_struct(png_get_libpng_ver(NULL), NULL, NULL,
+        NULL);
+    if (!png_ptr)
+        return 4;   /* out of memory */
+
+    info_ptr = png_create_info_struct(png_ptr);
+    if (!info_ptr) {
+        png_destroy_read_struct(&png_ptr, NULL, NULL);
+        return 4;   /* out of memory */
+    }
+
+
+    /* we could create a second info struct here (end_info), but it's only
+     * useful if we want to keep pre- and post-IDAT chunk info separated
+     * (mainly for PNG-aware image editors and converters) */
+
+
+    /* setjmp() must be called in every function that calls a PNG-reading
+     * libpng function */
+
+    if (setjmp(png_jmpbuf(png_ptr))) {
+        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+        return 2;
+    }
+
+
+    png_init_io(png_ptr, infile);
+    png_set_sig_bytes(png_ptr, 8);  /* we already read the 8 signature bytes */
+
+    png_read_info(png_ptr, info_ptr);  /* read all PNG info up to image data */
+
+
+    /* alternatively, could make separate calls to png_get_image_width(),
+     * etc., but want bit_depth and color_type for later [don't care about
+     * compression_type and filter_type => NULLs] */
+
+    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
+      NULL, NULL, NULL);
+    *pWidth = width;
+    *pHeight = height;
+
+
+    /* OK, that's all we need for now; return happy */
+
+    return 0;
+}
+
+
+
+
+/* returns 0 if succeeds, 1 if fails due to no bKGD chunk, 2 if libpng error;
+ * scales values to 8-bit if necessary */
+
+int readpng_get_bgcolor(uch *red, uch *green, uch *blue)
+{
+    png_color_16p pBackground;
+
+
+    /* setjmp() must be called in every function that calls a PNG-reading
+     * libpng function */
+
+    if (setjmp(png_jmpbuf(png_ptr))) {
+        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+        return 2;
+    }
+
+
+    if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))
+        return 1;
+
+    /* it is not obvious from the libpng documentation, but this function
+     * takes a pointer to a pointer, and it always returns valid red, green
+     * and blue values, regardless of color_type: */
+
+    png_get_bKGD(png_ptr, info_ptr, &pBackground);
+
+
+    /* however, it always returns the raw bKGD data, regardless of any
+     * bit-depth transformations, so check depth and adjust if necessary */
+
+    if (bit_depth == 16) {
+        *red   = pBackground->red   >> 8;
+        *green = pBackground->green >> 8;
+        *blue  = pBackground->blue  >> 8;
+    } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {
+        if (bit_depth == 1)
+            *red = *green = *blue = pBackground->gray? 255 : 0;
+        else if (bit_depth == 2)
+            *red = *green = *blue = (255/3) * pBackground->gray;
+        else /* bit_depth == 4 */
+            *red = *green = *blue = (255/15) * pBackground->gray;
+    } else {
+        *red   = (uch)pBackground->red;
+        *green = (uch)pBackground->green;
+        *blue  = (uch)pBackground->blue;
+    }
+
+    return 0;
+}
+
+
+
+
+/* display_exponent == LUT_exponent * CRT_exponent */
+
+uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)
+{
+    double  gamma;
+    png_uint_32  i, rowbytes;
+    png_bytepp  row_pointers = NULL;
+
+
+    /* setjmp() must be called in every function that calls a PNG-reading
+     * libpng function */
+
+    if (setjmp(png_jmpbuf(png_ptr))) {
+        free(image_data);
+        image_data = NULL;
+        free(row_pointers);
+        row_pointers = NULL;
+        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+        return NULL;
+    }
+
+
+    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,
+     * transparency chunks to full alpha channel; strip 16-bit-per-sample
+     * images to 8 bits per sample; and convert grayscale to RGB[A] */
+
+    if (color_type == PNG_COLOR_TYPE_PALETTE)
+        png_set_expand(png_ptr);
+    if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
+        png_set_expand(png_ptr);
+    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
+        png_set_expand(png_ptr);
+#ifdef PNG_READ_16_TO_8_SUPPORTED
+    if (bit_depth == 16)
+#  ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+        png_set_scale_16(png_ptr);
+#  else
+        png_set_strip_16(png_ptr);
+#  endif
+#endif
+    if (color_type == PNG_COLOR_TYPE_GRAY ||
+        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+        png_set_gray_to_rgb(png_ptr);
+
+
+    /* unlike the example in the libpng documentation, we have *no* idea where
+     * this file may have come from--so if it doesn't have a file gamma, don't
+     * do any correction ("do no harm") */
+
+    if (png_get_gAMA(png_ptr, info_ptr, &gamma))
+        png_set_gamma(png_ptr, display_exponent, gamma);
+
+
+    /* all transformations have been registered; now update info_ptr data,
+     * get rowbytes and channels, and allocate image memory */
+
+    png_read_update_info(png_ptr, info_ptr);
+
+    *pRowbytes = rowbytes = png_get_rowbytes(png_ptr, info_ptr);
+    *pChannels = (int)png_get_channels(png_ptr, info_ptr);
+
+    /* Guard against integer overflow */
+    if (height > ((size_t)(-1))/rowbytes) {
+        fprintf(stderr, "readpng:  image_data buffer would be too large\n");
+        return NULL;
+    }
+
+    if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) {
+        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+        return NULL;
+    }
+    if ((row_pointers = (png_bytepp)malloc(height*sizeof(png_bytep))) == NULL) {
+        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+        free(image_data);
+        image_data = NULL;
+        return NULL;
+    }
+
+    Trace((stderr, "readpng_get_image:  channels = %d, rowbytes = %ld, height = %ld\n",
+        *pChannels, rowbytes, height));
+
+
+    /* set the individual row_pointers to point at the correct offsets */
+
+    for (i = 0;  i < height;  ++i)
+        row_pointers[i] = image_data + i*rowbytes;
+
+
+    /* now we can go ahead and just read the whole image */
+
+    png_read_image(png_ptr, row_pointers);
+
+
+    /* and we're done!  (png_read_end() can be omitted if no processing of
+     * post-IDAT text/time/etc. is desired) */
+
+    free(row_pointers);
+    row_pointers = NULL;
+
+    png_read_end(png_ptr, NULL);
+
+    return image_data;
+}
+
+
+void readpng_cleanup(int free_image_data)
+{
+    if (free_image_data && image_data) {
+        free(image_data);
+        image_data = NULL;
+    }
+
+    if (png_ptr && info_ptr) {
+        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+        png_ptr = NULL;
+        info_ptr = NULL;
+    }
+}
+
+int main(int argc, char **argv)
+{
+#ifdef MAGMA_ENABLE_CANARIES
+  magma_init();
+#endif
+
+  if (argc != 2) {
+    fprintf(stderr, "readpng 1.0: Simple PNG file reader\n");
+    readpng_version_info();
+    fprintf(stderr, "\nUsage: readpng file.png\n");
+    exit(1);
+  }
+
+  FILE *infile;
+  char *filename = argv[1];
+
+  if ((infile = fopen(filename, "rb")) == NULL) {
+    fprintf(stderr, "readpng: can't open PNG file [%s]\n", filename);
+    exit(2);
+  }
+
+  ulg image_width, image_height;
+  int rc;
+
+  if ((rc = readpng_init(infile, &image_width, &image_height)) != 0) {
+    fclose(infile);
+    fprintf(stderr, "readpng: readpng_init() error\n");
+    exit(3);
+  }
+
+  uch bg_red, bg_green, bg_blue;
+  if (readpng_get_bgcolor(&bg_red, &bg_green, &bg_blue) > 1) {
+    readpng_cleanup(TRUE);
+    fclose(infile);
+    fprintf(stderr, "readpng: readpng_get_bgcolor() error\n");
+    exit(4);
+  }
+
+  uch *image_data;
+  int image_channels;
+  ulg image_rowbytes;
+  image_data = readpng_get_image(1.0, &image_channels, &image_rowbytes);
+
+  readpng_cleanup(TRUE);
+  fclose(infile);
+  return 0;
+}
\ No newline at end of file
diff --git a/codebase/libpng16/scripts/pnglibconf.dfa b/codebase/libpng16/scripts/pnglibconf.dfa
index 4dcaf7c..ea8476c 100644
--- a/codebase/libpng16/scripts/pnglibconf.dfa
+++ b/codebase/libpng16/scripts/pnglibconf.dfa
@@ -408,8 +408,8 @@ option USER_LIMITS requires READ
 # Only chunks that are variable in number are counted towards the
 
 # Use 0x7fffffff for unlimited
-setting USER_WIDTH_MAX default        1000000
-setting USER_HEIGHT_MAX default       1000000
+setting USER_WIDTH_MAX default        0x7fffffff
+setting USER_HEIGHT_MAX default       0x7fffffff
 
 # Use 0 for unlimited
 setting USER_CHUNK_CACHE_MAX default     1000
