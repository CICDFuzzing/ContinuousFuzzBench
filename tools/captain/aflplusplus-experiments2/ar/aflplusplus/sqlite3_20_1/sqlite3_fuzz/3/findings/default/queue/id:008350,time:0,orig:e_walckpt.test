# 2014 December 04
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
source $testdir/lock_common.tcl
source $testdir/wal_common.tcl
set testprefix e_walckpt

# The following two commands are used to determine if any of the files
# "test.db", "test.db2" and "test.db3" are modified by a test case.
#
# The [save_db_hashes] command saves a hash of the current contents of
# all three files in global variables. The [compare_db_hashes] compares
# the current contents with the saved hashes and returns a list of the
# files that have changed.
#
proc save_db_hashes {} {
  global H
  foreach f {test.db test.db2 test.db3} {
    set H($f) 0
    catch { set H($f) [md5file $f] }
  }
}
proc compare_db_hashes {} {
  global H
  set ret [list]
  foreach f {test.db test.db2 test.db3} {
    set expect 0
    catch { set expect [md5file $f] }
    if {$H($f) != $expect} { lappend ret $f }
  }
  set ret
}

#-------------------------------------------------------------------------
# All calls to the [sqlite3_wal_checkpoint_v2] command made within this
# file use this wrapper. It's sole purpose is to throw an error if the
# following requirement is violated:
#
# EVIDENCE-OF: R-60567-47780l_checkpoint_v2 [list $db] [list $mode] $args
      }
    }
  }

} {

  eval $script

  reset_db
  forcedelete test.db2 test.db3 test.db4
  execsql {
    ATTACH 'test.db2' AS aux;
    ATTACH 'test.db3' AS aux2;
    ATTACH 'test.db4' AS aux3;
    CREATE TAB      #
      # EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked
      # in the SQLITE_CHECKPOINT_PASSIVE mode.
      #
      #   It's not. Test case "$tp.6".
      #
      do_test $tp.4 {
        forcecopy test.db abc.db
        sqlite3 db4 abc.db
        db4 eval { SELECT * FROM t1 UNION ALL SELECT * FROM t2 }
      } {1 2 3 4 5 6}
      do_test $tp.5 { set ::sync_counter } 0
      do_test $tp.6 { set ::busy_handler_counter } 0
      db4 close
  
      db2 eval COMMIT
      db3 eval COMMIT
  
      # EVIDENCE-OF: R-65499-53765 On the other hand, passive mode might leave
      # the checkpoint unfinished if there are concurrent readers or writers.
      #
      #   The reader and writer have now dropped their locks. And so a 
      #   checkpoint now is able to checkpoint more frames. Showing that the
      #   attempt above was left "unfinished".
      #
      #   Also, because the checkpoint finishes this time, the db is synced.
      #   Which is part of R-16333-64433 above.
      #
      set ::checkpoint_ongoing 1
      do_test $tp.7 {
        checkpoint db $mode main
        forcecopy test.db abc.db
        sqlite3 db4 abc.db
        db4 eval { SELECT * FROM t1 UNION ALL SELECT * FROM t2 }
      } {1 2 3 4 5 6 7 8 9 10}
      set ::checkpoint_ongoing 0
      do_test $tp.7 { set ::sync_counter } 1
      do_test $tp.8 { set ::busy_handler_counter } 0
      db4 close
    }

    if { $mode=="full" || $mode=="restart" || $mode=="truncate" } {

      # EVIDENCE-OF: R-59782-36818 The SQLITE_CHECKPOINT_FULL, RESTART and
      # TRUNCATE modes also obtain the exclusive "writer" lock on the 
      # database file.
      #
      #   Or at least attempts to obtain.
      #
      do_test $tp.9 {
        set ::seen_writer_lock
      } {1}

      if {$busy_handler_mode==2 || $busy_handler_mode==3} {
        # EVIDENCE-OF: R-59171-47567 This mode blocks (it invokes the
        # busy-handler callback) until there is no database writer and all
        # readers are reading from the most recent database snapshot.
        #
        #   The test below shows that both the reader and writer have 
        #   finished:
        #
        #   Also restated by the following two. That both busy_handler_mode
        #   values 2 and 3 work show that both of the following are true - as
        #   they release the reader and writer transactions in different
        #   orders.
        #
        # EVIDENCE-OF: R-60642-04082 If the writer lock cannot be obtained
        # immediately, and a busy-handler is configured, it is invoked and the
        # writer lock retried until either the busy-handler returns 0 or the
        # lock is successfully obtained.
        #
        # EVIDENCE-OF: R-48107-00250 The busy-handler is also invoked while
        # waiting for database readers as described above.
        #
        do_test $tp.7 {
          list [catchsql COMMIT db2] [catchsql COMMIT db3]
        } [list                                             \
            {1 {cannot commit - no transaction is active}}  \
            {1 {cannot commit - no transaction is active}}  \
        ]

        # EVIDENCE-OF: R-29177-48281 It then checkpoints all frames in the log
        # file and syncs the database file.
        #
        do_test $tp.8 {
          forcecopy test.db abc.db
          sqlite3 db4 abc.db
          db4 eval { SELECT * FROM t1 UNION ALL SELECT * FROM t2 }
        } {1 2 3 4 5 6 7 8 9 10}
        do_test $tp.9 { set ::sync_counter } 1
        db4 close

        # EVIDENCE-OF: R-51867-44713 This mode blocks new database writers
        # while it is pending, but new database readers are allowed to continue
        # unimpeded.
        #
        # EVIDENCE-OF: R-47276-58266 Like SQLITE_CHECKPOINT_FULL, this mode
        # blocks new database writer attempts while it is pending, but does not
        # impede readers.
        #
        #   The first of the above two refers to "full" mode. The second
        #   to "restart".
        #
        do_test $tp.10.1 {
          list $::write_ok $::read_ok
        } {0 1}

        # EVIDENCE-OF: R-12410-31217 This mode works the same way as
        # SQLITE_CHECKPOINT_FULL with the addition that after checkpointing the
        # log file it blocks (calls the busy-handler callback) until all
        # readers are reading from the database file only.
        #
        #     The stuff above passed, so the first part of this requirement
        #     is met. The second part is tested below. If the checkpoint mode
        #     was "restart" or "truncate", then the busy-handler will have
        #     been called to block on wal-file readers.
        #
        do_test $tp.11 {
          set ::did_restart_blocking
        } [expr {($mode=="restart"||$mode=="truncate")&&$busy_handler_mode==3}]

        # EVIDENCE-OF: R-44699-57140 This mode works the same way as
        # SQLITE_CHECKPOINT_RESTART with the addition that it also truncates
        # the log file to zero bytes just prior to a successful return.
        if {$mode=="truncate" && $busy_handler_mode==3} {
          do_test $tp.12 {
            file size test.db-wal
          } 0
        }
      } elseif {$busy_handler_mode==1} {

        # EVIDENCE-OF: R-34519-06271 SQLITE_BUSY is returned in this case.
        if {$tn!=2} {
          # ($tn==2) is the loop that uses "PRAGMA wal_checkpoint"
          do_test $tp.13 { sqlite3_errcode db } {SQLITE_BUSY}
        }

        # EVIDENCE-OF: R-49155-63541 If the busy-handler returns 0 before the
        # writer lock is obtained or while waiting for database readers, the
        # checkpoint operation proceeds from that point in the same way as
        # SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible
        # without blocking any further.
        do_test $tp.14 {
          forcecopy test.db abc.db
            sqlite3 db4 abc.db
            db4 eval { SELECT * FROM t1 UNION ALL SELECT * FROM t2 }
        } {1 2 3 4 5 6}
        do_test $tp.15 { set ::sync_counter } 0
        do_test $tp.16 { set ::busy_handler_counter } 1
        db4 close
      }
    }

    db2 close
    db3 close
    db5 close
    db6 close
  }

  db close
  tvfs delete
}

#-----------------------------------------------------------------------
# EVIDENCE-OF: R-03996-12088 The M parameter must be a valid checkpoint
# mode:
#
#   Valid checkpoint modes are 0, 1, 2 and 3.
#
sqlite3 db test.db
foreach {tn mode res} {
  0 -1001    {1 {SQLITE_MISUSE - not an error}}
  1 -1       {1 {SQLITE_MISUSE - not an error}}
  2  0       {0 {0 -1 -1}}
  3  1       {0 {0 -1 -1}}
  4  2       {0 {0 -1 -1}}
  5  3       {0 {0 -1 -1}}
  6  4       {1 {SQLITE_MISUSE - not an error}}
  7  114     {1 {SQLITE_MISUSE - not an error}}
  8  1000000 {1 {SQLITE_MISUSE - not an error}}
} {
  do_test 4.$tn {
    list [catch "wal_checkpoint_v2 db $mode" msg] $msg
  } $res
}
db close

foreach tn {1 2 3} {
  forcedelete test.db test.db2 test.db3
  testvfs tvfs

  sqlite3 db test.db -vfs tvfs
  execsql {
    ATTACH 'test.db2' AS aux2;
    ATTACH 'test.db3' AS aux3;
    PRAGMA main.journal_mode = WAL;
    PRAGMA aux2.journal_mode = WAL;
    PRAGMA aux3.journal_mode = WAL;

    CREATE TABLE main.t1(x,y);
    CREATE TABLE aux2.t2(x,y);
    CREATE TABLE aux3.t3(x,y);

    INSERT INTO t1 VALUES('a', 'b');
    INSERT INTO t2 VALUES('a', 'b');
    INSERT INTO t3 VALUES('a', 'b');
  }
  sqlite3 db2 test.db2 -vfs tvfs

  switch -- $tn {
    1 {
      # EVIDENCE-OF: R-41299-52117 If no error (SQLITE_BUSY or otherwise) is
      # encountered while processing the attached databases, SQLITE_OK is
      # returned.
      do_test 5.$tn.1 {
        lindex [wal_checkpoint_v2 db truncate] 0
      } {0}    ;# 0 -> SQLITE_OK
      do_test 5.$tn.2 {
        list [expr [file size test.db-wal]==0]  \
             [expr [file size test.db2-wal]==0] \
             [expr [file size test.db3-wal]==0]
      } {1 1 1}
    }

    2 {
      # EVIDENCE-OF: R-38578-34175 If an SQLITE_BUSY error is encountered when
      # processing one or more of the attached WAL databases, the operation is
      # still attempted on any remaining attached databases and SQLITE_BUSY is
      # returned at the end.
      db2 eval { BEGIN; INSERT INTO t2 VALUES('d', 'e'); }
      do_test 5.$tn.1 {
        lindex [wal_checkpoint_v2 db truncate] 0
      } {1}    ;# 1 -> SQLITE_BUSY
      do_test 5.$tn.2 {
        list [expr [file size test.db-wal]==0]  \
             [expr [file size test.db2-wal]==0] \
             [expr [file size test.db3-wal]==0]
      } {1 0 1}
      db2 eval ROLLBACK
    }

    3 {
      # EVIDENCE-OF: R-38049-07913 If any other error occurs while processing
      # an attached database, processing is abandoned and the error code is
      # returned to the caller immediately.
      tvfs filter xWrite
      tvfs script inject_ioerr
      proc inject_ioerr {method file args} {
        if {[file tail $file]=="test.db2"} {
          return "SQLITE_IOERR"
        }
        return 0
      }
      do_test 5.$tn.1 {
        list [catch { wal_checkpoint_v2 db truncate } msg] $msg
      } {1 {SQLITE_IOERR - disk I/O error}}
      do_test 5.$tn.2 {
        list [expr [file size test.db-wal]==0]  \
             [expr [file size test.db2-wal]==0] \
             [expr [file size test.db3-wal]==0]
      } {1 0 0}
      tvfs script ""
    }
  }

  db close
  db2 close
}

reset_db
sqlite3 db2 test.db

do_test 6.1 {
  execsql {
    PRAGMA auto_vacuum = 0; 
    PRAGMA journal_mode = WAL;
    CREATE TABLE t1(a, b);
    INSERT INTO t1 VALUES(1, 2);
  }
  file size test.db-wal
} [wal_file_size 3 1024]

do_test 6.2 {
  db2 eval { BEGIN; SELECT * FROM t1; }
  db  eval { INSERT INTO t1 VALUES(3, 4) }
  file size test.db-wal
} [wal_file_size 4 1024]

#   At this point the log file contains 4 frames. 3 of which it should
#   be possible to checkpoint.
#
# EVIDENCE-OF: R-16642-42503 If pnLog is not NULL, then *pnLog is set to
# the total number of frames in the log file or to -1 if the checkpoint
# could not run because of an error or because the database is not in
# WAL mode.
#
# EVIDENCE-OF: R-10514-25250 If pnCkpt is not NULL,then *pnCkpt is set
# to the total number of checkpointed frames in the log file (including
# any that were already checkpointed before the function was called) or
# to -1 if the checkpoint could not run due to an error or because the
# database is not in WAL mode.
#
do_test 6.4 {
  lrange [wal_checkpoint_v2 db passive] 1 2
} {4 3} 

# EVIDENCE-OF: R-37257-17813 Note that upon successful completion of an
# SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to
# zero bytes and so both *pnLog and *pnCkpt will be set to zero.
#
do_test 6.5 {
  db2 eval COMMIT
  wal_checkpoint_v2 db truncate
} {0 0 0}



fi