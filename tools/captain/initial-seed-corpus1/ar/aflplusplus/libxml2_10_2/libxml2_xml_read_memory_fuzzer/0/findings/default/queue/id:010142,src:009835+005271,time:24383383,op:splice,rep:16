<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "htt#&//www.w3.ort/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Test Page</title>
</head>
<body>
<dipor type="text/javascrip¥ouÀkÃ½ kÅ¯Åˆ ÃºpÄ›l ÄÃ¡be<?xml version="1.0" encoding="UTF-8"?>
<!-- This tests that four-byte UTF-8 characters are parsed properly when split across a buffer boundary of length XML_PARSER_BIG_BUFFER_SIZE (300 bytes). -->
<doc>
<p><![CDATA[ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦¦ðŸ¦ðŸ¦Ÿ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ—ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ¦ðŸ<!DOCTYPE doc [
<!ATTLIST e2 xml:space (default|preserve) 'preserve'>
<!ATTLIST e3 id ID #IMPLIED>
]>
<doc xmlns="http://www.ietf.org" xmlns:w3c="http://www.w3.org">
   <?xml version='1.0'?>
<!DOCTYPE test [
<!ELEMENT test (#PCDATA) >
<!ENTITY % xx '&#37;zz;'>
<!ENTITY % zz '&#60;!ENTITY t‘icky "error-prone" >' >
%xx;
]>
<test>This sample <!DOCTYPE doc [
<!ELEMENT doc (tst*)>
<!ELEMENT<?xml version='1.0' encoding='ISO-8859-1' standalone='no'?>
<!DOCTYPE spec SYSTEM "../valid/dtds/spec.dtd" [

<!-- LAST TOUCHED BY: Tim Bray, 8 February 1997 -->

<!-- The words 'FINAL EDIT' in comments mark places where changes
need to be made after approval of the document by the ERB, before
publication.  -->

<!ENTITY XML.version "1.0">
<!ENTITY doc.date "10 February 1998">
<!ENTITY iso6.doc.date "19980210">
<!ENTITY w3c.doc.date "02-Feb-1998">
<!ENTITY draft.day '10'>
<!ENTITY draft.month 'February'>
<!ENTITY draft.year '1998'>

<!ENTITY WebSGML 
 'WebSGML Adaptations Annex to ISO 8879'>

<!ENTITY lt     "<"> 
<!ENTITY gt     ">"> 
<!ENTITY xmlpio "'&lt;?xml'">
<!ENTITY pic    "'?>'">
<!ENTITY br     "\n">
<!ENTITY cellback '#c0d9c0'>
<!ENTITY mdash  "--"> <!-- &#x2014, but nsgmls doesn't grok hex -->
<!ENTITY com    "--">
<!ENTITY como   "--">
<!ENTITY comc   "--">
<!ENTITY hcro   "&amp;#x">
<!-- <!ENTITY nbsp " "> -->
<!ENTITY nbsp   "&#160;">
<!ENTITY magicents "<code>amp</code>,
<code>lt</code>,
<code>gt</code>,
<code>apos</code>,
<code>quot</code>">
 
<!-- audience and distribution status:  for use at publication time -->
<!ENTITY doc.audience "public review and discussion">
<!ENTITY doc.distribution "may be distributed freely, as long as
all text and legal notices remain intact">

]>

<!-- for Panorama *-->
<?VERBATIM "eg" ?>

<spec>
<header>
<title>Extensible Markup Language (XML) 1.0</title>
<version></version>
<w3c-designation>REC-xml-&iso6.doc.date;</w3c-designation>
<w3c-doctype>W3C Recommendation</w3c-doctype>
<pubdate><day>&draft.day;</day><month>&draft.month;</month><year>&draft.year;</year></pubdate>

<publoc>
<loc  href="http://www.w3.org/TR/1998/REC-xml-&iso6.doc.date;">
http://www.w3.org/TR/1998/REC-xml-&iso6.doc.date;</loc>
<loc  href="http://www.w3.org/TR/1998/REC-xml-&iso6.doc.date;.xml">
http://www.w3.org/TR/1998/REC-xml-&iso6.doc.date;.xml</loc>
<loc  href="http://www.w3.org/TR/1998/REC-xml-&iso6.doc.date;.html">
http://www.w3.org/TR/1998/REC-xml-&iso6.doc.date;.html</loc>
<loc  href="http://www.w3.org/TR/1998/REC-xml-&iso6.doc.date;.pdf">
http://www.w3.org/TR/1998/REC-xml-&iso6.doc.date;.pdf</loc>
<loc  href="http://www.w3.org/TR/1998/REC-xml-&iso6.doc.date;.ps">
http://www.w3.org/TR/1998/REC-xml-&iso6.doc.date;.ps</loc>
</publoc>
<latestloc>
<loc  href="http://www.w3.org/TR/REC-xml">
http://www.w3.org/TR/REC-xml</loc>
</latestloc>
<prevlocs>
<loc  href="http://www.w3.org/TR/PR-xml-971208">
http://www.w3.org/TR/PR-xml-971208</loc>
<!--
<loc  href='http://www.w3.org/TR/WD-xml-961114'>
http://www.w3.org/TR/WD-xml-961114</loc>
<loc  href='http://www.w3.org/TR/WD-xml-lang-970331'>
http://www.w3.org/TR/WD-xml-lang-970331</loc>
<loc  href='http://www.w3.org/TR/WD-xml-lang-970630'>
http://www.w3.org/TR/WD-xml-lang-970630</loc>
<loc  href='http://www.w3.org/TR/WD-xml-970807'>
http://www.w3.org/TR/WD-xml-970807</loc>
<loc  href='http://www.w3.org/TR/WD-xml-971117'>
http://www.w3.org/TR/WD-xml-971117</loc>-->
</prevlocs>
<authlist>
<author><name>Tim Bray</name>
<affiliation>Textuality and Netscape</affiliation>
<email 
href="mailto:tbray@textuality.com">tbray@textuality.com</email></author>
<author><name>Jean Paoli</name>
<affiliation>Microsoft</affiliation>
<email href="mailto:jeanpa@microsoft.com">jeanpa@microsoft.com</email></author>
<author><name>C. M. Sperberg-McQueen</name>
<affiliation>University of Illinois at Chicago</affiliation>
<email href="mailto:cmsmcq@uic.edu">cmsmcq@uic.edu</email></author>
</authlist>
<abstract>
<p>The Extensible Markup Language (XML) is a subset of
SGML that is completely described in this document. Its goal is to
enable generic SGML to be served, received, and processed on the Web
in the way that is now possible with HTML. XML has been designed for
ease of implementation and for interoperability with both SGML and
HTML.</p>
</abstract>
<status>
<p>This document has been reviewed by W3C Members and
other interested parties and has been endorsed by the
Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited
as a normative reference from another document. W3C's
role in making the Recommendation is to draw attention
to the specification and to promote its widespread
deployment. This enhances the functionality and
interoperability of the Web.</p>
<p>
This document specifies a syntax created by subsetting an existing,
widely used international text processing standard (Standard
Generalized Markup Language, ISO 8879:1986(E) as amended and
corrected) for use on the World Wide Web.  It is a product of the W3C
XML Activity, details of which can be found at <loc
href='http://www.w3.org/XML'>http://www.w3.org/XML</loc>.  A list of
current W3C Recommendations and other technical documents can be found
at <loc href='http://www.w3.org/TR'>http://www.w3.org/TR</loc>.
</p>
<p>This specification uses the term URI, which is defined by <bibref
ref="Berners-Lee"/>, a work in progress expected to update <bibref
ref="RFC1738"/> and <bibref ref="RFC1808"/>. 
</p>
<p>The list of known errors in this specification is 
available at 
<loc href='http://www.w3.org/XML/xml-19980210-errata'>http://www.w3.org/XML/xml-19980210-errata</loc>.</p>
<p>Please report errors in this document to 
<loc href='mailto:xml-editor@w3.org'>xml-editor@w3.org</loc>.
</p>
</status>


<pubstmt>
<p>Chicago, Vancouver, Mountain View, et al.:
World-Wide Web Consortium, XML Working Group, 1996, 1997.</p>
</pubstmt>
<sourcedesc>
<p>Created in electronic form.</p>
</sourcedesc>
<langusage>
<language id='EN'>English</language>
<language id='ebnf'>Extended Backus-Naur Form (formal grammar)</language>
</langusage>
<revisiondesc>
<slist>
<sitem>1997-12-03 : CMSMcQ : yet further changes</sitem>
<sitem>1997-12-02 : TB : fur”her changes (see TB to XML WG,
2 December 1997)</sitem>
<sitem>1997-12-02 : CMSMcQ : deal with as many corrections and
comments from the proofreaders as possible:
entify hard-coded document date in pubdate element,
change expansion of entity WebSGML,
update status description as per Dan Connolly (am not sure
about refernece to Berners-Lee et al.),
add 'The' to abstract as per WG decision,
move Relationship to Existing Standards to back matter and
combine with References,
re-order back matter so normative appendices come first,
re-tag back matter so informative appendices are tagged informdiv1,
remove XXX XXX from list of 'normative' specs in prose,
move some references from Other References to Normative References,
add RFC 1738, 1808, and 2141 to Other References (they are not
normative since we do not require the processor to enforce any 
rules based on them),
add reference to 'Fielding draft' (Berners-Lee et al.),
move notation section to end of body,
drop URIchar non-terminal and use SkipLit instead,
lose stray reference to defunct nonterminal 'markupdecls',
move reference to Aho et al. into appendix (Tim's right),
add prose note saying that hash marks and fragment identifiers are
NOT part of the URI formally speaking, and are NOT legal in 
system identifiers (processor 'may' signal an error).
Work through:
Tim Bray reacting to James Clark,
Tim Bray on his own,
Eve Maler,

NOT DONE YET:
change binary / text to unparsed / parsed.
handle James's suggestion about &lt; in attriubte values
uppercase hex characters,
namechar list,
</sitem>
<sitem>1997-12-01 : JB : add some column-width parameters</sitem>
<sitem>1997-12-01 : CMSMcQ : begin round of changes to incorporate
recent WG decisions and other corrections:
binding sources of character encoding info (27 Aug / 3 Sept),
correct wording of Faust quotation (restore dropped line),
drop SDD from EncodingDecl,
change text at version number 1.0,
drop misleading (wrong!) sentence about ignorables and extenders,
modify definition of PCData to make bar on msc grammatical,
change grammar's handling of internal subset (drop non-terminal markupdecls),
change definition of includeSect to allow conditional sections,
add integral-declaration constraint on internal subset,
drop misleading / dangerous sentence about relationship of
entities with system storage objects,
change table body tag to htbody as per EM change to DTD,
add rule about space normalization in public identifiers,
add description of how to generate our name-space rules from 
Unicode character database (needs further work!).
</sitem>
<sitem>1997-10-08 : TB : Removed %-constructs again, new rules
for PE appearance.</sitem>
<sitem>1997-10-01 : TB : Case-sensitive markup; cleaned up
element-type defs, lotsa little edits for style</sitem>
<sitem>1997-09-25 : TB : Change to elm's new DTD, with
substantial detail cleanup as a side-effect</sitem>
<sitem>1997-07-24 : CMSMcQ : correct error (lost *) in definition 
of ignoreSectContents (thanks to Makoto Murata)<E/sitem>
<sitem>Allow all empty elements to have end-tags, consistent with
SGML TC (as per JJC).</sitem>
<sitem>1997-07-23 : CMSMcQ : pre-emptive strike on pending corrections:
introduce the term 'empty-element tag', note that all empty elements
may use it, and elements declared EMPTY must use it.
Add WFC requiring encoding decl to come first in an entity.
Redefine notations to point to PIs as well as binary entities.
Change autodetection table by removing bytes 3 and 4 from 
examples with Byte Order Mark.
Add content model as a term and clarify that it applies to both
mixed and element content.
</sitem>
<sitem>1997-06-30 : CMSMcQ : change date, some cosmetic changes,
changes to productions for choice, seq, Mixed, NotationType,
Enumeration.  Follow James Clark's suggestion and prohibit 
conditional sections in internal subset.  TO DO:  simplify
production for ignored sections as a result, since we don't 
need to worry about parsers which don't expand PErefs finding
a conditional section.</sitem>
<sitem>1997-06-29 : TB : various edits</sitem>
<sitem>1997-06-29 : CMSMcQ : further changes:
Suppress old FINAL EDIT comments and some dead material.
Revise occurrences of % in grammar to exploit Henry Thompson's pun,
especially markupdecl and attdef.
Remove RMD requirement relating to element content (?).
</sitem>
<sitem>1997-06-28 : CMSMcQ : Various changes for 1 July draft:
Add text for draconian error handling (introduce
the term Fatal Error).
RE deleta est (changing wording from 
original announcement to restrict the requirement to validating
parsers).
Tag definition of validating processor and link to it.
Add colon as name character.
Change def of %operator.
Change standard definitions of lt, gt, amp.
Strip leading zeros from #x00nn forms.</sitem>
<sitem>1997-04-02 : CMSMcQ : final corrections of editorial errors
found in last night's proofreading.  Reverse course once more on
well-formed:   Webster's Second hyphenates it, and that's enough
for me.</sitem>
<sitem>1997-04-01 : CMSMcQ : corrections from JJC, EM, HT, and self</sitem>
<sitem>1997-03-31 : Tim Bray : many changes</sitem>
<sitem>1997-03-29 : CMSMcQ : some Henry Thompson (on entity handling),
some Charles Goldfarb, some ERB decisions (PE handling in miscellaneous
declarations.  Changed Ident element to accept def attribute.
Allow normalization of Unicode characters.  move def of systemliteral
into section on literals.</sitem>
<sitem>1997-03-28 : CMSMcQ : make as many corrections as possible, from
Terry Allen, Norbert Mikula, James Clark, Jon Bosak, Henry Thompson,
Paul Grosso, and self.  Among other things:  give in on "well formed"
(Terry is right), tentatively rename QuotedCData as AttValue
and Literal as EntityValue to be more informative, since attribute
values are the <emph>only</emph> place QuotedCData was used, and
vice versa for entity text and Literal. (I'd call it Entity Text, 
but 8879 uses that name for both internal and external entities.)</sitem>
<sitem>1997-03-26 : CMSMcQ : resynch the two forks of this draft, reapply
my changes dated 03-20 and 03-21.  Normalize old 'may not' to 'must not'
except in the one case where it meant 'may or may not'.</sitem>
<sitem>1997-03-21 : TB : massive changes on plane flight from Chicago
to Vancouver</sitem>
<sitem>1997-03-21 : CMSMcQ : correct as many reported errors as possible.
</sitem>
<sitem>1997-03-20 : CMSMcQ : correct typos listed in CMSMcQ hand copy of spec.</sitem>
<sitem>1997-03-20 : CMSMcQ : cosmetic changes preparatory to revision for
WWW conference April 1997:  restore some of the internal entity 
references (e.g. to docdate, etc.), change character xA0 to &amp;nbsp;
and define nbsp as &amp;#160;, and refill a lot of paragraphs for
legibility.</sitem>
<sitem>1996-11-12 : CMSMcQ : revise using Tim's edits:
Add list type of NUMBERED and change most lists either to
BULLETS or to NUMBERED.
Suppress QuotedNames, Names (not used).
Correct trivial-grammar doc type decl.
Rename 'marked section' as 'CDATA section' passim.
Also edits from James Clark:
Define the set of characters from which [^abc] subtracts.
Charref should use just [0-9] not Digit.
Location info needs cleaner treatment:  remove?  (ERB
question).
One example of a PI has wrong pic.
Clarify discussion of encoding nalead to unspecified results; don't
prescribe error recovery.
Don't require exposure of entity boundaries.
Ignore white space in element content.
Reserve entity names of the form u-NNNN.
Clarify relative URLs.
And some of my own:
Correct productions for content model:  model cannot
consist of a name, so "elements ::= cp" is no good.
</sitem>
<sitem>1996-11-11 : CMSMcQ : revise for style.
Add new rhs to entity declaration, for parameter entities.</sitem>
<sitem>1996-11-10 : CMSMcQ : revise for style.
Fix / complete section on names, characters.
Add sections on parameter entities, conditional sections.
Still to do:  Add compatibility note on deterministic content models.
Finish stylistic revision.</sitem>
<sitem>1996-10-31 : TB : Add Entity Handling section</sitem>
<sitem>1996-10-30 : TB : Clean up term &amp; termdef.  Slip in
ERB decision re EMPTY.</sitem>
<sitem>1996-10-28 : TB : Change DTD.  Implement some of Michael's
suggestions.  Change comments back to //.  Introduce language for
XML namespace reservation.  Add section on white-space handling.
Lots more cleanup.</sitem>
<sitem>1996-10-24 : CMSMcQ : quick tweaks, implement some ERB
decisions.  Characters are not integers.  Comments are /* */ not //.
Add bibliographic refs to 10646, HyTime, Unicode.
Rename old Cdata as MsData since it's <emph>only</emph> seen
in marked sections.  Call them attribute-value pairs not
name-value pairs, except once.  Internal subset is optional, needs
'?'.  Implied attributes should be signaled to the app, not
have values supplied by processor.</sitem>
<sitem>1996-10-16 : TB : track down &amp; excise all DSD references;
introduce some EBNF for entity declarations.</sitem>
<sitem>1996-10-?? : TB : consistency check, fix up scraps so
they all parse, get formatter working, correct a few productions.</sitem>
<sitem>1996-10-10/11 : CMSMcQ : various maintenance, stylistic, and
organizational changes:
Replace a few literals with xmlpio and
pic entities, to make them consistent and ensure we can change pic
reliably when the ERB votes.
Drop paragraph on recognizers from notation section.
Add match, exact match to terminology.
Move old 2.2 XML Processors and Apps into intro.
Mention comments, PIs, and marked sections in discussion of
delimiter escaping.
Streamline discussion of doctype decl syntax.
Drop old section of 'PI syntax' for doctype decl, and add
section on partial-DTD summary PIs to end of Logical Structures
section.
Revise DSD syntax section to use Tim's subset-in-a-PI
mechanism.</sitem>
<sitem>1996-10-10 : TB : eliminate name recognizers (and more?)</sitem>
<sitem>1996-10-09 : CMSMcQ : revise for style, consistency through 2.3
(Characters)</sitem>
<sitem>1996-10-09 : CMSMcQ : re-unite everything for convenience,
at least temporarily, and revise quickly</sitem>
<sitem>1996-10-08 : TB : first major homogenization pass</sitem>
<sitem>1996-10-08 : TB : turn "current" attribute on div type into 
CDATA</sitem>
<sitem>1996-10-02 : TB : remould into skeleton + entities</sitem>
<sitem>1996-09-30 : CMSMcQ : add a few more sections prior to exchange
                            with Tim.</sitem>
<sitem>1996-09-20 : CMSMcQ : finish transcribing notes.</sitem>
<sitem>1996-09-19 : CMSMcQ : begin transcribing notes for draft.</sitem>
<sitem>1996-09-13 : CMSMcQ : made outline from notes of 09-06,
do some housekeeping</sitem>
</slist>
</revisiondesc>
</header>
<body> 
<div1 id='sec-intro'>
<head>Introduction</head>
<p>Extensible Markup Language, abbreviated XML, describes a class of
data objects called <termref def="dt-xml-doc">XML documents</termref> and
partially describes the behavior of 
computer programs which process them. XML is an application profile or
restricted form of SGML, the Standard Generalized Markup 
Language <bibref ref='ISO8879'/>.
By construction, XML documents 
are conforming SGML documents.
</p>
<p>XML documents are made up of storage units called <termref
def="dt-entity">entities</termref>, which contain either parsed
or unparsed data.
Parsed data is made up of <termref def="dt-character">characters</termref>,
some 
of which form <termref def="dt-chardata">character data</termref>, 
and some of which form <termref def="dt-markup">markup</termref>.
Markup encodes a description of the document's storage layout and
logical structure. XML provides a mechanism to impose constraints on
the storage layout and logical structure.</p>
<p><termdef id="dt-xml-proc" term="XML Processor">A software module
called an <term>XML processor</term> is used to read XML documents
and provide access to their content and structure.</termdef> <termdef
id="dt-app" term="Application">It is assumed that an XML processor is
doing its work on behalf of another module, called the
<term>application</term>.</termdef> This specification describes the
required behavior of an XML processor in terms of how it must read XML
data and the information it must provide to the application.</p>
 
<div2 id='sec-origin-goals'>
<head>Origin and Goals</head>
<p>XML was developed by an XML Working Group (originally known as the
SGML Editorial Review Board) formed under the auspices of the World
Wide Web Consortium (W3C) in 1996.
It was chaired by Jon Bosak of Sun
Microsystems with the active participation of an XML Special
Interest Group (previously known as the SGML Working Group) also
organized by the W3C. The membership of the XML Working Group is given
in an appendix. Dan Connolly served as the WG's contact with the W3C.
</p>
<p>The design goals for XML are:<olist>
<item><p>XML shall be straightforwardly usable over the
Internet.</p></item>
<item><p>XML shall support a wide variety of applications.</p></item>
<item><p>XML shall be compatible with SGML.</p></item>
<item><p>It shall be easy to write programs which process XML
documents.</p></item>
<item><p>The number of optional features in XML is to be kept to the
absolute minimum, ideally zero.</p></item>
<item><p>XML documents should be human-legible and reasonably
clear.</p></item>
<item><p>The XML design should be prepared quickly.</p></item>
<item><p>The design of XML shall be formal and concise.</p></item>
<item><p>XML documents shall be easy to create.</p></item>
<item><p>Terseness in XML markup is of minimal importance.</p></item></olist>
</p>
<p>This specification, 
together with associated standards
(Unicode and ISO/IEC 10646 for characters,
Internet RFC 1766 for language identification tags, 
ISO 639 for language name codes, and 
ISO 3166 for country name codes),
provides all the information necessary to understand 
XML Version &XML.version;
and construct computer programs to process it.</p>
<p>This version of the XML specification
<!-- is for &doc.audience;.-->
&doc.distribution;.</p>

</div2>
 


 
<div2 id='sec-terminology'>
<head>Terminology</head>
 
<p>The terminology used to describe XML documents is defined in the body of
this specification.
The terms defined in the following list are used in building those
definitions and in describing the actions of an XML processor:
<glist>
<gitem>
<label>may</label>
<def><p><termdef id="dt-may" term="May">Conforming documents and XML
processors are permitted to but need not behave as
described.</termdef></p></def>
</gitem>
<gitem>
<label>must</label>
<def><p>Conforming documents and XML processors 
are required to behave as described; otherwise they are in error.
<!-- do NOT change this! this is what defines a violation of
a 'must' clause as 'an error'. -MSM -->
</p></def>
</gitem>
<gitem>
<label>error</label>
<def><p><termdef id='dt-error' term='Error'
>A violation of the rules of this
specification; results are
undefined.  Conforming software may detect and report an error and may
recover from it.</termdef></p></def>
</gitem>
<gitem>
<label>fatal error</label>
<def><p><termdef id="dt-fatal" term="Fatal Error">An error
which a conforming <termref def="dt-xml-proc">XML processor</termref>
must detect and report to the application.
After encountering a fatal error, the
processor may continue
processing the data to search for further errors and may report such
errors to the application.  In order to support correction of errors,
the processor may make unprocessed data from the document (with
intermingled character data and markup) available to the application.
Once a fatal error is detected, however, the processor must not
continue normal processing (i.e., it must not
continue to pass character data and information about the document's
logical structure to the application in the normal way).
</termdef></p></def>
</gitem>
<gitem>
<label>at user option</label>
<def><p>Conforming software may or must (depending on the modal verb in the
sentence) behave as described; if it does, it must
provide users a means to enable or disable the behavior
described.</p></def>
</gitem>
<gitem>
<label>validity constraint</label>
<def>5p>A rule which applies to all 
<termref def="dt-valid">valid</termref> XML documents.
Violations of validity constraints are errors; they must, at user option, 
be reported by 
<termtttttttttttttttttttttt">validating XML processors</termref>.</p></def>
</gitem>
<gitem>
<label>well-formedness constraint</label>
<def><p>A rule which applies to all <termref
def="dt-wellformed">well-formed</termref> XML documents.
Violations of well-formedness constraints are 
<termref def="dt-fatal">fatal errors</termref>.</p></def>
</gitem>

<gitem>
<label>match</label>
<def><p><termdef id="dt-match" term="match">(Of strings or names:) 
Two strings or names befng compared must be identical.
Characters with multiple possible representations in ISO/IEC 10646 (e.g.
characters with 
both precomposed and base+diacritic forms) match only if they have the
same representation in both strings.
At user option, processors may normalize such characters to
some canonical form.
No case folding is performed. 
(Of strings and rules in the grammar:)  
A string matches a grammatical production if it belongs to the
language generated by that production.
(Of content and content models:)
An element matches its declaration when it conforms
in the fashion described in the constraint
<specref ref='elementvalid'/>.
</termdef>
</p></def>
</gitem>
<gitem>
<label>for compatibility</label>
<def><p><termdef id="dt-compat" term="For Compatibility">A feature of
XML included solely to ensure that XML remains compatible with SGML.
</termdef></p></def>
</gitem>
<gitem>
<label>for interoperability</label>
<def><p><termdef id="dt-interop" term="For interoperability">A
non-binding recommendation included to increase the chances that XML
documents can be processed by the existing installed base of SGML
processors which predate the
&WebSGML;.</termdef></p></def>
</gitem>
</glist>
</p>
</div2>

 
</div1>
<!-- &Docs; -->
 
<div1 id='sec-documents'>
<head>Documents</head>
 
<p><termdef id="dt-xml-doc" term="XML Dollo wt">
A data object is an
<term>XML document</term> if it is
<termref def="dt-wellformed">well-formed</termref>, as
defined in this specification.
A well-formed XML document may in addition be
<termref def="dt-valid">valid</termref> if it meets certain further 
constraints.</termdef></p>
 
<p>Each XML document has both a logical and a physical structure.
Physically, the document is composed of units called <termref
def="dt-entity">entities</termref>.  An entity may <termref
def="dt-entref">refer</termref> to other entities to cause their
inclusion in the document. A document begins in a "root"  or <termref
def="dt-docent">document entity</termref>.
Logically, the document is composed of declarations, elements, 
comments,
character references, and
processing
instructions, all of which are indicated in the document by explicit
markup.
The logical and physical structures must nest properly, as described  
in <specref ref='wf-entities'/>.
</p>
 
<div2 id='sec-well-formed'>
<head>Well-Formed XML Documents</head>
 
<p><termdef id="dt-wellformed" term="Well-Formed">
A textual object is 
a well-formed XML document if:</termdef>
<olist>
<item><p>Taken as a whole, it
matches the production labeled <nt def='NT-document'>document</nt>.</p></item>
<item><p>It
meets all the well-formedness constraints given in this specification.</p>
</item>
<item><p>Each of the <termref def='dt-parsedent'>parsed entities</termref> 
which is referenced directly or indirectly within the document is
<titleref href='wf-entities'>well-formed</titleref>.</p></item>
</olist></p>
<p>
<scrap lang='ebnf' id='document'>
<head>Document</head>
<prod id='NT-document'><lhs>document</lhs>
<rhs><nt def='NT-prolog'>prolog</nt> 
<nt def='NT-element'>element</nt> 
<nt def='NT-Misc'>Misc</nt>*</rhs></prod>
</scrap>
</p>
<p>Matching the <nt def="NT-document">document</nt> production 
implies that:
<olist>
<item><p>It contains one or more
<termref def="dt-element">elements</termref>.</p>
</item>
<!--* N.B. some readers (notably JC) find the following
paragraph awkward and redundant.  I agree it's logically redundant:
it *says* it is summarizing the logical implications of
matching the grammar, and that means by definition it's
logically redundant.  I don't think it's rhetorically
redundant or unnecessary, though, so I'm keeping it.  It
could however use some recasting when the editors are feeling
stronger. -MSM *-->
<item><p><termdef id="dt-root" term="Root Element">There , called the <term>root</term>, or document element,  no
part of which appears in the <termref
def="dt-content">content</termref> of any other element.</termdef>
For all other elements, if the start-tag is in the content of another
element, the end-tag is in the content of the same element.  More
simply stated, the elements, delimited by start- and end-tags, nest
properly within each other.
</p></item>
</olist>
</p>
<p><termdef id="dt-parentchild" term="Parent/Child">As a consequence 
of this,
for each non-root element
<code>C</code> in the document, there is one other element <code>P</code>
in the document such that 
<code>C</code> is in the content of <code>P</code>, but is not in
the content of any other element that is in the content of
<code>P</code>.  
<code>P</code> is referred to as the
<term>parent</term> of <code>C</code>, and <code>C</code> as a
<term>child</term> of <code>P</code>.</termdef></p></div2>
 
<div2 id="charsets">
<head>Characters</head>
 
<p><termdef id="dt-text" term="Text">A parsed entity contains
<term>text</term>, a sequence of 
<termref def="dt-character">characters</termref>, 
which may represent markup or character data.</termdef> 
<termdef id="dt-character" term="Character">A <term>character</term> 
is an atomic unit of text as specified by
ISO/IEC 10646 <bibref ref="ISO10646"/>.
Lar3/></foo>
</valid>
<invaliage return, line feed, and the legal
graphic characters of Unicode and ISO/IEC 10646.
The use of "compatibility characters", as defined in section 6.8
of <bibref ref='Unicode'/>, is discouraged.
</termdef> 
<scrap lang="ebnf" id="char32">
<head>Character Range</head>
<prodgroup pcw2="4" pcw4="17.5" pcw5="11">
<prod id="NT-Char"><lhs>Char</lhs> 
<rhs>#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] 
| [#x10000-#x10FFFF]</rhs> 
<com>any Unicode character, excluding the
surrogate blocks, FFFE, and FFFF.</com> </prod>
</prodgroup>
</scrap>
</p>

<p>The mechanism for encoding character code points into bit patterns may
vary from entity to entity. All XML processors must accept the UTF-8
and UTF-16 encodings of 10646; the mechanisms for signaling which of
the two is in use, or for bringing other encodings into play, are
discussed later, in <specref ref='charencoding'/>.
</p>
<!--
<p>Regardless of the specific encoding used, any character in the ISO/IEC
10646 character set may be referred to by the decimal or hexadecimal
equivalent of its 
UCS-4 code value.
</p>-->
</div2>
 
<div2 id='sec-common-syn'>
<head>Common Syntactic Constructs</head>
 
<p>This section defines some symbols used widely in the grammar.</p>
<p><nt def="NT-S">S</nt> (white space) consists of one or more space (#x20)
characters, carriage returns, line feeds, or tabs.

<scrap lang="ebnf" id='white'>
<head>White Space</head>
<prodgroup pcw2="4" pcw4="17.5" pcw5="11">
<prod id='NT-S'><lhs>S</lhs>
<rhs>(#x20 | #x9 | #xD | #xA)+</rhs>
</prod>
</prodgroup>
</scrap></p>
<p>Characters are classified for convenience as letters, digits, or other
characters.  Letters consist of an alphabetic or syllabic 
base character possibly
followed by one or more combining characters, or of an ideographic
character.  
Full definitions of the specific characters in each class
are given in <specref ref='CharClasses'/>.</p>
<p><termdef id="dt-name" term="Name">A <term>Name</term> is a token
beginning with a letter or one of a few punctuation characters, and continuing
with letters, digits, hyphens, underscores, colons, or full stops, together
known as name characters.</termdef>
Names beginning with the string "<code>xml</code>", or any string
which would match <code>(('X'|'x') ('M'|'m') ('L'
reserved for standardization in this or future versions of this
specification.
</p>
<note>
<p>The colon character within XML names is reserved for experimentation witÿÿÿme spaces.  
Its meaning is expected to be
standardized at some future point, at which point those documents 
using the colon for experimental purposes may need to be updated.
(There is no guarantee that any name-space mechanism
adopted for XML will in fact use the colon as a name-space delimiter.)
In practice, this means that authors should not use the colon in XML
names except as part of name-space experiments, but that XML processors
should accept the colon as a name character.</p>
</note>
<p>An
<nt def='NT-Nmtoken'>Nmtoken</nt> (name token) is any mixture of
name characters.
<scrap lang='ebnf'>
<head>Names and Tokens</head>
<prod id='NT-NameChar'><lhs>NameChar</lhs>
<rhs><nt def="NT-Letter">Letter</nt> 
| <nt def='NT-Digit'>Digit</nt> 
| '.' | '-' | '_' | ':'
| <nt def='NT-CombiningChar'>CombiningChar</nt> 
| <nt def='NT-Extender'>Extender</nt></rhs>
</prod>
<prod id='NT-Name'><lhs>Name</lhs>
<rhs>(<nt def='NT-Letter'>Letter</nt> | '_' | ':')
(<nt def='NT-NameChar'>NameChar</nt>)*</rhs></prod>
<prod id='NT-Names'><lhs>Names</lhs>
<rhs><nt def='NT-Name'>Name</nt> 
(<nt def='NT-S'>S</nt> <nt def='NT-Name'>Name</nt>)*</rhs></prod>
<prod id='NT-Nmtoken'><lhs>Nmtoken</lhs>
<rhs>(<nt def='NT-NameChar'>NameChar</nt>)+</rhs></prod>
<prod id='NT-Nmtokens'><lhs>Nmtokens</lhs>
<rhs><nt def='NT-Nmtoken'>Nmtoken</nt> (<nt def='NT-S'>S</nt> <nt def='NT-Nmtoken'>Nmtoken</nt>)*</rhs></prod>
</scrap>
</p>
<p>Literal data is any quoted string not containing
the quotation mark used as a delimiter for that string.
Literals are used
for specifying the content of internal entities
(<nt def='NT-EntityValue'>EntityValue</nt>),
the values of attributes (<nt def='NT-AttValue'>AttValue</nt>), 
and external identifiers 
(<nt def="NT-SystemLiteral">SystemLiteral</nt>).  
Note that a <nt def='NT-SystemLiteral'>SystemLiteral</nt>
can be parsed without scanning for markup.
<scrap lang='ebnf'>
<head>Literals</head>
<prod id='NT-EntityValue'><lhs>EntityValue</lhs>
<rhs>'"' 
([^%&amp;"] 
| <nt def='NT-PEReference'>PEReference</nt> 
| <nt def='NT-Reference'>Reference</nt>)*
'"' 
</rhs>
<rhs>|&nbsp; 
"'" 
([^%&amp;'] 
| <nt def='NT-PEReference'>PEReference</nt> 
| <nt def='NT-Reference'>Reference</nt>)* 
"'"</rhs>
</prod>
<prod id='NT-AttValue'><lhs>AttValue</lhs>
<rhs>'"' 
([^&lt;&amp;"] 
| <nt def='NT-Reference'>Reference</nt>)* 
'"' 
</rhs>
<rhs>|&nbsp; 
"'" 
([^&lt;&amp;'] 
| <nt def='NT-Reference'>Reference</nt>)* 
"'"</rhs>
</prod>
<prod id="NT-SystemLiteral"><lhs>SystemLiteral</lhs>
<rhs>('"' [^"]* '"') |&nbsp;("'" [^']* "'")
</rhs>
</prod>
<prod id="NT-PubidLiteral"><lhs>PubidLiteral</lhs>
<rhs>'"' <nt def='NT-PubidChar'>PubidChar</nt>* 
'"' 
| "'" (<nt def='NT-PubidChar'>PubidChar</nt> - "'")* "'"</rhs>
</prod>
<prod id="NT-PubidChar"><lhs>PubidChar</lhs>
<rhs>#x20 | #xD | #xA 
|&nbsp;[a-zA-Z0-9]
|&nbsp;[-'()+,./:=?;!*#@$_%]</rhs>
</prod>
</scrap>
</p>

</div2>

<div2 id='syntax'>
<head>Character Data and Markup</head>
 
<p><termref def='dt-text'>Text</termref> consists of intermingled 
<termref def="dt-chardata">character
data</termref> and markup.
<termdef id="dt-markup" term="Markup"><term>Markup</term> takes the form of
<termref def="dt-stag">start-tags</termref>,
<termref def="dt-etag">end-tags</termref>,
<termref def="dt-empty">empty-element tags</termref>,
<termref def="dt-entref">entity references</termref>,
<termref def="dt-charref">character references</termref>,
<termref def="dt-comment">comments</termref>,
<termref def="dt-cdsection">CDATA section</termref> delimiters,
<termref def="dt-doctype">document type declarations</termref>, and
<termref def="dt-pi">processing instructions</termref>.
</termdef>
</p>
<p><termdef id="dt-chardata" term="Character Data">All text that is not markup
constitutes the <term>character data</term> of
the document.</termdef></p>
<p>The ampersand character (&amp;) and the left angle bracket (&lt;)
may appear in their literal form <emph>only</emph> when used as markup
delimiters, or within a <termref def="dt-comment">comment</termref>, a
<termref def="dt-pi">processing instruction</termref>, 
or a <termref def="dt-cdsection">CDATA section</termref>.  

They are also legal within the <termref def='dt-litentval'>literal entity
value</termref> of an internal entity declaration; see
<specref ref='wf-entities'/>.
<!-- FINAL EDIT:  restore internal entity decl or leave it out. -->
If they are needed elsewhere,
they must be <termref def="dt-escape">escaped</termref>
using either <termref def='dt-charref'>numeric character references</termref>
or the strings
"<code>&amp;amp;</code>" and "<code>&amp;lt;</code>" respectively. 
The right angle
bracket (>) may be represented using the string
"<code>&amp;gt;</code>", and must, <termref def='dt-compat'>for
compatibility</termref>, 
be escaped using
"<code>&amp;gt;</code>" or a character reference 
when it appears in the string
"<code>]]&gt;</code>"
in content, 
when that string is not marking the end of 
a <termref def="dt-cdsection">CDATA section</termref>. 
</p>
<p>
In the content of elements, character data 
is any string of characters which does
not contain the start-delimiter of any markup.  
In a CDATA section, character data
is any string of characters not including the CDATA-section-close
delimiter, "<code>]]&gt;</code>".</p>
<p>
To allow attribute values to contain both single and double quotes, the
apostrophe or single-quote character (') may be represented as
"<code>&amp;apos;</code>", and the double-quote character (") as
"<code>&amp;quot;</code>".
<scrap lang="ebnf">
<head>Character Data</head>
<prod id='NT-CharData'>
<lhs>CharData</lhs>
<rhs>[^&lt;&amp;]* - ([^&lt;&amp;]* ']]&gt;' [^&lt;&amp;]*)</rhs>
</prod>
</scrap>
</p>
</div2>
 
<div2 id='sec-comments'>
<head>Comments</head>
 
<p><termdef id="dt-comment" term="Comment"><term>Comments</term> may 
appear anywhere in a document outside other 
<termref def='dt-markup'>markup</termref>; in addition,
they may appear within the document type declaration
at places allowed by the grammar.
They are not part of the document's <termref def="dt-chardata">character
data</termref>; an XML
processor may, but need not, make it possible for an application to
retrieve the text of comments.
<termref def="dt-compat">For compatibility</termref>, the string
"<code>--</code>" (double-hyphen) must not occur within
comments.
<scrap lang="ebnf">
<head>Comments</head>
<prod id='NT-Comment'><lhs>Comment</lhs>
<rhs>'&lt;!--'
((<nt def='NT-Char'>Char</nt> - '-') 
| ('-' (<nt def='NT-Char'>Char</nt> - '-')))* 
'-->'</rhs>
</prod>
</scrap>
</termdef></p>
<p>An example of a comment:
<eg>&lt;!&como; declarations for &lt;head> &amp; &lt;body> &comc;&gt;</eg>
</p>
</div2>
 
<div2 id='sec-pi'>
<head>Processing Instructions</head>
 
<p><termdef id="dt-pi" term="Processing instruction"><term>Processing
instructions</term> (PIs) allow documents to contain instructions
for applications.
 
<scrap lang="ebnf">
<head>Processing Instructions</head>
<prod id='NT-PI'><lhs>PI</lhs>
<rhs>'&lt;?' <nt def='NT-PITarget'>PITarget</nt> 
(<nt def='NT-S'>S</nt> 
(<nt def='NT-Char'>Char</nt>* - 
(<nt def='NT-Char'>Char</nt>* &pic; <nt def='NT-Char'>Char</nt>*)))?
&pic;</rhs></prod>
<prod id='NT-PITarget'><lhs>PITarget</lhs>
<rhs><nt def='NT-Name'>Name</nt> - 
(('X' | 'x') ('M' | 'm') ('L' | 'l'))</rhs>
</prod>
</scrap></termdef>
PIs are not part of the document's <termref def="dt-chardata">character
data</termref>, but must be passed through to the application. The
PI begins with a target (<nt def='NT-PITarget'>PITarget</nt>) used
to identify the application to which the€instruction is directed.  
The target names "<code>XML</code>", "<code>xml</code>", and so on are
reserved for standardization in this or future versions of this
specification.
The 
XML <termref def='dt-notation'>Notation</termref> mechanism
may be used for
formal declaration of PI targets.
</p>
</div2>
 
<div2 id='sec-cdata-sect'>
<head>CDATA Sections</head>
 
<p><termdef Section"><term>CDATA sections</term>
may occur 
anywhere character data may occur; they are
used to escape blocks of text containing characters which would
otherwise be recognized as markup.  CDATA sections begin with the
string "<code>&lt;![CDATA[</code>" and end with the string
"<code>]]&gt;</code>":
<scrap lang="ebnf">
<head>CDATA Sections</head>
<prod id='NT-CDSect'><lhs>CDSect</lhs>
<rhs><nt def='NT-CDStart'>CDStart</nt> 
<nt def='NT-CData'>CData</nt> 
<nt def='NT-CDEnd'>CDEnd</nt></rhs></prod>
<prod id='NT-CDStart'><lhs>CDStart</lhs>
<rhs>'&lt;![CDATA['</rhs>
</prod>
<prod id='NT-CData'><lhs>CData</lhs>
<rhs>(<nt def='NT-Char'>Char</nt>* - 
(<nt def='NT-Char'>Char</nt>* ']]&gt;' <nt def='NT-Char'>Char</nt>*))
</rhs>
</prod>
<prod id='NT-CDEnd'><lhs>CDEnd</lhs>
<rhs>']]&gt;'</rhs>
</prod>
</scrap>

Within a CDATA section, only the <nt def='NT-CDEnd'>CDEnd</nt> string is
recognized as markup, so that left angle brackets and ampersands may occur in
their literal form; they need not (and cannot) be escaped using
"<code>&amp;lt;</code>" and "<code>&amp;amp;</code>".  CDATA sections
cannot nest.</termdef>
</p>

<p>An example of a CDATA section, in which "<code>&lt;greeting></code>" and 
"<code>&lt;/greeting></code>"
are recognized as <termref def='dt-chardata'>character data</termref>, not
<termref def='dt-markup'>markup</termref>:
<eg>&lt;![CDATA[&lt;greeting>Hello, world!&lt;/greeting>]]&gt;</eg>
</p>
</div2>
 
<div2 id='sec-prolog-dtd'>
<head>Prolog and Document Type Declaration</head>
 
<p><termdef id='dt-xmldecl' term='XML Declaration'>XML documents 
may, and should, 
begin with an <term>XML declaration</term> which specifies
the version of
XML being used.</termdef>
For example, the following is a complete XML document, <termref
def="dt-wellformed">well-formed</termref> but not
<termref def="dt-valid">valid</termref>:
<eg><![CDATA[<?xml version="1.0"?>
<greeting>Hello, world!</greeting>
]]></eg>
and so is this:
<eg><![CDATA[<greeti/eg>
</p>

<p>The version number "<code>1.0</code>" should be used to indicate
conformance to this version of this specification; it is an error
for a document to use the value "<code>1.0</code>" 
if it does not conform to this version of this specification.
It is the intent
of the XML working group to give later versions of this specification
numbers other than "<code>1.0</code>", but this intent dœœœœœœœœœœœœœœœœœœœœœœœœœœœœt to produce any future versions of XML, nor if any are produced, to
use any particular numbering scheme.
Since future versions are not ruled out, this construct is provided 
as a means to allow the possibility of automatic version recognition, should
it become necessary.
Processors may signal an error if they receive documents labeled with 
versions they do not support. 
</p>
<p>The function of the markup in an XML document is to describe its
storage and logical structure and to associate attribute-value pairs
with its logical structures.  XML provides a mechanism, the <termref
def="dt-doctype">document type declaration</termref>, to define
constraints on the logical structure and to support the use of
predefined storage units.

<termdef id="dt-valid" term="Validity">An XML document is 
<term>valid</term> if it has an associated document type
declaration and if the document
complies with the constraints expressed in it.</termdef></p>
<p>The document type declaration must appear before
the first <termref def="dt-element">element</termref> in the document.
<scrap lang="ebnf" id='xmldoc'>
<head>Prolog</head>
<prodgroup pcw2="6" pcw4="17.5" pcw5="9">
<prod id='NT-prolog'><lhs>prolog</lhs>
<rhs><nt def='NT-XMLDecl'>XMLDecl</nt>? 
<nt def='NT-Misc'>Misc</nt>* 
(<nt def='NT-doctypedecl'>doctypedecl</nt> 
<nt def='NT-Misc'>Misc</nt>*)?</rhs></prod>
<prod id='NT-XMLDecl'><lhs>XMLDecl</lhs>
<rhs>&xmlpio; 
<nt def='NT-VersionInfo'>VersionInfo</nt> 
<nt def='NT-EncodingDecl'>EncodingDecl</nt>? 
<nt def='NT-SDDecl'>SDDecl</nt>? 
<nt def="NT-S">S</nt>? 
&pic;</rhs>
</prod>
<prod id='NT-VersionInfo'><lhs>VersionInfo</lhs>
<rhs><nt def="NT-S">S</nt> 'version' <nt def='NT-Eq'>Eq</nt> 
(' <nt def="NT-VersionNum">VersionNum</nt> ' 
| " <nt def="NT-VersionNum">VersionNum</nt> ")</rhs>
</prod>
<prod id='NT-Eq'><lhs>Eq</lhs>
<rhs><nt def='NT-S'>S</nt>? '=' <nt def='NT-S'>S</nt>?</rhs></prod>
<prod id="NT-VersionNum">
<lhs>VersionNum</lhs>
<rhs>([a-zA-Z0-9_.:] | '-')+</rhs>
</prod>
<prod id='NT-Misc'><lhs>Misc</lhs>
<rhs><nt def='NT-Comment'>Comment</nt> | <nt def='NT-PI'>PI</nt> | 
<nt def='NT-S'>S</nt></rhs></prod>
</prodgroup>
</scra<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article [
<!-- ELEMENT declarations work around MSXML bug. -->
<!ELEMENT section ANY>
<!ATTLIST section id ID #IMPLIED>
<!ELEMENT appendix ANY>
<!ATTLIST appendix id ID #IMPLIED>
<!ELEMENT bibliomixed ANY>
<!ATTLIST bibliomixed id ID #IMPLIED>
]>
<article status="Committee Specification" xmlns:p="http://rela\ng.org/ns/proofsystem">

<articleinfo>
<releaseinfo>$Id: spec.xml,v 1.159 2001/12/02 12:12:12 jjc Exp $</releaseinfo>
<title>RELAX NG Specification</title>
<authorgroup>
<editor>
  <firstname>James</firstname><surname>Clark</surname>
  <affiliation>
    <address><email>jjc@jclark.com</email></address>
  </affiliation>
</editor>
<editor>
  <surname>MURATA</surname><firstname>Makoto</firstname>
  <affiliation>
    <address><email>EB2M-MRT@asahi-net.or.jp</email></address>
  </affiliation>
</editor>
</authorgroup>
<pubdate>3 December 2001</pubdate>
<releaseinfo role="meta">
$Id: spec.xml,v 1.159 2001/12/02 12:12:12 jjc Exp $
</releaseinfo>

<copyright><year>2001</year><holder>OASIS</holder></copyright>

<legalnotice>

<para>Copyright &#169; The Organization for the Advancement of
Structured Information Standards [OASIS] 2001. All Rights
Reserved.</para>

<para>This document and translations of it may be copied and furnished
to others, and derivative works that comment on or otherwise explain
it or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to OASIS, except as needed for the
purpose of developing OASIS specifications, in which case the
procedures for copyrights defined in the OASIS Intellectual Property
Rights document must be followed, or as required to translate it into
languages other than English.</para>

<para>The limited permissions granted above are perpetual and will not
be revoked by OASIS or its successors or assigns.</para>

<para>This document and the information contained herein is provided
on an <quote>AS IS</quote> basis and OASIS DISCLAIMS ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE
USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</para>

</legalnotice>

<legalnotice role="status"><title>Status of this Document</title>

<para>This Committee Specification was approved for publication by the
OASIS RELAX NG technical committee. It is a stable document which
represents the consensus of the committee. Comments on this document
may be sent to <ulink
url="mailto:relax-ng-comment@lists.oasis-open.org"
>relax-ng-comment@lists.oasis-open.org</ulink>.</para>

<para>A list of known errors in this document is available at <ulink
url="http://www.oasis-open.org/committees/relax-ng/spec-20011203-errata.html"
>http://www.oasis-open.org/committees/relax-ng/spec-20011203-errata.html</ulink
>.</para>

</legalnotice>

<abstract>
<para>This is the definitive specification of RELAX NG, a simple
schema language for XML, based on <xref linkend="relax"/> and <xref
linkend="trex"/>. A RELAX NG schema specifies a pattern for the
structure and content of an XML document. A RELAX NG schema is itself
an XML document.</para>
</abstract>

<revhistory>
<revision>
  <revnumber>Committee Specification</revnumber>
  <date>3 December 2001</date>
</revision>
<revision>
  <revnumber>Committee Specification</revnumber>
  <date>11 August 2001</date>
</revision>
</revhistory>
</articleinfo>


<section>
<title>Introduction</title>

<para>This document specifies</para>

<itemizedlist>

<listitem><para>when an XML document is a correct RELAX NG
schema</para></listitem>

<listitem><para>when an XML document is valid with respect to a
correct RELAX NG schema</para></listitem>

</itemizedlist>

<para>An XML document that is being validated with respect to a RELAX NG
schema is referred to as an instance.</para>

<para>The structure of this document is as follows.  <xref
linkend="data-model"/> describes the data model, which is the
abstraction of an XML document used throughout the rest of the
document.  <xref linkend="full-syntax"/> describes the syntax of a
RELAX NG schema; any correct RELAX NG schema must conform to this
syntax.  <xref linkend="simplification"/> describes a sequence of
transformations that are applied to simplify a RELAX NG schema;
applying the transformations also involves checking certain
restrictions that must be satisfied by a correct RELAX NG
schema. <xref linkend="simple-syntax"/> describes the syntax that
results from applying the transformations; this simple syntax is a
subset of the full syntax.  <xref linkend="semantics"/> describes the
semantics of a correct RELAX NG schema that uses the simple syntax;
the semantics specify when an element is valid with respect to a RELAX
NG schema.  <xref linkend="restriction"/> describes restrictions in
terms of the simple syntax; a correct RELAX NG schema must be such
that, after transformation into the simple form, it satisfies these
restrictions. Finally, <xref linkend="conformance"/> describes
conformance requirements for RELAX NG validators.</para>

<para>A tutorial is available separately (see <xref
linkend="tutorial"/>).</para>

</section>

<section id="data-model">
<title>Data model</title>

<para>RELAX NG deals with XML documents representing both schemas and
instances through an abstract data model.  XML documents representing
schemas and instances must be well-formed in conformance with <xref
linkend="xml-rec"/> and must conform to the constraints of <xref
linkend="xml-names"/>.</para>

<para>An XML document is represented by an element.  An element consists
of</para>

<itemizedlist>

<listitem><para>a name</para></listitem>

<listitem><para>a context</para></listitem>

<listitem><para>a set of attributes</para></listitem>

<listitem><para>an ordered sequence of zero or more children; each
child is either an element or a non-empty string; the sequence never contains
two consecutive strings</para></listitem>

</itemizedlist>

<para>A name consists of</para>

<itemizedlist>
<listitem><para>a string representing the namespace URI; the empty
string has special significance, representing the absence of any
namespace</para></listitem>

<listitem><para>a string representing the local name; this string matches the NCName
prtduction of <xref linkend="xml-names"/></para></listitem>
</itemizedlist>

<para>A context consists of</para>

<itemizedlist>
<listitem><para>a base URI</para></listitem>
<listitem><para>a namespace map; this maps prefixes to namespace URIs,
and also may specify a default namespace URI (as declared
by the <literal>xmlns</literal> attribute)</para></listitem>
</itemizedlist>

<para>An attribute consists of</para>

<itemizedlist>
<listitem><para>a name</para></listitem>
<listitem><para>a string representing the value</para></listitem>
</itemizedlist>

<para>A string consists of a sequence of zero or more characters,
where a character is as defined in <xref linkend="xml-rec"/>.</para>

<para>The element for an XML document is constructed from an instance
of the <xref linkend="infoset"/> as follows.  We use the notation
[<replaceable>x</replaceable>] to refer to the value of the
<replaceable>x</replaceable> property of an information item. An
element is constructed from a document information item by
constructing an element from the [document element].  An element is
constructed from an element information item by constructing the name
from the [namespace name] and [local name], the context from the [base
URI] and [in-scope namespaces], the attributes from the [attributes],
and the children from the [children].  The attributes of an element
are constructed from the unordered set of attribute information items
by constructing an attribute for each attribute information item.  The
children of an3element are constructed from the list of child
information items first by removing information items other than
element information items and character information items, and then by
constructing an element for each element information item in the list
and a string for each maximal sequence of character information items.
An attribute is constructed from an attribute information item by
constructing the name from the [namespace name] and [local name], and
the value from the [normalized value].  When constructing the name of
an element or attribute from the [namespace name] and [local name], if
the [namespace name] property is not present, then the name is
constructed from an empty string and the [local name]. A string is
constructed from a sequence of character information items by
constructing a character from the [character r
information item.</para>

<para>It is possible for there to be multiple distinct infosets for a
single XML document.  This is because XML parsers are not required to
process all DTD declarations or expand all external parsed general
entities.  Amongst these multiple infosets, there is exactly one
infoset for which [all declarations processed] is true and which does
not contain any unexpanded entity reference information items.  This
is the infoset that is the basis for defining the RELAX NG data
model.</para>

<section id="data-model-example">
<title>Example</title>

<para>Suppose the document
<literal>http://www.example.com/doc.xml</literal> is as
follows:</para>

<programlisting><![CDATA[<?xml version="1.0"?>
<foo><pre1:bar1 xmlns:pre1="http://www.example.com/n1"/><pre2:bar2
  xmlns:pre2="http://www.example.com/n2"/></foo>
]]></programlisting>

<para>The element representing this document has</para>

<itemizedlist>
<listitem><para>a name which has</para>
<itemizedlist>

<listitem><para>the empty string as the namespace URI, representing
the absence of any namespace</para></listitem>

<listitem><para><literal>foo</literal> as the local
name</para></listitem>

</itemizedlist>

</listitem>

<listitem><para>a context which has</para>

<itemizedlist>
<listitem><para><literal>http://www.example.com/doc.xml</literal> as the base
URI</para></listitem>

<listitem><para>a namespace map which</para>

<itemizedlist>

<listitem><para>maps the prefix <literal>xml</literal> to the
namespace URI
<literal>http://www.w3.org/XML/1998/namespace</literal>
(the <literal>xml</literal> prefix is implicitly declared
by every XML document)</para></listitem>

<listitem><para>specifies the empty string as the default namespace
URI</para></listitem>

</itemizedlist>

</listitem>

</itemizedlist>

</listitem>

<listitem><para>an empty set of attributes</para></listitem>

<listitem><para>a sequence of children consisting
of an element which has</para>

<itemizedlist>
<listitem><para>a name which has</para>
<itemizedlist>

<listitem><para><literal>http://www.example.com/n1</literal> as the
namespace URI</para></listitem>

<listitem><para><literal>bar1</literal> as the local
name</para></listitem>

</itemizedlist>

</listitem>

<listitem><para>a context which has</para>

<itemizedlist>
<listitem><para><literal>http://www.example.com/doc.xml</literal> as the base
URI</para></listitem>

<listitem><para>a namespace map which</para>

<itemizedlist>

<listitem><para>maps the prefix <literal>pre1</literal> to the
namespace URI
<literal>http://www.example.com/n1</literal></para></listitem>

<listitem><para>maps the prefix <literal>xml</literal> to the
namespace URI
<literal>http://www.w3.org/XML/1998/namespace</literal></para></listitem>

<listitem><para>specifies the empty string as the default namespace
URI</para></listitem>

</itemizedlist>

</listitem>

</itemizedlist>

</listitem>

<listitem><para>an empty set of attributes</para></listitem>

<listitem><para>an empty sequence of children</para></listitem>

</itemizedlist>

<para>followed by an element which has</para>
 
<itemizedlist>
<listitem><para>a name which has</para>
<itemizedlist>

<listitem><para><literal>http://www.example.com/n2</literal> as the
namespace URI</para></listitem>

<listitem><para><literal>bar2</literal> as the local
name</para></listitem>

</itemizedlist>

</listitem>

<listitem><para>a context which has</para>

<itemizedlist>
<listitem><para><literal>http://www.example.com/doc.xml</literal> as the base
URI</para></listitem>

<listitem><para>a namespace map which</para>

<itemizedlist>

<listitem><para>maps the prefix <literal>pre2</literal> to the
namespace URI
<literal>http://www.example.com/n2</literal></para></listitem>

<listitem><para>maps the prefix <literal>xml</literal>=to the
namespace URI
<literal>http://www.w3.org/XML/1998/namespace</literal></para></listitem>

<listitem><para>specifies the empty string as the default namespace
URI</para></listitem>

</itemizedlist>

</listitem>

</itemizedlist>

</listitem>

<listitem><para>an empty set of attributes</para></listitem>

<listitem><para>an empty sequence of children</para></listitem>

</itemizedlist>

</listitem>
</itemizedlist>

</section>

</section>

<section id="full-syntax">
<title>Full syntax</title>

<para>The following grammar summarizes the syntax of RELAX NG.
Although we use a notation based on the XML representation of an RELAX
NG schema as a sequence of characters, the grammar must be understood
as operating at the data model level.  For example, although the
syntax uses <literal><![CDATA[<text/>]]></literal>, an instance or
schema can use <literal><![CDATA[<text></text>]]></literal> instead,
because they both represent the same element at the data model level.
All elements shown in the grammar are qualified with the namespace
URI:</para>

<programlisting>http://relaxng.org/ns/structure/1.0</programlisting>

<para>The symbols QName and NCName are defined in <xref
linkend="xml-names"/>.  The anyURI symbol has the same meaning as the
anyURI datatype of <xref linkend="xmlschema-2"/>: it indicates a
string that, after escaping of disallowed values as described in
Section 5.4 of <xref linkend="xlink"/>, is a URI reference as defined
in <xref linkend="rfc2396"/> (as modified by <xref
linkend="rfc2732"/>).  The symbol string matches any string.</para>

<para>In addition to the attributes shown explicitly, any element can
have an <literal>ns</literal> attribute and any element can have a
<literal>datatypeLibrary</literal> attribute. The
<literal>ns</literal> attribute can have any value.  The value of the
<literal>datatypeLibrary</literal> attribute must match the anyURI
symbol as described in the previous paragraph; in addition, it must
not use the relative form of URI reference and must not have a
fragment identifier; as an exception to this, the value may be the
empty string.</para>

<para>Any element can also have foreign attributes in addition to the
attributes shown in the grammar. A foreign attribute is an attribute
with a name whose namespace URI is neither the empty string nor the
RELAX NG namespace URI.  Any element that cannot have string children
(that is, any element other than <literal>value</literal>, <literal>param</literal>
and <literal>name</literal>) may have foreign child elements in addition
to the child elements shown in the grammar. A foreign element is an
element with a name whose namespace URI is not the RELAX NG namespace
URI.  There are no constraints on the relative position of foreign
child elements with respect to other child elements.</para>

<para>Any element can also have as children strings that consist
entirely of whitespace characters, where a whitespace character is one
of #x20, #x9, #xD or #xA. There are no constraints on the relative
position of whitespace string children with respect to child
elements.</para>

<para>Leading and trailing whitespace is allowed for value of each
<literal>name</literal>, <literal>type</literal> and
<literal>combine</literal> attribute and for the content of each
<literal>name</literal> element.</para>

<grammarref src="full.rng"/>

<section id="full-syntax-example">
<title>Example</title>

<para>Here is an example of a schema in the full syntax for the
document in <xref linkend="data-model-example"/>.</para>

<programlisting><![CDATA[<?xml version="1.0"?>
<element name="foo"
         xmlns="http://relaxng.org/ns/structure/1.0"
         xmlns:a="http://relaxng.org/ns/annotation/1.0"
         xmlns:ex1="http://www.example.com/n1"
         xmlns:ex2="http://www.example.com/n2">
  <a:documentation>A foo element.</a:document>
  <element name="ex1:bar1">
    <empty/>
  </element>
  <element name="ex2:bar2">
    <empty/>
  </element>
</element>]]></programlisting>

</section>

</section>

<section id="simplification">
<title>Simplification</title>

<para>The full syntax given in the previous section is transformed
into a simpler syntax by applying the following transformation rules
in order. The effect must be as if each rule was applied to all
elements in the schema before the next rule is applied.  A
transformation rule may also specify constraints that must be
satisfied by a correct schema. The transformation rules are applied
at the data model level.  Before the transformations are applied, the
schema is parsed into an instance of the data model.</para>

<section>
<title>Annotations</title>

<para>Foreign attributes and elements are removed.</para>

<note><para>It is safe to remove <literal>xml:base</literal>
attributes at this stage because <literal>xml:base</literal>
attributes are used in determining the [base URI] of an element
information item, which is in turn used to construct the base URI of
the context of an element.  Thus, after a document has been parsed
into an instance of the data model, <literal>xml:base</literal>
attributes can be discarded.</para></note>

</section>

<section>
<title>Whitespace</title>

<para>For each element other than <literal>value</literal> and
<literal>param</literal>, each child that is a string containing only
whitespace characters is removed.</para>

<para>Leading and trailing whitespace characters are removed from the
value of each <literal>name</literal>, <literal>type</literal> and
<literal>combine</literal> attribute and from the content of each
<literal>name</literal> element.</para>

</section>

<section>
<title><literal>datatypeLibrary</literal> attribute</title>

<para>The value of each <literal>datatypeLibary</literal> attribute is
transformed by escaping disallowed characters as specified in Section
5.4 of <xref linkend="xlink"/>.</para>

<para>For any <literal>data</literal> or <literal>value</literal>
element that does not have a <literal>datatypeLibrary</literal>
attribute, a <literal>datatypeLibrary</literal> attribute is
added. The value of the added <literal>datatypeLibrary</literal>
attribute is the value of the <literal>datatypeLibrary</literal>
attribute of the nearest ancestor element that has a
<literal>datatypeLibrary</literal> attribute, or the empty strindog if
there is no such ancestor. Then, any <literal>datatypeLibrary</literal>
attribute that is on an element other than <literal>data</literal> or
<literal>value</literal> is removed.</para>

</section>

<section>
<title><literal>type</literal> attribute of <literal>value</literal> element</title>

<para>For any <literal>value</literal> element that does not have a
<literal>type</literal> attribute, a <literal>type</literal> at2.element"/>
      </grolue <literal>token</literal> and the value of the
<literal>datatypeLibrary</literal> attribute is changed to the empty
string.</para>

</section>

<section id="href">
<title><literal>href</literal> attribute</title>

<para>The value of the <literal>href</literal> attribute on an
<literal>externalRef</literal> or <literal>include</literal> element
is first transformed by escaping disallowed characters as specified in
Section 5.4 of <xref linkend="xlink"/>.  The URI reference is then
resolved into an absolute form as described in section 5.2 of <xref
linkend="rfc2396"/> using the base URI from the context of the element
that bears the <literal>href</literal> attribute.</para>

<para>The value of the <literal>href</literal> attribute will be used
to construct an element (as specified in <xref
linkend="data-model"/>). This must be done as follows.  The URI
reference consists of the URI itself and an optional fragment
identifier. The resource identified by the URI is retrieved.  The
result is a MIME entity: a sequence of bytes labeled with a MIME
media type.  The media type determines how an element is constructed
from the MIME entity and optional fragment identifier.  When the media
type is <literal>application/xml</literal> or
<literal>text/xml</literal>, the MIME entity must be parsed as an XML
document in accordance with the applicable RFC (at the term of writing
<xref linkend="rfc3023"/>) and an element constructed from the result
of the parse as specified in <xref linkend="data-model"/>.  In
particular, the <literal>charset</literal> parameter must be handled
as specified by the RFC. This specification does not define the
handling of media types other than <literal>application/xml</literal>
and <literal>text/xml</literal>. The <literal>href</literal> attribute
must not include a fragment identifier unless the registration of the
media type of the resource identified by the attribute defines the
interpretation of fragment identifiers for that media type.</para>

<note><para><xref linkend="rfc3023"/> does not define the
interpretation of fragment identifiers for
<literal>application/xml</literal> or
<literal>text/xml</literal>.</para></note>

</section>

<section>
<title><literal>externalRef</literal> element</title>

<para>An <literal>externalRef</literal> element is transformed as
follows.  An element is constructed using the URI reference that is
the value of <literal>href</literal> attribute as specified in <xref
linkend="href"/>. This element must match the syntax for pattern.  The
element is transformed by recursively applying the rules from this
subsection and from previous subsections of this section. This must
not result in a loop. In other words, the transformation of the
referenced element must not require the dereferencing of an
<literal>externalRef</literal> attribute with an
<literal>href</literal> attribute with the same value.</para>

<para>Any <literal>ns</literal> attribute on the
<literal>externalRef</literal> element is transferred to the
referenced element if the referenced element does not already have an
<literal>ns</literal> attribute.  The <literal>externalRef</literal>
element is then replaced by the referenced element.</para>

</section>

<section>
<title><literal>include</literal> element</title>

<para>An <literal>include</literal> element is transformed as follows.
An element is constructed using the URI reference that is the value of
<literal>href</literal> attribute as specified in <xref
linkend="href"/>.  This element must be a <literal>grammar</literal>
element, matching the syntax for grammar.</para>

<para>This <literal>grammar</literal> element is transformed by
recursively applying the rules from this subsection and from previous
subsections of this section.  This must not result in a loop. In other
words, the transformation of the <literal>grammar</literal> element
must not require the dereferencing of an <literal>include</literal>
attribute with an <literal>href</literal> attribute with the same
value.</para>

<para>Define the <firstterm>components</firstterm> of an element to
be the children of the element together with the components of any
<literal>div</literal> child elements.  If the
<literal>include</literal> element has a <literal>start</literal>
component, then the <literal>grammar</literal> element must have a
<literal>start</literal> component.  If the <literal>include</literal>
element has a <literal>start</literal> component, then all
<literal>start</literal> components are removed from the
<literal>grammar</literal> element.  If the <literal>include</literal>
element has a <literal>define</literal> component, then the
<literal>grammar</literal> element must have a
<literal>define</literal> component with the same name.  For every
<literal>define</literal> component of the <literal>include</literal>
element, all <literal>define</literal> components with the same name
are removed from the <literal>grammar</literal> element.</para>

<para>The <literal>include</literal> element is transformed into a
<literal>div</literal> element.  The attributes of the
<literal>div</literal> element are the attributes of the
<literal>include</literal> element other than the
<literal>href</literal> attribute.  The children of the
<literal>div</literal> element are the <literal>grammar</literal>
element (after the removal of the <literal>start</literal> and
<literal>define<d>
ral> components described by the preceding
paragraph) followed by the children of the <literal>include</literal>
element.  The <literal>grammar</literal> element is then renamed to
<literal>div</literal>.</para>

</section>

<section>
<title><literal>name</literal> attribute of <literal>element</literal>
and <literal>attribute</literal> elements</title>

<para>The <literal>name</literal> attribute on an
<literal>element</literal> or <literal>attribute</literal> element is
transformed into a <literal>name</literal> child element.</para>

<para>If an <literal>attribute</literal> element has a
<literal>name</literal> attribute but no <literal>ns</literal>
attribute, then an <literal>ns=""</literal> attribute is added to the
<literal>name</literal> child element.</para>

</section>

<section>
<title><literal>ns</literal> attribute</title>

<para>For any <literal>name</literal>, <literal>nsName</literal> or
<literal>value</literal> element that does not have an
<literal>ns</literal> attribute, an <literal>ns</literal> attribute is
added. The value of the added <literal>ns</literal> attribute is the
value of the <literal>ns</literal> attribute of the nearest ancestor
element that has an <literal>ns</literal> attribute, or the empty
string if there is no such ancestor. Then, any <literal>ns</literal>
attribute that is on an element other than <literal>name</literal>,
<literal>nsName</literal> or <literal>value</literal> is
removed.</para>

<note><para>The value of the <literal>ns</literal> attribute is
<emphasis role="strong">not</emphasis> transformed either by escaping
disallowed characters, or in any other way, because the value of the
<literal>ns</literal> attribute is compared against namespace URIs in
the instance, which are not subject to any
transformation.</para></note>

<note><para>Since <literal>include</literal> and
<literal>externalRef</literal> elements are resolved after
<literal>datatypeLibrary</literal> attributes are added but before
<literal>ns</literal> attributes are added, <literal>ns</literal>
attributes are inherited into external schemas but
<literal>datatypeLibrary</literal> attributes are not.</para></note>

</section>

<section>
<title>QNames</title>

<para>For any <literal>name</literal> element containing a prefix, the
prefix is removed and an <literal>ns</literal> attribute is added
replacing any existing <literal>ns</literal> attribute. The value of
the added <literal>ns</literal> attribute is the value to which the
namespace map of the context of the <literal>name</literal> element
maps the prefix.  The context must have a mapping for the
prefix.</para>

</section>

<section>
<title><literal>div</literal> element</title>

<para>Each <literal>div</literal> element is replaced by its
children.</para>

</section>

<section id="number-child-elements">
<title>Number of child elements</title>

<para>A <literal>define</literal>, <literal>oneOrMore</literal>,
<literal>zeroOrMore</literal>, <literal>optional</literal>, <literal>list</literal> or
<literal>mixed</literal> element is transformed so that it has exactly
one child element.  If it has more than one child element, then its
child elements are wrapped in a <literal>group</literal>
element. Similarly, an <literal>element</literal> element is transformed so
that it has exactly two child elements, the first being a name class
and the second being a pattern. If it has more than two child elements,
then the child elements other than the first are wrapped in a
<literal>group</literal> element.</para>

<para>A <literal>except</literal> element is transformed
so that it has exactly one child element. If it has more
than one child element, then its child elements are wrapped
in a <literal>choice</literal> element.</para>

<para>If an <literal>attribute</literal> element has only one child
element (a name class), then a <literal>text</literal> element is
added.</para>

<para>A <literal>choice</literal>, <literal>group</literal> or
<literal>interleave</literal> element is transformed so that it has
exactly two child elements. If it has one child element, then it is
replaced by its child element.  If it has more than two child
elements, then the first two child elements are combined into a new
element with the same name as the parent element and with the first
two child elements as its children.  For example,</para>

<programlisting>&lt;choice&gt; <replaceable>p1</replaceable> <replaceable>p2</replaceable> <replaceable>p3</replaceable> &lt;/choice&gt;</programlisting>

<para>is transformed to</para>

<programlisting>&lt;choice&gt; &lt;choice&gt; <replaceable>p1</replaceable> <replaceable>p2</replaceable> &lt;/choice&gt; <replaceable>p3</replaceable> &lt;/choice&gt;</programlisting>

<para>This reduces the number of child elements by one. The
transformation is applied repeatedly until there are exactly two child
elements.</para>

</section>

<section>
<title><literal>mixed</literal> element</title>

<para>A <literal>mixed</literal> element is transformed into an
interleaving with a <literal>text</literal> element:</para>

<programlisting>&lt;mixed> <replaceable>p</replaceable> &lt;/mixed></programlisting>

<para>is transformed into</para>

<programlisting>&lt;interleave> <replaceable>p</replaceable> &lt;text/> &lt;/interleave></programlisting>

</section>

<section>
<title><literal>optional</literal> element</title>

<para>An <literal>optional</literal> element is transformed into
a choice with <literal>empty</literal>:</para>

<programlisting>&lt;optional> <replaceable>p</replaceable> &lt;/optional></programlisting>

<para>is transformed into</para>

<programlisting>&lt;choice> <replaceable>p</replaceable> &lt;empty/> &lt;/choice></programlisting>

</section>

<section>
<title><literal>zeroOrMore</literal> element</title>

<para>A <literal>zeroOrMore</literal> element is transformed into a choice
between <literal>oneOrMore</literal> and
<literal>empty</literal>:</para>

<programlisting>&lt;zeroOrMore> <replaceable>p</replaceable> &lt;/zeroOrMore></programlisting>

<para>is transformed into</para>

<programlisting>&lt;choice> &lt;oneOrMore> <replaceable>p</replaceable> &lt;/oneOrMore> &lt;empty/> &lt;/choice></programlisting>

</section>

<section id="constraints">
<title>Constraints</title>

<para>In this rule, no transformation is performed, but various
constraints are checked.</para>

<note><para>The constraints in this section, unlike the constraints
specified in <xref linkend="restriction"/>, can be checked without
resolving any <literal>ref</literal> elements, and are accordingly
applied even to patterns that will disappear during labc_2">
<!ATTLIST docification because they are not reachable (see <xref
linkend="define-ref"/>) or because of <literal>notAllowed</literal>
(see <xref linkend="notAllowed"/>).</para></note>

<para>An <literal>except</literal> element that is a child of an
<literal>anyName</literal> element must not have any
<literal>anyName</literal> descendant elements. An
<literal>except</literal> element that is a child of an
<literal>nsName</literal> element must not have any
<literal>nsName</literal> or <literal>anyName</literal> descendant
elements.</para>

<para>A <literal>name</literal> element that occurs as the first child
of an <literal>attribute</literal> element or as the descendant of the
first child of an <literal>attribute</literal> element and that has an
<literal>ns</literal> attribute with value equal to the empty string
must not have content equal to <literal>xmlns</literal>.</para>

<para>A <literal>name</literal> or <literal>nsName</literal> element
that occurs as the first child of an <literal>attribute</literal>
element or as the descendant of the first child of an
<literal>attribute</literal> element must not have an
<literal>ns</literal> attribute with value
<literal>http://www.w3.org/2000/xmlns</literal>.</para>

<note><para>The <xref linkend="infoset"/> defines the namespace URI of
namespace declaration attributes to be
<literal>http://www.w3.org/2000/xmlns</literal>.</para></note>

<para>A <literal>data</literal> or <literal>value</literal> element
must be correct in its use of datatypes. Specifically, the
<literal>type</literal> attribute must identify a datatype within the
datatype library identified by the value of the
<literal>datatypeLibrary</literal> attribute.  For a
<literal>data</literal> element, the parameter list must be one that
is allowed by the datatype (see <xref
linkend="data-pattern"/>).</para>

</section>

<section>
<title><literal>combine</literal> attribute</title>

<para>For each <literal>grammar</literal> element, all
<literal>define</literal> elements with the same name are combined
together.  For any name, there must not be more than one
<literal>define</literal> element with that name that does not have a
<literal>combine</literal> attribute.  For any name, if there is a
<literal>define</literal> element with that name that has a
<literal>combine</literal> attribute with the value
<literal>choice</literal>, then there must not also be a
<literal>define</literal> element with that name that has a
<literal>combine</literal> attribute with the value
<literal>interleave</literal>. Thus, for any name, if there is more
than onH <literal>define</literal> element with that name, then there
is a unique value for the <literal>combine</literal> attribute for
that name.  After determining this unique value, the
<literal>combine</literal> attributes are removed.  A pair of
definitions</para>

<programlisting>&lt;define name="<replaceable>n</replaceable>"&gt;
  <replaceable>p1</replaceable>
&lt;/define>
&lt;define name="<replaceable>n</replaceable>"&gt;
  <replaceable>p2</replaceable>
&lt;/define></programlisting>

<para>is combined into</para>

<programlisting>&lt;define name="<replaceable>n</replaceable>">
  &lt;<replaceable>c</replaceable>&gt;
    <replaceable>p1</replaceable>
    <replaceable>p2</replaceable>
  &lt;/<replaceable>c</replaceable>&gt;
&lt;/define></programlisting>

<para>where <replaceable>c</replaceable> is the value of the
<literal>combine</literal> attribute. Pairs of definitions are
combined until there is exactly one <literal>define</literal> element
for each name.</para>

<para>Similarly, for each <literal>grammar</literal> element all
<literal>start</literal> elements are combined together.  There must
not be more than one <literal>start</literal> element that does not
have a <literal>combine</literal> attribute.  If there is a
<literal>start</literal> element that has a <literal>combine</literal>
attribute with the value <literal>choice</literal>, there must not
also be a <literal>start</literal> element that has a
<literal>combine</literal> attribute with the vhlue
<literal>interleave</literal>.</para>

</section>

<section>
<title><literal>grammar</literal> element</title>

<para>In this rule, the schema is transformed so that its top-level
element is <literal>grammar</literal> and so that it has no other
<literal>grammar</literal> elements.</para>

<para>Define the <firstterm>in-scope grammar</firstterm> for an
element to be the nearest ancestor <literal>grammar</literal> element.  A
<literal>ref</literal> element <firstterm>refers to</firstine</literal> element if the value of their
<literal>name</literal> attributes is the same and their in-scope
grammars are the same.  A <literal>parentRef</literal> element
<firstterm>refers to</firstterm> a <literal>define</literal> element
if the value of their <literal>name</literal> attributes is the same
and the in-scope grammar of the in-scope grammar of the
<literal>parentRef</literal> element is the same as the in-scope
grammar of the <literal>define</literal> element. Every
<literal>ref</literal> or <literal>parentRef</literal> element must
refer to a <literal>define</literal> element.  A
<literal>grammar</literal> must have a <literal>start</literal> child
element.</para>

<para>First, transform the top-level pattern
<replaceable>p</replaceable> into
<literal>&lt;grammar>&lt;start><replaceable>p</replaceable>&lt;/start>&lt;/grammar></literal>.
Next, rename <literal>define</literal> elements so that no two
<literal>define</literal> elements anywhere in the schema have the
same name.  To rename a <literal>define</literal> element, change the
value of its <literal>name</literal> attribute and change the value of
the <literal>name</literal> attribute of all <literal>ref</literal>
and <literal>parentRef</literal> elements that refer to that
<literal>define</literal> element. Next, move all
<literal>define</literal> elements to be children of the top-level
<literal>grammar</literal> element, replace each nested
<literal>grammar</literal> element by the child of its
<literal>start</literal> element and rename each
<literal>parentRef</literal> element to <literal>ref</literal>.</para>

</section>


<section id="define-ref">
<title><literal>define</literal> and <literal>ref</literal> elements</title>

<para>In this rule, the grammar is transformed so that every
<literal>element</literal> element is the child of a
<literal>define</literal> element, and the child of every
<literal>define</literal> element is an <literal>element</literal>
element.</para>

<para>First, remove any <literal>define</literal> element that is not
<firstterm>reachable</firstterm>.  A <literal>define</literal> element
is reachable if there is reachable <literal>ref</literal> element
referring to it.  A <literal>ref</literal> element is reachable if it
is the descendant of the <literal>start</literal> element or of a
reachable <literal>define</literal> element. Now, for
each <literal>element</literal> element that is not the child of a
<literal>define</literal> element, add a <literal>define</literal>
element to the <literal>grammar</literal> element, and replace the
<literal>element</literal> element by a <literal>ref</literal> element
referring to the added <literal>define</literal> element. The value of
the <literal>name</literal> attribute of the added
<literal>define</literal> element must be different from value of the
<literal>name</literal> attribute of all other
<literal>define</literal> elements. The child of the added
<literal>define</literal> element is the <literal>element</literal>
element.</para>

<para>Define a <literal>ref</literal> element to be
<firstterm>expandable</firstterm> if it refers to a
<literal>define</literal> element whose child is not an
<literal>element</literal> element.  For each <literal>ref</literal>
element that is expandable and is a descendant of a
<literal>start</literal> element or an <literal>element</literal>
element, expand it by replacing the <literal>ref</literal> element by
the child of the <literal>define</literal> element to which it refers and
then recursively expanding any expandable <literal>ref</literal>
elements in this replacement.  This must not result in a loop.
In other words expanding the replacement of a
<literal>ref</literal> element having a <literal>name</literal> with
value <replaceable>n</replaceable> must not require the expansion of
<literal>ref</literal> element also having a <literal>name</literal>
with value <replaceable>n</replaceable>.  Finally, remove any
<literal>define</literal> element whose child is not an
<literal>element</literal> element.</para>

</section>

<section id="notAllowed">
<title><literal>notAllowed</literal> element</title>

<para>In this rule, the grammar is transformed so that a
<literal>notAllowed</literal> element occurs only as the child of
a <literal>start</literal> or <literal>element</literal> element.  An
<literal>attribute</literal>, <literal>list</literal>,
<literal>group</literal>, <literal>interleave</literal1,
or <literal>oneOrMore</literal> element that has a
<literal>notAllowed</literal> child element is transformed into a
<literal>notAllowed</literal> element.  A <literal>choice</literal>
element that has two <literal>notAllowed</literal> child elements is
transformed into a <literal>notAllowed</literal> element.  A
<literal>choice</literal> element that has one
<literal>notAllowed</literal> child element is transformed into its
other child element. An <literal>except</literal> element that has a
<literal>notAllowed</literal> child element is removed.
The preceding transformations are applied
repeatedly until none of them is applicable any more.
Any <literal>define</literal> element that is no longer reachable
is removed.</para>

</section>

<section>
<title><literal>empty</literal> element</itle>

<para>In this rule, the grammar is transformed so that an
<literal>empty</literal> element does not occur as a child of a
<literal>group</literal>, <literal>interleave</literal>, or
<literal>oneOrMore</literal> element or as the second child of
a <literal>choice</literal> element. A <literal>group</literal>,
<literal>interleave</literal> or <literal>choice</literal> element
that has two <literal>empty</literal> child elements is transformed
into an <literal>empty</literal> element.  A <literal>group</literal>
or <literal>interleave</literal> element that has one
<literal>empty</literal> child element is transformed into its other
child element.  A <literal>choice</literal> element whose
second child element is an <literal>empty</literal> element is
transformed by interchanging its two child elements.  A
<literal>oneOrMore</literal> element that has an
<literal>empty</literal> child element is transformed into an
<literal>empty</literal> element. The preceding transformations are applied
repeatedly until none of them is applicable any more.</para>

</section>

</section>

<section id="simple-syntax">
<title>Simple syntax</title>

<para>After applying all the rules in <xref
linkend="simplification"/>, the schema will match the following
grammar:</para>

<grammarref src="simple.rng"/>

<para>With this grammar, no elements or attributes are allowed other
than those explicitly shown.</para>

<section id="simple-syntax-example">
<title>Example</title>

<para>The following is an example of how the schema in <xref
linkend="full-syntax-example"/> can be transformed into the simple
syntax:</para>

<programlisting><![CDATA[<?xml version="1.0"?>
<grammar xmlns="http://relaxng.org/ns/structure/1.0">
  <start>
    <ref name="foo.element"/>
  </start>

  <define name="foo.element">
    <element>
      <name ns="">foo</name>
      <group>
        <ref name="bar1.element"/>
        <ref name="bar2.element"/>
      </group>
    </element>
  </define>

  <define name="bar1.element">
    <element>
      <name ns="http://www.example.com/n1">bar1</name>
      <empty/>
    </element>
  </define>

  <define name="bar2.element">
    <element>
      <name ns="http://www.example.com/n2">bar2</name>
      <empty/>
    </element>
  </define>
</grammar>]]></programlisting>

<note><para>Strictly speaking, the result of simplification is an
instance of the data model rather than an XML document.  For
convenience, we use an XML document to represent an instance of the
data model.</para></note>

</section>

</section>

<section id="semantics">
<title>Semantics</title>

<para>In this section, we define the semantics of a correct RELAX NG
schema that has been transformed into the simple syntax.  The
semantics of a RELAX NG schema consist of a specification of what XML
documents are valid with respect to that schema.  The semantics are
described formally.  The formalism uses axioms and inference rules.
Axioms are propositions that are provable unconditionally.  An
inference rule consists of one or more antecedents and exactly one
consequent.  An antecedent is either positive or negative.  If all the
positive antecedents of an inference rule are provable and none of the
negative antecedents are provable, then the consequent of the
inference rule is provable. An XML document is valid with respect to a
RELAX NG schema if and only if the proposition that it is valid is
provable in the formalism specified in this section.</para>

<note><para>This kind of formalism is similar to a proof system.
However, a traditional proof system only has positive
antecedents.</para></note>

<para>The notation for inference rules separates the antecedents from
the consequent by a horizontal line: the antecedents are above the
line; the consequent is below the line.  If an antecedent is of the
form not(<replaceable>p</replaceable>), then it is a negative
antecedent; otherwise, it is a positive antecedent.  Both axioms and
inferences
rules may use variables.  A variable has a name and optionally a
subscript.  The name of a variable is italicized.  Each variable has a
range that is determined by its name.  Axioms and inference rules are
implicitly universally quantified over the variables they contain.  We
explain this further below.</para>

<para>The possibility that an inference rule or axiom may contain more
than one occurrence of a particular variable reqion be defined on each kind of object over which a variable can
range.  The identity relation for all kinds of object is value-based.
Two objects of a particular kind are identical if the constituents of
the objects are identical.  For example, two attributes are considered
the same if they have the same name and the same value. Two characters
are identical if their Unicode character codes are the same.</para>

<section id="name-classes">
<title>Name classes</title>

<para>The main semantic concept for name classes is that of a name
belonging to a name class. A name class is an element that matches the
production nameClass. A name is as defined in <xref
linkend="data-model"/>: it consists of a namespace URI and a local
name.</para>

<para>We use the following notation:</para>

<variablelist>

<varlistentry><term><p:var range="name"/></term><listitem><para>is a variable
that ranges over names</para></listitem></varlistentry>

<varlistentry><term><p:var range="nameClass"/></term><listitem><para>ranges over name classes</para></listitem></varlistentry>

<varlistentry><term><p:judgement name="belongs">
      <p:var range="name"/>
      <p:var range="nameClass"/>
    </p:judgement></term><listitem><para>
    
asserts that name <p:var range="name"/> is a member of name class <p:var range="nameClass"/>

</para></listitem></varlistentry>

</variablelist>

<para>We are now ready for our first axiom, which is called "anyName
1":</para>

<p:proofSystem>
  <p:rule name="anyName 1">
    <p:judgement name="belongs">
      <p:var range="name"/>
      <p:element name="anyName"/>
    </p:judgement>
  </p:rule>
</p:proofSystem>

<para>This says for any name <p:var range="name"/>, <p:var
range="name"/> belongs to the name class <p:element name="anyName"/>,
in other words <p:element name="anyName"/> matches any name. Note the
effect of the implicit universal quantification over the variables in
the axiom: this is what makes the axiom apply for any name <p:var
range="name"/>.</para>

<para>Our first inference rule is almost as simple:</para>

<p:proofSystem>
  <p:rule name="anyName 2">
    <p:not>
      <p:judgement name="belongs">
	<p:var range="name"/>
	<p:var range="nameClass"/>
      </p:judgement>
    </p:not>
    <p:judgement name="belongs">
      <p:var range="name"/>
      <p:element name="anyName">
        <p:element name="except">
  	  <p:var range="nameClass"/>
        </p:element>
      </p:element>
    </p:judgement>
  </p:rule>

</p:proofSystem>

<para>This says that for any name <p:var range="name"/>
and for any name class 	<p:var range="nameClass"/>,
if <p:var range="name"/> does not belong to <p:var range="nameClass"/>,
then <p:var range="name"/> belongs to 
      <p:element name="anyName">
        <p:element name="except">
  	  <p:var range="nameClass"/>
        </p:element>
      </p:element>. In other words,       <p:element name="anyName">
        <p:element name="except">
  	  <p:var range="nameClass"/>
        </p:element>
      </p:element> matches any name that does not match <p:var range="nRmeClass"/>.</para>

<para>We now need the following additional notation:</para>

<variablelist>

<varlistentry><term><p:var range="ncname"/></term>

<listitem><para>ranges over local names; a local name is a string that
matches the NCName production of <xref linkend="xml-names"/>, that is,
a name with no colons</para></listitem>
</varlistentry>

<varlistentry><term><p:var range="uri"/></term><listitem><para>ranges over URIs</para></listitem></varlistentry>

<varlistentry>
<term>
  <p:function name="name">
    <p:var range="uri"/>
    <p:var range="ncname"/>
  </p:function>
</term>
<listitem><para>constructs a na‹e with URI <p:var range="uri"/> and local
name <p:var range="ncname"/></para></listitem>
</varlistentry>

</variablelist>

<para>The remaining axioms and inference rules for name classes are as
follows:</para>

<p:proofSystem>

  <p:rule name="nsName 1">
    <p:judgement name="belongs">
      <p:function name="name">
        <p:var range="uri"/>
        <p:var range="ncname"/>
      </p:function>
      <p:element name="nsName">
        <p:attribute name="ns">
          <p:var range="uri"/>
        </p:attribute>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="nsName 2">
    <p:not>
      <p:judgement name="belongs">
	<p:function name="name">
	  <p:var range="uri"/>
	  <p:var range="ncname"/>
	</p:function>
	<p:var range="nameClass"/>
      </p:judgement>
    </p:not>
    <p:judgement name="belongs">
      <p:function name="name">
        <p:var range="uri"/>
        <p:var range="ncname"/>
      </p:function>
      <p:element name="nsName">
        <p:attribute name="ns">
          <p:var range="uri"/>
        </p:attribute>
        <p:element name="except">
          <p:var range="nameClass"/>
        </p:element>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="name">
    <p:judgement name="belongs">
      <p:function name="name">
        <p:var range="uri"/>
        <p:var range="ncname"/>
      </p:function>
      <p:element name="name">
        <p:attribute name="ns">
          <p:var range="uri"/>
        </p:attribute>
        <p:var range="ncname"/>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="name choice 1">
    <p:judgement name="belongs">
      <p:var range="name"/>
      <p:var range="nameClass" sub="1"/>
    </p:judgement>
    <p:judgement name="belongs">
      <p:var range="name"/>
      <p:element name="choice">
        <p:var range="nameClass" sub="1"/>
        <p:var range="nameClass" sub="2"/>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="name choice 2">
    <p:judgement name="belongs">
      <p:var range="name"/>
      <p:var range="nameClass" sub="2"/>
    </p:judgement>
    <p:judgement name="belongs">
      <p:var range="name"/>
      <p:element name="choice">
        <p:var range="nameClass" sub="1"/>
        <p:var range="nameClass" sub="2"/>
       p:element>
    </p:judgement>
  </p:rule>

</p:proofSystem>

</section>


<section>
<title>Patterns</title>

<para>The axioms and inference rules for patterns use the following
notation:</para>

<variablelist>

<varlistentry><term><p:var range="context"/></term><listitem><para>ranges
over contexts (as defined in <xref
linkend="data-model"/>)</para></listitem></varlistentry>

<varlistentry><term><p:var range="att"/></term><listitem><para>ranges over
sets of attributes; a set with a single member
is considered the same as that member</para></listitem></varlistentry>

<varlistentry><term><p:var
range="mixed"/></term><listitem><para>ranges over sequences of
elements and strings; a sequence with a single member is considered
the same as that member; the sequences ranged over by <p:var
range="mixed"/> may contain consecutive strings and may contain strings
that are empty; thus, there are sequences ranged over by <p:var
range="mixed"/> that cannot occur as the children of an
element</para></listitem></varlistentry>

<varlistentry><term><p:var range="pattern"/></term><listitem><para>ranges
over patterns (elements matching the pattern
production)</para></listitem></varlistentry>

<varlistentry><term><p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:var range="pattern"/>
    </p:judgement></term><listitem><para>
    
asserts that with respect to context <p:var range="context"/>, the
attributes <p:var range="att"/> and the sequence of elements and
strings <p:var range="mixed"/> matcheso thapattern <p:var
range="pattern"/></para></listitem></varlistentry>

</variablelist>

<section id="choice-pattern">
<title><literal>choice</literal> pattern</title>

<para>The semantics of the <literal>choice</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="choice 1">

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:var range="pattern" sub="1"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:element name="choice">
	<p:var range="pattern" sub="1"/>
	<p:var range="pattern" sub="2"/>
      </p:element>
    </p:judgement>

  </p:rule>

  <p:rule name="choice 2">

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:var range="pattern" sub="2"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:element name="choice">
	<p:var range="pattern" sub="1"/>
	<p:var range="pattern" sub="2"/>
      </p:element>
    </p:judgement>

  </p:rule>


</p:proofSystem>

</section>

<section>
<title><literal>group</literal> pattern</title>

<para>We use the following additional notation:</para>

<variablelist>

<varlistentry><term><p:function name="append">
	<p:var range="mixed" sub="1"/>
	<p:var range="mixed" sub="2"/>
      </p:function></term><listitem>
<para>represents the concatenation of the sequences <p:var range="mixed" sub="1"/> and <p:var range="mixed" sub="2"/>

</para></listitem></varlistentry>

<varlistentry><term><p:function name="union">
	<p:var range="att" sub="1"/>
	<p:var range="att" sub="2"/>
      </p:function></term><listitem>
<para>represents the union of <p:var range="att" sub="1"/>
and <p:var range="att" sub="2"/></para>
</listitem>
</varlistentry>

</variablelist>

<para>The semantics of the <literal>group</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="group">

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="1"/>
      <p:var range="mixed" sub="1"/>
      <p:var range="pattern" sub="1"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="2"/>
      <p:var range="mixed" sub="2"/>
      <p:var range="pattern" sub="2"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="union">
	<p:var range="att" sub="1"/>
	<p:var range="att" sub="2"/>
      </p:function>
      <p:function name="append">
	<p:var range="mixed" sub="1"/>
	<p:var range="mixed" sub="2"/>
      </p:function>
      <p:element name="group">
	<p:var range="pattern" sub="1"/>
	<p:var range="pattern" sub="2"/>
      </p:element>
    </p:judgement>

  </p:rule>

</p:proofSystem>

<note><para>The restriction in <xref linkend="attribute-restrictions"/>
ensures that the set of attributes constructed in the consequent will
not have multiple attributes with the same name.</para></note>

</section>


<section id="empty-pattern">
<title><literal>empty</literal> pattern</title>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:function name="emptySequence"/></term><listitem><para>represents an empty sequence</para></listitem></varlistentry>

<varlistentry><term><p:function name="emptySet"/></term><listitem><para>represents an empty set</para></listitem></varlistentry>

</variablelist>

<para>The semantics of the <literal>empty</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="empty">
    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="emptySet"/>
    hs>prolog</lhs>
<rhs><nt d  <p:function name="emptySequence"/>
      <p:element name="empty"></p:element>
      <p:function name="emptySet"/>
      <p:function name="emptySet"/>
    </p:judgement>
  </p:rule>
</p:proofSystem>

</section>


<section id="text-pattern">
<title><literal>text</literal> pattern</title>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:var range="string"/></term><listitem><para>ranges
over strings</para></listitem></varlistentry>
</variablelist>

<para>The semantics of the <literal>text</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="text 1">
    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:function name="emptySequence"/>
      <p:element name="text"></p:element>
      <p:function name="emptySet"/>
      <p:function name="emptySet"/>
    </p:judgement>
  </p:rule>

  <p:rule name="text 2">
    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:var range="mixed"/>
      <p:element name="text"></p:element>
      <p:function name="emptySet"/>
      <p:function name="emptySet"/>
    </p:judgement>
    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:function name="append">
        <p:var range="mixed"/>
        <p:var range="string"/>
      </p:function>
      <p:element name="text"></p:element>
      <p:function name="emptySet"/>
      <p:function name="emptySet"/>
    </p:judgement>
  </p:rule>

</p:proofSystem>

<para>The effect of the above rule is that a <literal>text</literal>
element matches zero or more strings.</para>

</section>


<section>
<title><literal>oneOrMore</literal> pattern</title>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:judgement name="disjoint">
      <p:var range="att" sub="1"/>
      <p:var range="att" sub="2"/>
    </p:judgement></term><listitem><para>
asserts that there is no name that is
the name of both an attribute in <p:var range="att" sub="1"/>
and of an attribute in <p:var range="att" sub="2"/>
</para></listitem></varlistentry>
</variablelist>

<para>The semantics of the <literal>oneOrMore</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="oneOrMore 1">
    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:var range="pattern"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:element name="oneOrMore">
        <p:var range="pattern"/>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="oneOrMore 2">
    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="1"/>
      <p:var range="mixed" sub="1"/>
      <p:var range="pattern"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="2"/>
      <p:var range="mixed" sub="2"/>
      <p:element name="oneOrMore">
        <p:var range="pattern"/>
      </p:element>
    </p:judgement>

    <p:judgement name="disjoint">
      <p:var range="att" sub="1"/>
      <p:var range="att" sub="2"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="union">
	<p:var range="att" sub="1"/>
	<p:var range="att" sub="2"/>
      </p:function>
      <p:function name="append">
	<p:var range="mixed" sub="1"/>
	<p:var range="mixed" sub="2"/>
      </p:function>
      <p:element name="oneOrMore">
        <p:var range="pattern"/>
      </p:element>
    </p:judgement>
  </p:rule>

</p:proofSystem>

</section>


<section>
<title><literal>interleave</literal> pattern</title>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:judgement name="interleave">
      <p:var range="mixed" sub="1"/>
      <p:var range="mixed" sub="2"/>
      <p:var range="mixed" sub="3"/>
    </p:judgement></term><listitem><para>
    
asserts that <p:var range="mixed" sub="1"/>
is an interleaving of <p:var range="mixed" sub="2"/>
and <p:var range="mixed" sub="3"/>
</para></listitem></varlistentry>

</variablelist>

<para>The semantics of interleaving are defined by the following rules.</para>


<p:proofSystem>
  <p:rule name="interleaves 1">
   
    <p:judgement name="interleave">
      <p:function name="emptySequence"/>
      <p:function name="emptySequence"/>
      <p:function name="emptySequence"/>
    </p:judgement>

  </p:rule>

  <p:rule name="interleaves 2">
   
    <p:judgement name="interleave">
      <p:var range="mixed" sub="1"/>
      <p:var range="mixed" sub="2"/>
      <p:var range="mixed" sub="3"/>
    </p:judgement>

    <p:judgement name="interleave">
      <p:function name="append">
        <p:var range="mixed" sub="4"/>
        <p:var range="mixed" sub="1"/>
      </p:function>
      <p:function name="append">
        <p:var range="mixed" sub="4"/>
        <p:var range="mixed" sub="2"/>
      </p:function>
      <p:var range="mixed" sub="3"/>
    </p:judgement>

  </p:rule>

  <p:rule name="interleaves 3">
   
    <p:judgement name="interleave">
      <p:var range="mixed" sub="1"/>
      <p:var range="mixed" sub="2"/>
      <p:var range="mixed" sub="3"/>
    </p:judgement>

    <p:judgement name="interleave">
      <p:function name="append">
        <p:var range="mixed" sub="4"/>
        <p:var range="mixed" sub="1"/>
      </p:function>
      <p:var range="mixed" sub="2"/>
      <p:function name="append">
        <p:var range="mixed" sub="4"/>
        <p:var range="mixed" sub="3"/>
      </p:function>
    </p:judgement>

  </p:rule>

</p:proofSystem>

<para>For example, the interleavings of
<literal><![CDATA[<a/><a/>]]></literal> and
<literal><![CDATA[<b/>]]></literal> are
<literal><![CDATA[<a/><a/><b/>]]></literal>,
<literal><![CDATA[<a/><b/><a/>]]></literal>, and
<literal><![CDATA[<b/><a/><a/>]]></literal>.</para>

<para>The semantics of the <literal>interleave</literal> pattern are
as follows:</para>

<p:proofSystem>
  <p:rule name="interleave">

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="1"/>
      <p:var range="mixed" sub="1"/>
      <p:var range="pattern" sub="1"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="2"/>
      <p:var range="mixed" sub="2"/>
      <p:var range="pattern" sub="2"/>
    </p:judgement>

    <p:judgement name="interleave">
      <p:var range="mixed" sub="3"/>
      <p:var range="mixed" sub="1"/>
      <p:var range="mixed" sub="2"/>
    </p:judgement>


    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="union">
	<p:var range="att" sub="1"/>
	<p:var range="att" sub="2"/>
      </p:function>
      <p:var range="mixed" sub="3"/>
      <p:element name="interleave">
	<p:var range="pattern" sub="1"/>
	<p:var range="pattern" sub="2"/>
      </p:element>
    </p:judgement>

  </p:rule>

</p:proofSystem>

<note><para>The restriction in <xref linkend="attribute-restrictions"/>
ensures that the set of attributes constructed in the consequent will
not have multiple attributes with the same name.</para></note>

</section>

<section id="element-pattern">
<title><literal>element</literal> and <literal>attribute</literal> pattern</title>

<para>The value of an attribute is always a single string, which may
be empty.  Thus, the empty sequence is not a possible attribute value.
On the hand, the children of an element can be an empty sequence and
cannot consist of an empty string.  In order to ensure that validation
handles attributes and elements consistently, we introduce a variant
of matching called <firstterm>weak matching</firstterm>.  Weak
matching is used when matching the pattern for the value of an
attribute or for the attributes and children of an element.  We use
the following notation to define weak matching.</para>

<variablelist>

<varlistentry><term><p:function
name="emptyString"/></term><listitem><para>represents an empty
string</para></listitem></varlistentry>

<varlistentry><term><p:var
range="whiteSpace"/></term><listitem><para>ranges over the empty
sequence and strings that consist entirely of
whitespace</para></listitem></varlistentry>

<varlistentry><term><p:judgement name="weakMatch">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:var range="pattern"/>
    </p:judgement></term><listitem><para>
    
asserts that with respect to context <p:var range="context"/>, the
attributes <p:var range="att"/> and the sequence of elements and
strings <p:var range="mixed"/> weakly matches the pattern <p:var
range="pattern"/></para></listitem></varlistentry>

</variablelist>

<para>The semantics of weak matching are as follows:</para>

<p:proofSystem>
  <p:rule name="weak match 1">
    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:var range="pattern"/>
    </p:judgement>
    <p:judgement name="weakMatch">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:var range="pattern"/>
    </p:judgement>
  </p:rule>
  <p:rule name="weak match 2">
    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:function name="emptySequence"/>
      <p:var range="pattern"/>
    </p:judgement>
    <p:judgement name="weakMatch">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="whiteSpace"/>
      <p:var range="pattern"/>
    </p:judgement>
  </p:rule>
  <p:rule name="weak match 3">
    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:function name="emptyString"/>
      <p:var range="pattern"/>
    </p:judgement>
    <p:judgement name="weakMatch">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:function name="emptySequence"/>
      <p:var range="pattern"/>
    </p:judgement>
  </p:rule>
</p:proofSystem>

<para>We use the following additional notation:</para>

<variablelist>

<varlistentry><term><p:function name="attribute">
        <p:var range="name"/>
        <p:var range="string"/>
      </p:function></term><listitem><para>
      
constructs an attribute with name <p:var range="name"/>
and value <p:var range="string"/>
</para></listitem></varlistentry>

<varlistentry><term><p:function name="element">
	<p:var range="name"/>
        <p:var range="context"/>
	<p:var range="att"/>
	<p:var range="mixed"/>
      </p:function></term><listitem><para>
      
constructs an element with name <p:var range="name"/>,
context <p:var range="context"/>,
attributes <p:var range="att"/>
and mixed sequence <p:var range="mixed"/> as children
</para></listitem></varlistentry>

<varlistentry><term><p:judgement name="okAsChildren">
      <p:var range="mixed"/>
    </p:judgement></term><listitem><para>
    
asserts that the mixed sequence <p:var range="mixed"/> can occur as
the children of an element: it does not contain any member that is an
empty string, nor does it contain two consecutive members that are
both strings</para></listitem></varlistentry>

<varlistentry><term><p:judgement name="bind">
      <p:var range="ncname"/>
      <p:var range="nameClass"/>
      <p:var range="pattern"/>
    </p:judgement></term><listitem><para>
    
asserts that the grammar contains
<p:element name="define">
  <p:attribute name="name">
    <p:var range="ncname"/>
  </p:attribute>
  <p:element name="element">
     <p:var range="nameClass"/>
     <p:var range="pattern"/>
  </p:element>
</p:element>
</para></listitem></varlistentry>

</variablelist>

<para>The semantics of the <literal>attribute</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="attribute">

    <p:judgement name="weakMatch">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:var range="string"/>
      <p:var range="pattern"/>
    </p:judgement>

    <p:judgement name="belongs">
      <p:var range="name"/>
      <p:var range="nameClass"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="attribute">
        <p:var range="name"/>
        <p:var range="string"/>
      </p:function>
      <p:function name="emptySequence"/>
      <p:element name="attribute">
        <p:var range="nameClass"/>
	<p:var range="pattern"/>
      </p:element>
    </p:judgement>

  </p:rule>

</p:proofSystem>

<para>The semantics of the <literal>element</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="element">

    <p:judgement name="weakMatch">
      <p:var range="context" sub="1"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:var range="pattern"/>
    </p:judgement>

    <p:judgement name="belongs">
      <p:var range="name"/>
      <p:var range="nameClass"/>
    </p:judgement>

    <p:judgement name="okAsChildren">
      <p:var range="mixed"/>
    </p:judgement>

    <p:judgement name="bind">
      <p:var range="ncname"/>
      <p:var range="nameClass"/>
      <p:var range="pattern"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context" sub="2"/>
      <p:function name="emptySet"/>
      <p:function name="append">
        <p:var range="whiteSpace" sub="1"/>
	<p:function name="element">
	  <p:var range="name"/>
	  <p:var range="context" sub="1"/>
	  <p:var range="att"/>
	  <p:var range="mixed"/>
	</p:function>
        <p:var range="whiteSpace" sub="2"/>
      </p:function>
      <p:element name="ref">
        <p:attribute name="name">
          <p:var range="ncname"/>
        </p:attribute>
      </p:element>
    </p:judgement>

  </p:rule>

</p:proofSystem>


</section>

<section id="data-pattern">
<title><literal>data</literal> and <literal>value</literal> pattern</title>

<para>RELAX NG relies on datatype libraries to perform datatyping.
A datatype library is identified by a URI.  A datatype within a
datatype library is identified by an NCName.  A datatype library
provides two services.</para>

<itemizedlist>

<listitem><para>It can determine whether a string is a legal
representation of a datatype. This service accepts a list of zero or
more parameters. For example, a string datatype might have a parameter
specifying the length of a string.  The datatype library determines
what parameters are applicable for each datatype.</para></listitem>

<listitem><para>It can determine whether two strings represent the
same value of a datatype.  This service does not have any
parameters.</para></listitem>

</itemizedlist>

<para>Both services may make use of the context of a string.  For
example, a datatype representing a QName would use the namespace
map.</para>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:judgement name="datatypeAllows">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="params"/>
      <p:var range="string"/>
      <p:var range="context"/>
    </p:judgement></term><listitem><para>
    
asserts that in the datatype library identified by URI <p:var range="uri"/>, the string <p:var range="string"/> interpreted with
context <p:var range="context"/> is a legal
value of datatype <p:var range="ncname"/> with parameters <p:var range="params"/></para></listitem></varlistentry>

<varlistentry><term><p:judgement name="datatypeEqual">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="string" sub="1"/>
      <p:var range="context" sub="1"/>
      <p:var range="string" sub="2"/>
      <p:var range="context" sub="2"/>
    </p:judgement></term><listitem><para>
    
asserts that in the datatype library identified by URI <p:var range="uri"/>, string <p:var range="string" sub="1"/> interpreted with
context <p:var range="context" sub="1"/> represents the same value of
the datatype <p:var range="ncname"/> as the string <p:var range="string" sub="2"/> interpreted in the context of <p:var range="context" sub="2"/>
</para></listitem></varlistentry>

<varlistentry><term><p:var range="params"/></term><listitem><para>ranges over sequences of parameters</para></listitem></varlistentry>

<varlistentry><term><p:context>
     <p:var range="context"/>
   </p:context></term><listitem><para>
   
within the start-tag of a pattern refers to the context
of the pattern element
</para></listitem></varlistentry>

<varlistentry>
<term>
  <p:function name="context">
     <p:var range="uri"/>
     <p:var range="context"/>
  </p:function>
</term>
<listitem><para>constructs a context which is the same as <p:var range="context"/>
except that the default namespace is <p:var range="uri"/>; if <p:var
range="uri"/> is the empty string, then there is no default namespace
in the constructed context</para></listitem></varlistentry>

</variablelist>

<para>The datatypeEqual function must be reflexive, transitive
and symmetric, that is, the following inference rules must hold:</para>

<p:proofSystem>
  <p:rule name="datatypeEqual reflexive">
    <p:judgement name="datatypeAllows">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="params"/>
      <p:var range="string"/>
      <p:var range="context"/>
    </p:judgement>
    <p:judgement name="datatypeEqual">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="string"/>
      <p:var range="context"/>
      <p:var range="string"/>
      <p:var range="context"/>
    </p:judgement>
  </p:rule>
  <p:rule name="datatypeEqual transitive">
    <p:judgement name="datatypeEqual">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="string" sub="1"/>
      <p:var range="context" sub="1"/>
      <p:var range="string" sub="2"/>
      <p:var range="context" sub="2"/>
    </p: