<UTISO LATE]>[\i
<?xmU version<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article [
<!-- ELEMENT declarations work around MSXML bug. -->
<!ELEMENT section ANY>
<!ATTLIST section id ID #IMPLIED>
<!ELEMENT appendix ANY>
<!ATTLIST appendix id ID #IMPLIED>
<!ELEMENT bibliomixed ANY>
<!ATTLIST bibliomixed id ID #IMPLIED>
]>
<article status="Committee Specification" xmlns:p="http://relaxng.org/ns/proofsystem">

<articleinfo>
<releaseinfo>$Id: spec.xml,v 1.159 2001/12/02 12:12:12 jjc Exp $</releaseinfo>
<title>RELAX NG Specification</title>
<authorgroup>
<editor>
  <firstname>James</firstname><surname>Clark</surname>
  <affiliation>
    <address><email>jjc@jclark.com</email></address>
  </affiliation>
</editor>
<editor>
  <surname>MURATA</surname><firstname>Makoto</firstname>
  <affiliation>
    <address><email>EB2M-MRT@asahi-net.or.jp</email></address>
  </affiliation>
</editor>
</authorgroup>
<pubdate>3 December 2001</pubdate>
<releaseinfo role="meta">
$Id: spec.xml,v 1.159 2001/12/02 12:12:12 jjc Exp $
</releaseinfo>

<copyright><year>2001</year><holder>OASIS</holder></copyright>

<legalnotice>

<para>Copyright &#169; The Organization for the Advancement of
Structured Information Standards [OASIS] 2001. All Rights
Reserved.</para>

<para>This document and translations of it may be copied and furnished
to others, and derivative works that comment on or otherwise explain
it or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to OASIS, except as needed for the
purpose of developing OASIS specifications, in which case the
procedures for copyrights defined in the OASIS Intellectual Property
Rights document must be followed, or as required to translate it into
languages other than English.</para>

<para>The limited permissions granted above are perpetual and will not
be revoked by OASIS or its successors or assigns.</para>

<para>This document and the information contained herein is provided
on an <quote>AS IS</quote> basis and OASIS DISCLAIMS ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE
USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</para>

</legalnotice>

<legalnotice role="status"><title>Status of this Document</title>

<para>This Committee Specification was approved for publication by the
OASIS RELAX NG technical committee. It is a stable document which
represents the consensus of the committee. Comments on this document
may be sent to <ulink
url="mailto:relax-ng-comment@lists.oasis-open.org"
>relax-ng-comment@lists.oasis-open.org</ulink>.</para>

<para>A list of known errors in this document is available at <ulink
url="http://www.oasis-open.org/committees/relax-ng/spec-20011203-errata.html"
>http://www.oasis-open.org/committees/relax-ng/spec-20011203-errata.html</ulink
>.</para>

</legalnotice>

<abstract>
<para>This is the definitive specification of RELAX NG, a simple
schema language for XML, based on <xref linkend="relax"/> and <xref
linkend="trex"/>. A RELAX NG schema specifies a pattern for the
structure and content of an XML document. A RELAX NG schema is itself
an XML document.</para>
</abstract>

<revhistory>
<revision>
  <revnumber>Committee Specification</revnumber>
  <date>3 December 2001</date>
</revision>
<revision>
  <revnumber>Committee Specification</revnumber>
  <date>11 August 2001</date>
</revision>
</revhistory>
</articleinfo>


<section>
<title>Introduction</title>

<para>This document specifies</para>

<itemizedlist>

<listi</X><para>when an XML document is a correct RELAX NG
schema</para></listitem>

<listitem><para>when an XML document m.  The
children of an element are constructed from the list of child
information items first by removing information items other than
element information items and character information items, and then by
constructing an element for each element information item in the list
and a string for each maximal sequence of character information items.
An attribute is constructed from an attribute information item by
constructing the name from the [namespace name] and [local name], and
the value from the [namespace name] property is not present, then the name is
constructed from an empty string and the [local name]. A string is
coch has</para>

<itemizedlist>
<listitem><para><literal>http://www.example.com/doc.xml</literal> as the base
URI</para></list> to the
namespace URI
<literal>http://www.w3.org/XML/1998/namespace</literal>
(the <literal>xml</literal> prefix is implicitly declared
by every XML document)</para></listitem>

<listitem><para>specifies the empty string as the default namespace
URI</para></listitem>

</itemizedlist>

</listitem>

</itemizedlist>

</listitem>

<listitem><para>an empty set of attri<listitem><para>a name which has</para>
<itemizedlist>

<listitem><para><literal>http://www.example.com/n1</literal> as the
t>

</listitem>

<listitem><para>a context which has</para>

<itemizedlist>
<listitem><para><literal>http://www.example.com/doc.xml</literal> as the base
URI</para></listitem>

<listitem><para>a namespace map which</para>

<itemizedlist>

<li  </element>
  <element name="ex2:bar2">
    <empty/>
  </element>
</element>]]></programlisting>

</section>

</section, each child that is a string containing only
whitespace characters is removed.</para>

<para>Leading and trailing whitespace characters are removed from the
value of each <literal>name</literal>, <literal>type</literal> and
<literal>combine</literal> attribute and from the content of each
<literal>name</literal> element.</para>

</section>

<section>
<title><literal>datatypeLibrary</literal> attribute</title>

<para>The value of each <literal>datatypeLibary</literal> attribute is
transformed by escaping disallowed characters as specified in Section
5.4 of <xref linkend="xlink"/>.</para>

<para>For any <literal>data</literal> or <literal>value</literal>
element that does not have a <literal>datatypeLibrary</literal>
attribute, a <literal>dinkend="rfc3023"/>) and an element constructed from the result
of the parse as specified in <xref linkend="data-model"/>.  In
particular, the <literal>charset</literal> parameter must be handled
as specified by the RFC. This specification does not define the
handling of media types other than <literal>application/xml</literal>
and <literal>text/xml</literal>. The <literal>href</literal> attribute
must not include a fragment identifier unless the registration of the
media type of the resource identifi="rfc3023"/> does not define the
interpretation of fragment identifiers for
<literal>application/xml</literal> or
<literal>te
element is then replaced by the referenced element.</para>

</section>

<section>
<title><literal>include</literal> element</title>

<para>An <literal>include</literal> element is transformed as follows.
An element is constructed using the URI re <literal>grammar</literal>
element, matching the syntax for grammar.</para>

<para>This <literal>grammar</literal> element ierencing of an <literal>include</literal>
attribute with an <literal>href</literal> attribute with the same
value.</para>

<para>Define the <firstterm>components</firstterm> of an element to
be the children of the element together with the components of any
<literal>div</literal> child elements.  If the
<literal>include</literal> element has a <literal>start</literal>
compoibute, an <literal>ns</literal> attribute is
added. The value of the added <literal>ns</literal> attribute is the
value of the <literal>ns</literal> attribute of the nearest ancestor
element that has an <literal>ns</literal> attribute, or the empty
string if there is no such ancestor. Then, any <literal>ns</literal>
attribute that is on an element other than <literal>name</litttributes are added, <literal>ns</literal>
attributes are inherited into external schemas but
<literal>datatypeLibrary</literaeral>ns</literal> attribute. The value of
the added <literal>ns</literal> attribute is the value to which the
namespace map of the context of the <literal>name</literal> element
maps the prefix.  The context must have a mapping for the
prefix.</para>
ement</literal> element is transformed so
that it has exactly two child elements, the first being a name class
and the second being a pattern. If it has more than two child elements,
then the child elements other than the first are wrapped in a
<literasame name as the parent element and with the first
two child elements as its children.  For example,</para>

<programlisting>&lt;choice&gt; <replaceable>p1</replaceable> <replaceable>p2</replaceable> <replaceable>p3</replaceable> &lt;/choice&gt;</prograaceable>p2</replaceable> &lt;/choice&gt; <replaceable>p3</replaceable> &lt;/choice&gt;</programlisting>

<para>This reduces the number of child elements by one. The
transformation is applied repeatedly until there are exactly two child
elements.</para>

</section>

<section>
<title><literal>mixed</literal> element</title>

<para>A <literal>mixed</literal> element is traneplaceable> &lt;/zeroOrMore></programlisting>

<para>is transformed into</para>

<programlisting>&lt;choice> &lt;oneOrMore> <replaceable>p</replaceable> &lt;/oneOrMore> &lt;empty/> &lt;/choice></programlisting>

</section>

<section id="constraintsa>

<note><para>The constraints in this section, unlike the constraints
specified in <xref linkend="restriction"/>, can be ch.w3.org/2000/xmlns</literal>.</para></note>

<para>A <literal>data</literal> or <literal>value</literal> element
must be correct in its use of datatypes. Specifically, the
<literal>type</literal> attribute must identify a datatype within the
datatype he parameter list must be one that
is allowed by the datatype (see <xref
linkend="data-pattern"/>).</para>

</section>

<s
<literal>define</literal> element with that name that has a
<literal>combine</literal> attribute with the value
<literal>choiteral> element with that name, then there
is a unique value for the <literal>combine</literal> attribute for
that name.  Aftereplaceable>n</replaceable>"&gt;
  <replaceable>p2</replaceable>
&lt;/define></programlisting>

<para>is combined into</para>

<programlisting>&lt;define name="<replaceable>n</replaceable>">
  &lt;<replaceable>c</replaceable>&gt;
    <replaceable>p1ammar</literal> element all
<literal>start</literal> elements are combined together.  There must
not be more than one <literal>start</literal> element that does not
have a <literal>combine</literal> attribute.  If there is a
<literal>start</literal> element that has a <literal>combine</literal>
attribute with the value <literal>choice</literal>, there must not
also be a <ffffa>

</section>

<section>
<title><literal>grammar</literal> element</title>

<para>In this rule, the schema is transforme
refer to a <literal>define</literal> element.  A
<literal>grammar</literal> must have a <literal>start</literal> child
element.</para>

<para>First, transform the top-level pattern
<replaceable>p</replaceable> into
<literal>&lt;grammar>&lt;start><rliteral>ref</literal>
and <literal>parentRef</literal> elements that refer to that
<literal>define</literal> element. Next, moted
<literal>grammar</literal> element by the child of its
<literal>start</literal> element and rename each
<literal>parentRe
<firstterm>reachable</firstterm>.  A <literal>define</literal> element
is reachable if there is reachable <literal>ref</literal> element
referring to it.  A <literal>ref</literal> element is reachable if it
is the descendant of the <literal>start</literal> element or of a
reachable <literal>define</literal> element. Now, for
each <literal>element</literal> element that is not the child of a
<literal>define</literal> element, add a <literal>define</literal>
element to the <literal>grammar</literal> element, and replace the
<literal>element</literal> element by a <literal>ref</literal> element
referring to the added <literal>define</literal> element. The value of
the <literal>name</literal> attribute of the added
<literal>define</literal> element mref</literal> element to be
<firstterm>expandable</firstterm> if it refers to a
<literal>define</literal> element whose child is not an
<literal>element</literal> element.  For each <literal>ref</literal>
element that is expandable and is a descendant of a
<literal>start</literal> element or an <literal>element</literal>
element, expand it by replacing the <literal>ref</literable <literal>ref</literal>
elements in this replacement.  This must not result in a loop.
In other words expanding the replacement of a
<literal>ref</literal> element having a <literal>name</literal> with
value <replaceable>n</replaceable> must not rents are valid with respect to that schema.  The semantics are
described formally.  The formalism uses axioms and inference rules.
Axioms are propositions that are provable unconditionally.  An
inference rule consists of one or more antecedents and exact:attribute name="ns">
          <p:var range="uri"/>
        </p:attribute>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="nsName 2">
    <p:not>
      <p:judgement name="belongs">
	<p:function name="name">
	  <p:var range="uunction>
      <p:element name="nsName">
        <p:attribute name="ns">
          <p:var range="uri"/>
        </p:attribute>
        <p:element name="except">
          <p:var range="nameClass"/>
        </p:element>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="name">
    <p:judgement name="belongs">
      <p:function name="name">
        <p:var range="uri"/>
        <p:var range="ncname"/>
      </p:function>
      <p:element name="name">
        <p:attribute name="ns">
          <p:var range="uri"/>
        </p:attribute>
        <p:var range="ncname"/>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="name choice 1">
    <p:judgement name="belongs">
      <p:var range="name"/>
      <p
      <p:element name="choice">
        <p:var range="nameClass" sub="1"/>
        <p:var range="nameClass" sub="2"/>
     :judgement></term><listitem><para>
    
asserts that with respect to context <p:var range="context"/>, the
attributes <p:var range="att"/> and the sequence of elements and
strings <p:var range="mixed"/> matches the pattern <p:var
range="pattern"/></pahoice 1">

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mix <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:rlistentry><term><p:function name="append">
	<p:var range="mixed" sub="1"/>
	<p:var range="mixed" sub="2"/>
      </p:function></term><listitem>
<para>represents the concatenation of the sequences <p:var range="mixed" sub="1"/> and <p:var range="mixed" sub="2"/>

</para></listitem></varlistentry>

<varlistentry><term><p:function name="union">
	<p:var range="att" sub="1"/>
	<p:var range="att" sub="2"/>
      </p:function></term><listitem>
<para>represents the union of <p:var range="att" sub="1"/>
and <p:var range="att" sub="2"/></para>
</listitem>
</varlistentry>

</variablelist>

<para>The semantics of the <literattern" sub="1"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" name="match">
      <p:var range="context"/>
      <p:function name="union">
	<p:var range="att" sub="1"/>
	<p:var range="a

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:function name="emptySequence"emptySet"/></term><listitem><para>represents an empty set</para></listitem></varlistentry>

</variablelist>

<para>The semantics of the <literal>empty</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="empty">
    <p:judgemeudgement>
  </p:rule>
</p:proofSystem>

</section>


<section id="text-pattern">
<title><literal>text</literal> pattern</title>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:var range="string"/></term><listitem><para>ranges
over strings</para></listitem></varlistentry>
</variablelist>

<para>The semantics of the <literal>text</literal> pattern are as follows:</para>

<p:proofSystem>
  <p:rule name="text 1">
    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:function name="emptySequence"/>
      <p:element name="text"></p:element>
      <p:function name="emptySet"/>
      <p:function name="emptySet"/>
    </p:judgement>
  </p:ret"/>
      <p:var range="mixed"/>
      <p:element name="text"></p:element>
      <p:function name="emptySet"/>
      <p:function name="emptySet"/>
    </p:judgement>
    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:function name="append">
        <p:var range="mixed"/>
        <p:var range="string"/>
      </p:ment matches zero or more strings.</para>

</section>


<section>
<title><literal>oneOrMore</literal> pattern</title>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:judgement name="disjoint">
    e is no name that is
the name of both an attribute in <p:var range="att" sub="1"/>
and of an attribute in <p:var range="att" s:element name="oneOrMore">
        <p:var range="pattern"/>
      </p:element>
    </p:judgement>
  </p:rule>

</p:proofSystem>

</section>


<section>
<title><literal>interleave</literal> pattern</title>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:judgement name="interleave">
      <p:var range="mixed" sub="1"/>serts that <p:var range="mixed" sub="1"/>
is an interleaving of <p:var range="mixed" sub="2"/>
and <p:var range="mixed" sub="3"/>
</para></listitem></varlistentry>

</variablelist>

<para>The semantics of interleaving are defined by the following rules.</para>


<p:proofSystem>
  <p:rule name="interleaves 1">
   
    <p:judgement name="interleave">
      <p:function n
   
    <p:judgement name="interleave">
      <p:var range="mixed" sub="1"/>
      <p:var range="mixed" sub="2"/>
      <p2"/>
      <p:function name="append">
        <p:var range="mixed" sub="4"/>
        <p:var range="mixed" sub="3"/>
      </interleave</literal> pattern are
as follows:</para>

<p:proofSystem>
  <p:rule name="interleave">

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="1"/>
      <p:var range="mixed" sub="1"/>
      <p:var range="pattern" sub="1"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="2"/>
      <p:var range="mixed" sub="2"/>
      <p:var range="pattern" sub="2"/>
    </p:judgement>

    <p: range="pattern"/>
      </p:element>
    </p:judgement>

  </p:rule>

</p:proofSystem>

<para>The semantics of the <litakMatch">
      <p:var range="context" sub="1"/>
      <p:var range="att"/>
      <p:var range="mixed"/>
      <p:var range="pattern"/>
    </p:judgement>

    <p:judgement name="belongs">
      <p:var range="name"/>
      <p:var range="nameClass"/>
    </p:judgement>

    <p:judgement name="okAsChildren">
      <p:var range="mixed"/>
    </p:judgement>

    <p:judgement name="bind">
      <p:var range="ncname"/>
      <p:var range="nameClass"/>
      <p:var range="pattern"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context" sub="2"/>
      <p:function name="emptySet"/>
      <pe="ncname"/>
        </p:attribute>
      </p:element>
    </p:judgement>

  </p:rule>

</p:proofSystem>


</section>

<section id="data-pattern">
<title><literal>data</literal> and <literal>value</literal> pattern</title>

<para>RELAX NG relies on datatype libraries to perform datatyping.
A datatype library is identified by a URI.  A datatype within a
datatype library is identified by an NCName.  A datatype library
provides two services.</para>

<itemizedlist>

<listitem><para>It can arameters are applicable for each datatype.</para></listitem>

<listitem><para>It can determine whether two strings represent the
same value of a datatype.  This service does not have any
parameters.</para></listitem>

</itemizedlist>

<para>Both services may make use of the context of a string.  For
example, a datatype representing a QName would use the namespace
map.</para>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:judgement name="datatypeAllows">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="params"/>
      <p:var range="string"stentry><term><p:judgement name="datatypeEqual">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="uri"/>, string <p:var range="string" sub="1"/> interpreted with
context <p:var range="context" sub="1"/> represents the same vra>ranges over sequences of parameters</para></listitem></varlistentry>

<varlistentry><term><p:context>
     <p:var range="context"/>
   </p:context></term><listitem><para>
   
within the start-tag of a pattern refers to the context
of the pattern  range="uri"/>
      <p:var range="ncname"/>
      <p:var range="string" sub="2"/>
      <p:var range="context" sub="3"/>
      <p:var range="string" sub="3"/>
      <p:var range="context" sub="3"/>
    </p:judgement>
    <p:judgement name="datatypeEqual">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="string" sub="1"/>
      <p:var range="cch">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:var range="string"/>
      <p:element name="data">
        <p:attribute name="datatypeLibrary">
          <p:var range="uri"/>
        </p:attribute>
        <p:attribute name="type">
          <p:var range="ncname"/>
        </p:attribute>
        <p:var range="params"/>
      </p:element>
      <p:function name="emptySet"/>
      <p:function name="emptySet"/>
    </p:judgement>
  </p:rule>

  <p:rule name="data 2">
    <p:judgement name="datatypeAllows">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="params"/>
      <p:var range="string"/>
      <p:var range="context"/>
    </p:judgement>
    <p:not>
      <p:judgement name="match">
	<p:var range="context"/>
	<p:var range="att"/>
	<p:var range="string"/>
        <p:var range="pattern"/>
      </p:judgement>
    </p:not>
    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:var range="string"/>
      <p:element name="data">
        <p:attribute name="datatypeLibrary">
          <p:var range="uri"/>
        </p:attribute>
        <p:attribute name="type">
          <p:var range="ncname"/>
        </p:attribute>
        <p:var range="params"/>
        <p:element name="except">
          <p:var range="pattern"/>
        </p:element>
      </p:element>
      <p:function name="emptySet"/>
      <p:function name="emptySet"/>
    </p:judgement>
  </p:rule>

</p:proofSystem>

</section>

<section id="built-in-datatype">
<title>Built-in datatype library</title>

<para>The empty URI identifies a special built-in datatype library.
This provides two datatypes, <literal>string</literal> and
<literal>ge="context"/>
    </p:judgement>
  </p:rule>

  <p:rule name="string equal">
    <p:judgement name="datatypeEqual">
      <p:function name="emptyString"/>
      <p:string>string</p:string>
      <p:var range="string"/>
      <p:var range="context:string>
      <p:function name="emptySequence"/>
      <p:var range="string"/>
      <p:var range="context"/>
    </p:judgement>
  </p:rule>

  <p:rule name="token equal">
    <p:judgement name="equal">
      <p:function name="normalizeWhiteSpace     <p:function name="split">
        <p:var range="string"/>
      </p:function>
      <p:var range="pattern"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:var range="string"/>
      <p:element name="list">
	<p:var range="pattern"/>
      </p:element>
    </p:judgement>

  </p:rule>
</p:proofSystem>

<note><para>It is crucial in the above inference rule that the
sequence that is matched against a pattern can contain consecutive
strings.</para></note>

</section>

</section>

<section id="validity">
<title>Validity</title>

<para>Now we can define when an element is valid with respect to a
schema.  We use the following additional notation:</para>

<variablelist>

<varlistentry><term><p:var range="element"/></term><listitem><para>ranges over elements</para></listitem><p:attribute>
      <p:string>bar2</p:string>
    </p:element>
    <p:element name="empty"/>
  </p:judgement>
</p:formula>


<para>Let name class <p:var range="nameClass" sub="1"/> be</para>

<p:formula>
  <p:element name="name">
    <p:attribute name="ns">
      <p:string>http://www.example.com/n1</p:string>
    </p:attribute>
    <p:string>bar1</p:string>
  </p:element>
</p:formula>

<para>and let <p:var range="nameClass" sub="2"/> be</para>

<p:formula>
  <p:element name="name">
   
<para>and</para>

<p:formula>
  <p:judgement name="belongs">
    <p:function name="name">
      <p:string>http://www.example.com/n2</p:string>
      <p:string>bar2</p:string>
    </p:function>
    <p:var range="nameClass" sub="2"/>
  </p:judgement>
</p:formula>


<para>By the inference rule (empty) in <xref linkend="empty-pattern"/>,
we have</para>

<p:formula>
  <p:judgement name="match">
    <p:var range="context" sub="1"/>
    <p:function name="emptySet"/>
    <p:function name="emptySequence"/>
    <p:element name="empty"></p:element>
  </p:judgement>
</p:formula>

<para>and</para>

<p:formula>
  <p:judgement name="match">
    <p:var range="context" sub="2"/>
    <p:function name="emptySet"/>
    <p:function name="emptySequence"/>
    <p:element name="empty"></p:element>
  </p:judgement>
</p:formula>

<para>Thus by the inference rule (element) in <xref
linkend="element-pattern"/>, we have</para>

<p:formula>
  <p:judgement name="match">
    <p:var range="context" sub="0"/>
    <p:function name="emptySet"/>
    <p:var range="element" sub="1"/>
    <p:element name="ref">
      <p:attribute name="name">
        <p:string>bar1</p:string>
      </p:attribute>
    </p:element>
  </p:judgement>
</p:formula>

<pa <p:var range="element" sub="2"/>
    <p:element name="ref">
      <p:attribute name="name">
        <p:string>bar2</p:string>
      </p:attribute>
    </p:element>
  </p:judgement>
</p:formula>

<para>By the inference rule (group) in <xref
linkend="choice-pattern"/>, we have</para>

<p:formula>
  <p:judgement name="match">
    <p:var range="context" sub="0"/>
    <p:function name="emptySet"/>
    <p:function name="append">
      <p:var range="element" sub="1"/>
      <p:var range="element" sub="2"/>
    </p:function>
    <p:element name="group">
      <p:element name="ref">
        <p:attribute name="name">
          <p:string>bar1</p:string>
        </p:attribute>
      </p:element>
      <p:element name="ref">
        <p:attribufunction>
      <p:var range="context" sub="0"/>
      <p:function name="emptySet"/>
      <p:var range="mixed"/>
    </p:function>
    <p:element name="ref">
      <p:attribute name="name">
        <p:string>foo</p:string>
      </p:attribute>
  nce of NCNames separated
by <literal>/</literal> or <literal>//</literal>.</para>

<itemizedlist>

<listitem><para>An element matches a path
<replaceable>x</replaceable>, where <replaceable>x</replaceable> is an
NCName, if and only if the local name of the element is
<replaceable>x</replaceable></para></listitem>

<listitem><para>An element matches a path
<replaceable>x</replaceable><literal>/</literal><replaceable>p</replaceable>,
where <replaceable>x</replaceable> is an NCName and
<replaceabltemizedlist>
<listitem><para><literal>data/except//attribute</literal></para></listitem>
<listitem><para><literal>data/except//ref</literal></para></listitem>
<listitem><para><literal>data/except//text</literal></para></listitem>
<listitem><para><literitem><para><literal>data/except//interleave</literal></para></listitem>
<listitem><para><literal>data/except//oneOrMore</literal></para></listitem>
<listitem><para><literal>data/except//empty</literal></para></listitem>
</itemizedlist>

<note><para>This implies that an <literal>except</literal> element
with a <literal>data</literal> parent can contain only
<literal>data</literal>, <literal>value</literal> and
<literal>choice</literal> elements.</para></note>

</section>

<section id="context-start">
<title><literal>start</literal> element</title>

<para>The following paths are prohibited:</para>

<itemizedlist>
<listitem><para><literal>start//attribute</literal></para></listitem>
<listitem><para><literal>start//data</literal></para></listitem>
<listitem><para><literal>start//value</literal></para></listitem>
<listitem><para><literal>start//text</literal></para></listitem>
<listitem><para><literal>start//list</literal></para></listitem>
<listitem><para><literal>start//group</literal></para></listitem>
<listitem><para><literal>start//interleave</literal></para></listitem>
<listitem><para><literal>start//oneOrMore</literal></para></listitem>
<listitem><para><literal>start//empty</literal></para></listitem>
</itemizedlist>
</section>

</section>

<section id="string-sequences">
<title>String sequences</title>

<para>RELAX NG does not allow a pattern such as:</para>

<programlisting><![CDATA[<element name="foo">
  <group>
    <data type="int"/>
    <element name="bar">
      <empty/>
    </element>
  </group>
</element>]]></programlisting>

<para>Nor does it allow a pattern such as:</para>

<pr empty content-type is groupable with anything.  In addition,
the complex content-type is groupable with the complex content-type. The
following rules formalize this.</para>

<p:proofSystem>
<p:rule name="group empty 1">
  <p:judgement name="groupable">
    <p:function name="empty"/>
    <p:var range="contentType"/>
  </p:judgement>
</p:rule>
<p:rule name="group empty 2">
  <p:judgement name="groupable">
    <p:var range="contentType"/>
    <p:function name="empty"/>
  </p:judgement>
</p:rul
content-type <p:var range="contentType"/></para></listitem>
</varlistentry>

<varlistentry><term>
  <p:function name="max">
    <p:var range="contentType" sub="1"/>
    <p:var range="contentType" sub="2"/>
  </p:function>
</term>
<listitem><para>returns the maximum of <p:var range="contentType"
sub="1"/> and <p:var range="contentType" sub="2"/> where the
content-types in increasing order are <p:function name="empty"/>,
<p:function name="complex"/>, <p:function
name="simple"/></para></listitem>
</varlistentry>

</variablelist>

<para>The following rules define when a pattern has a content-type and,
if so, what it is.</para>

<p:proofSystem>
<p:rule name="value">
  <p:judgement name="contentType">
    <p:element name="value">
      <p:attribute name="datatypeLibrary">
	<p:var range="uri" sub="1"/>
      </p:attribute>
      <p:attribute name="type">
	<p:var range="ncname"/>
      </p:attribute>
      <p:attribute name="ns">
	<p:var range="uri" sub="2"/>
      </p:attribute>
 e"/>
  </p:judgement>
</p:rule>

<p:rule name="list">
  <p:judgement name="contentType">
    <p:element name="list">
      <p:var range="pattern"/>
    </p:element>
    <p:function name="simple"/>
  </p:judgement>
</p:rule>

<p:rule name="text">
  <p:judgement name="contentType">
    <p:element name="text"/>
    <p:function name="complex"/>
  </p:judgement>
</p:rule>

<p:rule name="ref">
  <p:judgement name="contentType">
    <p:element name="ref">
      <p:attribute name="name">
	<p:var range="ncname"/>
      </p:attribute>
    </p:element>
    <p:function name="complex"/>
  </p:judgement>
</p:rule>

<p:rule name="empty">
  <p:judgement name="contentType">
    <p:element name="empty"/>
    <p:function name="empty"/>
  </p:judgement>
</p:rule>

<p:rule name="attribute">
  <p:judgement name="contentType">
    <p:var range="pattern"/>
    <p:var range="contentType"/>
  </p:judgement>
  <p:judgement name="contentType">
    <p:element name="attribute">
      <p:var ran
</itemizedlist>

<para><xref linkend="attribute-restrictions"/> defines when one
pattern is considered to occur in another pattern.</para>

</section>

</section>

<section id="conformance">
<title>Conformance</title>

<para>A conforming RELAX NG validator must be able to determine for
any XML document whether it is a correct RELAX NG schema.  A
conforming RELAX NG validator must be able to determine for any XML
document and for any correct RELAX NG schema whether the document is
valid with respect to the schema.</para>

<para>However, the requirements in the preceding paragraph do not
apply if the schema uses a datatype library that the validator does
not support.  A conforming RELAX NG validator is only required to
support the built-in datatype library described in <xref
linkend="built-in-datatype"/>.  A validator that claims conformance to
RELAX NG should cludes <literal>externalRef</literal> or
<literal>include</literal> elements and the validator is unable to
retrieve the resouce to RELAX NG should document its capabilities for handling
URI references.</para>

</section>

<appendix>
<title>RELAX NG schema for RELAX NG</title>

<rngref src="relaxng.rng"/>

</appendix>

<appendix>
<title>Changes since version 0.9</tit the namespace URI, <literal>0.9</literal> has been
changed to <literal>1.0</literal></para></listitem>

<listitem><para><literal>data/except//empty</literal> has been added
as a prohibited path (see <xref
linkend="context-data-except"/>)</para></listitem>

<listitem><para><literal>start//empty</literal> has been added
as a prohibited path (see <xref
linkend="context-starts of <literal>except</literal> in name
classes that are now specified in the newly added section were
previously specified in a subsection of <xref
linkend="contextual-restriction"/>, which has been
removed</para></listitem>

<listitem><para>the treatment of element and attribute values that
consist only of whitespace has been refined (see <xref
linkend="element-pattern"/> and <xref
linkend="data-pattern"/>)</para></listitem>

<listitem><para>attributes with infinite name classes are now required
to be repeated (see <xref
linkend="attribute-restrictions"/>)</para></listitem>

<listitem><para>restrictions have been imposed on
<literal>interleave</literal> (see <xref
linkend="interleave-restrictions"/>); <literal>list//interleave</literal>
haohibited paths in <xref
linkend="contextual-restriction"/> have been corrected to use
<literal>ref</literal> rather than
<litmembers of the TC are:</para>

<itemizedlist>
<listitem><para>Fabio Arciniegas</para></listitem>
<listitem><para>James Clark</para></listitem>
<listitem><para>Mike Fitzgerald</para></listitem>
<listitem><para>KAWAGUCHI Kohsuke</para></listitem>
<lis/listitem>
<listitem><para>David Webber</para></listitem>
</itemizedlist>

</appendix>

<bibliography><title>References</t/TR/xlink/">XML Linking
Language (XLink) Version 1.0</ulink></citetitle>.
W3C (World Wide Web Consortium), 2001.</bibliomixed>

<bibliomixed id="infoset"><abbrev>XML Infoset</abbrev>John Cowan, Richard Tobin,
editors.
<citetitle><ulink url="http://wwulink></citetitle>.
W3C (World Wide Web Consortium), 2001.</bibliomixed>

<bibliomixed id="tutorial"><abbrev>Tutorial</abbrev>James Clark,
Makoto MURATA, editors.  <citetitle><ulink
url="http://www.oasis-open.org/committees/relax-ng/tutorial.html">RELAX
NG Tutorial</ulink></citetitle>.  OASIS, 2001.</bibliomixed>

</bibliodiv>

<