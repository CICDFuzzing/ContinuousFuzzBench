a\:<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article [
<!-- ELEMENT declarations work around MSXML bug. -->
<!ELEMENT section ANY>
<!ATTLIST section id ID #IMPLIED>
<!ELEMENT appendix ANY>
<!ATTLIST appendix id ID #IMPLIED>
<!ELEMENT bibliomixed ANY>
<!ATTLIST bibliomixed id ID #IMPLIED>
]>
<article status="Committee Specification" xmlns:p="http://relaxng.org/ns/proofsystem">

<articleinfo>
<releaseinfo>$Id: spec.xml,v 1.159 2001/12/02 12:12:12 jjc Exp $</releaseinfo>
<title>RELAX NG Specification</title>
<authorgroup>
<editor>
  <firstname>James</firstname><surname>Clark</surname>
  <affiliation>
    <address><email>jjc@jclark.com</email></address>
  </affiliation>
</editor>
<editor>
  <surname>MURATA</surname><firstname>Makoto</firstname>
  <affiliation>
    <address><email>EB2M-MRT@asahi-net.or.jp</email></address>
  </affiliation>
</editor>
</authorgroup>
<pubdate>3 December 2001</pubdate>
<releaseinfo role="meta">
$Id: spec.xml,v 1.159 2001/12/02 12:12:12 jjc Exp $
</releaseinfo>

<copyright><year>2001</year><holder>OASIS</holder></copyright>

<legalnotice>

<para>Copyright &#169; The Organization for the Advancement of
Structured Information Standards [OASIS] 2001. All Rights
Reserved.</para>

<para>This document and translations of it may be copied and furnished
to others, and derivative works that comment on or otherwise explain
it or assist in its implementation may be prepared, copied, published
and distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to OASIS, except as needed for the
purpose of developing OASIS specifications, in which case the
procedures for copyrights defined in the OASIS Intellectual Property
Rights document must be followed, or as required to translate it into
languages other than English.</para>

<para>The limited permissions granted above are perpetual and will not
be revoked by OASIS or its successors or assigns.</para>

<para>This document and the information contained herein is provided
on an <quote>AS IS</quote> basis and OASIS DISCLAIMS ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE
USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</para>

</legalnotice>

<legalnotice role="status"><title>Status of this Document</title>

<para>This Committee Specification was approved for publication by the
OASIS RELAX NG technical committee. It is a stable document which
represents the consensus of the committee. Comments on this document
may be sent to <ulink
url="mailto:relax-ng-comment@lists.oasis-open.org"
>relax-ng-comment@lists.oasis-open.org</ulink>.</para>

<para>A list of known errors in this document is available at <ulink
url="http://www.oasis-open.org/committees/relax-ng/spec-20011203-errata.html"
>http://www.oasis-open.org/committees/relax-ng/spec-20011203-errata.html</ulink
>.</para>

</legalnotice>

<abstract>
<para>This is the definitive specification of RELAX NG, a simple
schema language for XML, based on <xref linkend="relax"/> and <xref
linkend="trex"/>. A RELAX NG schema specifies a pattern for the
structure and content of an XML document. A RELAX NG schema is itself
an XML document.</para>
</abstract>

<revhistory>
<revision>
  <revnumber>Committee Specification</revnumber>
  <date>3 December 2001</date>
</revision>
<revision>
  <revnumber>Committee Specification</revnumber>
  <date>11 August 2001</date>
</revision>
</revhistory>
</articleinfo>


<section>
<title>Introduction</title>

<para>This document specifies</para>

<itemizedlist>

<listitem><para>when an XML document is a correct RELAX NG
schema</para></listitem>

<listitem><para>when an XML document is valid with respect to a
correct RELAX NG schema</para></listitem>

</itemizedlist>

<para>An XML document that is being validated with respect to a RELAX NG
schema is referred to as an instance.</para>

<para>The structure of this document is as follows.  <xref
linkend="data-model"/> describes the data model, which is the
abstraction of an XML document used throughout the rest of the
document.  <xref linkend="full-syntax"/> describes the syntax of a
RELAX NG schema; any correct RELAX NG schema must conform to this
syntax.  <xref linkend="simplification"/> describes a sequence of
transformations that are applied to simplify a RELAX NG schema;
applying the transformations also involves checking certain
restrictions that must be satisfied by a correct RELAX NG
schema. <xref linkend="simple-syntax"/> describes the syntax that
results from applying the transformations; this simple syntax is a
subset of the full syntax.  <xref linkend="semantics"/> describes the
semantics of a correct RELAX NG schema that uses the simple syntax;
the semantics specify when an element is valid with respect to a RELAX
NG schema.  <xref linkend="restriction"/> describes restrictions in
terms of the simple syntax; a correct RELAX NG schema must be such
that, after transformation into the simple form, it satisfies these
restrictions. Finally, <xref linkend="conformance"/> describes
conformance requirements for RELAX NG validators.</para>

<para>A tutorial is available separately (see <xref
linkend="tutorial"/>).</para>

</section>

<section id="data-model">
<title>Data model</title>

<para>RELAX NG deals with XML documents representing both schemas and
instances through an abstract data model.  XML documents representing
schemas and instances must be well-formed in conformance with <xref
linkend="xml-rec"/> and must conform to the constraints of <xref
linkend="xml-names"/>.</para>

<para>An XML document is represented by an element.  An element consists
of</para>

<itemizedlist>

<listitem><para>a name</para></listitem>

<listitem><para>a context</para></listitem>

<listitem><para>a set of attributes</para></listitem>

<listitem><para>an ordered sequence of zero or more children; each
child is either an element or a non-empty string; the sequence never contains
two consecutive strings</para></listitem>

</itemizedlist>

<para>A name consists of</para>

<itemizedlist>
<listitem><para>a string representing the namespace URI; the empty
string has special significance, representing the absence of any
namespace</para></listitem>

<listitem><para>a string representing the local name; this string matches the NCName
production of <xref linkend="xml-names"/></para></listitem>
</itemizedlist>

<para>A context consists of</para>

<itemizedlist>
<listitem><para>a base URI</para></listitem>
<listitem><para>a namespace map; this maps prefixes to namespace URIs,
and also may specify a default namespace URI (as declared
by the <literal>xmlns</literal> attribute)</para></listitem>
</itemizedlist>

<para>An attribute consists of</para>

<itemizedlist>
<listitem><para>a name</para></listitem>
<listitem><para>a string representing the value</para></listitem>
</itemizedlist>

<para>A string consists of a sequence of zero or more characters,
where a character is as defined in <xref linkend="xml-rec"/>.</para>

<para>The element for an XML document is constructed from an instance
of the <xref linkend="infoset"/> as follows.  We use the notation
[<replaceable>x</replaceable>] to refer to the value of the
<replaceable>x</replaceable> property of an information item. An
element is constructed from a document information item by
constructing an element from the [document element].  An element is
constructed from an element information item by constructing the name
from the [namespace name] and [local name], the context from the [base
URI] and [in-scope namespaces], the attributes from the [attributes],
and the children from the [children].  The attributes of an element
are constructed from the unordered set of attribute information items
by constructing an attribute for each attribute information item.  The
children of an element are constructed from the list of child
information items first by removing information items other than
element information items and character information items, and then by
constructing an element for each element information item in the list
and a string for each maximal sequence of character information items.
An attribute is constructed from an attribute information item by
constructing the name from the [namespace name] and [local name], and
the value from the [normalized value].  When constructing the name of
an element or attribute from the [namespace name] and [local name], if
the [namespace name] property is not present, then the name is
constructed from an empty string and the [local name]. A string is
constructed from a sequence of character information items by
constructing a character from the [character code] of each character
information item.</para>

<para>It is possible for there to be multiple distinct infosets for a
single XML document.  This is because XML parsers are not required to
process all DTD declarations or expand all external parsed general
entities.  Amongst these multiple infosets, there is exactly one
infoset for which [all declarations processed] is true and which does
not contain any unexpanded entity reference information items.  This
is the infoset that is the basis for defining the RELAX NG data
model.</para>

<section id="data-model-example">
<title>Example</title>

<para>Suppose the document
<literal>http://www.example.com/doc.xml</literal> is as
follows:</para>

<programlisting><![CDATA[<?xml version="1.0"?>
<foo><pre1:bar1 xmlns:pre1="http://www.example.com/n1"/><pre2:bar2
  xmlns:pre2="http://www.example.com/n2"/></foo>
]]></programlisting>

<para>The element representing this document has</para>

<itemizedlist>
<listitem><para>a name which has</para>
<itemizedlist>

<listitem><para>the empty string as the namespace URI, representing
the absence of any namespace</para></listitem>

<listitem><para><literal>foo</literal> as the local
name</para></listitem>

</itemizedlist>

</listitem>

<listitem><para>a context which has</para>

<itemizedlist>
<listitem><para><literal>http://www.example.com/doc.xml</literal> as the base
URI</para></listitem>

<listitem><para>a namespace map which</para>

<itemizedlist>

<listitem><para>maps the prefix <literal>xml</literal> to the
namespace URI
<literal>http://www.w3.org/XML/1998/namespace</literal>
(the <literal>xml</literal> prefix is implicitly declared
by every XML document)</para></listitem>

<listitem><para>specifies the empty string as the default namespace
URI</para></listitem>

</itemizedlist>

</listitem>

</itemizedlist>

</listitem>

<listitem><para>an empty set of attributes</para></listitem>

<listitem><para>a sequence of children consisting
of an element which has</para>

<itemizedlist>
<listitem><para>a name which has</para>
<itemizedlist>

<listitem><para><literal>http://www.example.com/n1</literal> as the
namespace URI</para></listitem>

<listitem><para><literal>bar1</literal> as the local
name</para></listitem>

</itemizedlist>

</listitem>

<listitem><para>a context which has</para>

<itemizedlist>
<listitem><para><literal>http://www.example.com/doc.xml</literal> as the base
URI</para></listitem>

<listitem><para>a namespace map which</para>

<itemizedlist>

<listitem><para>maps the prefix <literal>pre1</literal> to the
namespace URI
<literal>http://www.example.com/n1</literal></para></listitem>

<listitem><para>maps the prefix <literal>xml</literal> to the
namespace URI
<literal>http://www.w3.org/XML/1998/namespace</literal></para></listitem>

<listitem><para>specifies the empty string as the default namespace
URI</para></listitem>

</itemizedlist>

</listitem>

</itemizedlist>

</listitem>

<listitem><para>an empty set of attributes</para></listitem>

<listitem><para>an empty sequence of children</para></listitem>

</itemizedlist>

<para>followed by an element which has</para>
 
<itemizedlist>
<listitem><para>a name which has</para>
<itemizedlist>

<listitem><para><literal>http://www.example.com/n2</literal> as the
namespace URI</para></listitem>

<listitem><para><literal>bar2</literal> as the local
name</para></listitem>

</itemizedlist>

</listitem>

<listitem><para>a context which has</para>

<itemizedlist>
<listitem><para><literal>http://www.example.com/doc.xml</literal> as the base
URI</para></listitem>

<listitem><para>a namespace map which</para>

<itemizedlist>

<listitem><para>maps the prefix <literal>pre2</literal> to the
namespace URI
<literal>http://www.example.com/n2</literal></para></listitem>

<listitem><para>maps the prefix <literal>xml</literal> to the
namespace URI
<literal>http://www.w3.org/XML/1998/namespace</literal></para></listitem>

<listitem><para>specifies the empty string as the default namespace
URI</para></listitem>

</itemizedlist>

</listitem>

</itemizedlist>

</listitem>

<listitem><para>an empty set of attributes</para></listitem>

<listitem><para>an empty sequence of children</para></listitem>

</itemizedlist>

</listitem>
</itemizedlist>

</section>

</section>

<section id="full-syntax">
<title>Full syntax</title>

<para>The following grammar summarizes the syntax of RELAX NG.
Although we use a notation based on the XML representation of an RELAX
NG schema as a sequence of characters, the grammar must be understood
as operating at the data model level.  For example, although the
syntax uses <literal><![CDATA[<text/>]]></literal>, an instance or
schema can use <literal><![CDATA[<text></text>]]></literal> instead,
because they both represent the same element at the data model level.
All elements shown in the grammar are qualified with the namespace
URI:</para>

<programlisting>http://relaxng.org/ns/structure/1.0</programlisting>

<para>The symbols QName and NCName are defined in <xref
linkend="xml-names"/>.  The anyURI symbol has the same meaning as the
anyURI datatype of <xref linkend="xmlschema-2"/>: it indicates a
string that, after escaping of disallowed values as described in
Section 5.4 of <xref linkend="xlink"/>, is a URI reference as defined
in <xref linkend="rfc2396"/> (as modified by <xref
linkend="rfc2732"/>).  The symbol string matches any string.</para>

<para>In addition to the attributes shown explicitly, any element can
have an <literal>ns</literal> attribute and any element can have a
<literal>datatypeLibrary</literal> attribute. The
<literal>ns</literal> attribute can have any value.  The value of the
<literal>datatypeLibrary</literal> attribute must match the anyURI
symbol as described in the previous paragraph; in addition, it must
not use the relative form of URI reference and must not have a
fragment identifier; as an exception to this, the value may be the
empty string.</para>

<para>Any element can also have foreign attributes in addition to the
attributes shown in the grammaR. A foreign attribute is an attribute
with a name whose namespace URI is neither the empty string nor the
RELAX NG namespace URI.  Any element that cannot have string children
(that is, any element other than <literal>value</literal>, <literal>param</literal>
and <literal>name</literal>) may have foreign child elements in addition
to the child elements shown in the grammar. A foreign element is an
element with a name whose namespace URI is not the RELAX NG namespace
URI.  There are no constraints on the relative position of foreign
child elements with respect to other child elements.</para>

<para>Any element can also have as children strings that consist
entirely of whitespace characters, where a whitespace character is one
of #x20, #x9, #xD or #xA. There are no constraints on the relative
position of whitespace string children with respect to child
elements.</para>

<para>Leading and trailing whitespace is allowed for value of each
<literal>name</literal>, <literal>type</literal> and
<literal>combine</literal> attribute and for the content of each
<literal>name</literal> element.</para>

<grammarref src="full.rng"/>

<section id="full-syntax-example">
<title>Example</title>

<para>Here is an example of a schema in the full syntax for the
document in <xref linkend="data-model-example"/>.</para>

<programlisting><![CDATA[<?xml version="1.0"?>
<element name="foo"
         xmlns="http://relaxng.org/ns/structure/1.0"
         xmlns:a="http://relaxng.org/ns/annotation/1.0"
         xmlns:ex1="http://www.example.com/n1"
         xmlns:ex2="http://www.example.com/n2">
  <a:documentation>A foo element.</a:document>
  <element name="ex1:bar1">
    <empty/>
  </element>
  <element name="ex2:bar2">
    <empty/>
  </element>
</element>]]></programlisting>

</section>

</section>

<section id="simplification">
<title>Simplification</title>

<para>The full syntax given in the previous section is transformed
into a simpler syntax by applying the following transformation rules
in order. The effect must be as if each rule was applied to all
elements in the schema before the next rule is applied.  A
transformation rule may also specify constraints that must be
satisfied by a correct schema. The transformation rules are applied
at the data model level.  Before the transformations are applied, the
schema is parsed into an instance of the data model.</para>

<section>
<title>Annotations</title>

<para>Foreign attributes and elements are removed.</para>

<note><para>It is safe to remove <literal>xml:base</literal>
attributes at this stage because <literal>xml:base</literal>
attributes are used in determining the [base URI] of an element
information item, which is in turn used to construct the base URI of
the context of an element.  Thus, after a document has been parsed
into an instance of the data model, <literal>xml:base</literal>
attributes can be discarded.</para></note>

</section>

<section>
<title>Whitespace</title>

<para>For each element other than <literal>value</literal> and
<literal>param</literal>, each child that is a string containing only
whitespace characters is removed.</para>

<para>Leading and trailing whitespace characters are removed from the
value of each <literal>name</literal>, <literal>type</literal> and
<literal>combine</literal> attribute and from the content of each
<literal>name</literal> element.</para>

</section>

<section>
<title><literal>datatypeLibrary</literal> attribute</title>

<para>The value of each <literal>datatypeLibary</literal> attribute is
transformed by escaping disallowed characters as specified in Section
5.4 of <xref linkend="xlink"/>.</para>

<para>For any <literal>data</literal> or <literal>value</literal>
element that does not have a <literal>datatypeLibrary</literal>
attribute, a <literal>datatypeLibrary</literal> attribute is
added. The value of the added <literal>datatypeLibrary</literal>
attribute is the value of the <literal>datatypeLibrary</literal>
attribute of the nearest ancestor element that has a
<literal>datatypeLibrary</literal> attribute, or the empty string if
there is no such ancestor. Then, any <literal>datatypeLibrary</literal>
attribute that is on an element other than <literal>data</literal> or
<literal>value</literal> is removed.</para>

</section>

<section>
<title><literal>type</literal> attribute of <literal>value</literal> element</title>

<para>For any <literal>value</literal> element that does not have a
<literal>type</literal> attribute, a <literal>type</literal> attribute
is added with value <literal>token</literal> and the value of the
<literal>datatypeLibrary</literal> attribute is changed to the empty
string.</para>

</section>

<section id="href">
<title><literal>href</literal> attribute</title>

<para>The value of the <literal>href</literal> attribute on an
<literal>externalRef</literal> or <literal>include</literal> element
is first transformed by escaping disallowed characters as specified in
Section 5.4 of <xref linkend="xlink"/>.  The URI reference is then
resolved into an absolute form as described in section 5.2 of <xref
linkend="rfc2396"/> using the base URI from the context of the element
that bears the <literal>href</literal> attribute.</para>

<para>The value of the <literal>href</literal> attribute will be used
to construct an element (as specified in <xref
linkend="data-model"/>). This must be done as follows.  The URI
reference consists of the URI itself and an optional fragment
identifier. The resource identified by the URI is retrieved.  The
result is a MIME entity: a sequence of bytes labeled with a MIME
media type.  The media type determines how an element is constructed
from the MIME entity and optional fragment identifier.  When the media
type is <literal>application/xml</literal> or
<literal>text/xml</literal>, the MIME entity must be parsed as an XML
document in accordance with the applicable RFC (at the term of writing
<xref linkend="rfc3023"/>) and an element constructed from the result
of the parse as specified in <xref linkend="data-model"/>.  In
particular, the <literal>charset</literal> parameter must be handled
as specified by the RFC. This specification does not define the
handling of media types other than <literal>application/xml</literal>
and <literal>text/xml</literal>. The <literal>href</literal> attribute
must not include a fragment identifier unless the registration of the
media type of the resource identified by the attribute defines the
interpretation of fragment identifiers for that media type.</para>

<note><para><xref linkend="rfc3023"/> does not define the
interpretation of fragment identifiers for
<literal>application/xml</literal> or
<literal>text/xml</literal>.</para></note>

</section>

<section>
<title><literal>externalRef</literal> element</title>

<para>An <literal>externalRef</literal> element is transformed as
follows.  An element is constructed using the URI reference that is
the value of <literal>href</literal> attribute as specified in <xref
linkend="href"/>. This element must ma›ch the syntax for pattern.  The
element is transformed by recursively applying the rules from this
subsection and from previous subsections of this section. This must
not result in a loop. In other words, the transformation of the
referenced element must not require the dereferencing of an
<literal>externalRef</literal> attribute with an
<literal>href</literal> attribute with the same value.</para>

<para>Any <literal>ns</literal> attribute on the
<literal>externalRef</literal> element is transferred to the
referenced element if the referenced element does not already have an
<literal>ns</literal> attribute.  The <literal>externalRef</literal>
element is then replaced by the referenced element.</para>

</section>

<section>
<title><literal>include</literal> element</title>

<para>An <literal>include</literal> element is transformed as follows.
An element is constructed using the URI reference that is the value clude</literal>
attribute with an <literal>href</literal> attribute with the same
value.</para>

<para>Define the <firstterm>components</firstterm> of an element to
be the children of the element together with the components of any
<literal>div</liteiteral>grammar</literal> element.</para>

<para>The <literal>include</literal> element is transformed into a
<literal>div</literal> element.  The attributes of the
<literal>div</literal> element are the attributes of the
<literal>include</literal> element other than the
<literal>href</literal> attribute.  The children of the
<literal>div</literal> element are the <literal>grammar</literal>
element (after the removal of the <literal>start</literal> and
<literal>define</literal> components described  element.</para>

<para>If an <literal>attribute</literal> element has a
<literal>name</literal> attribute but no <literal>ns</literal>
attribute, then an <literal>ns=""</literal> attribute is added to the
<literal>name</literal> child element.</para>

</section>

<section>
<title><literal>ns</literal> attribute</title>

<para>For any <literal>name</literal>, <literal>nsName</literal> or
<literal>value</literal> element that does not have an
<literal>ns</literal> attribute, an <literal>ns</litsformed to</para>

<programlisting>&lt;choice&gt; &lt;choice&gt; <replaceable>p1</replaceable> <replaceable>p2</replaceable> &lt;/choice&gt; <replaceable>p3</replaceable> &lt;/choice&gt;</programlisting>

<para>This reduces the number of child elements by one. The
transformation is applied repeatedly until there are exactly two child
elements.</para>

</section>

<section>
<title><literal>mixed</literal> element</title>

<para>A <literal>mixed</literal> element is transformed into an
interleaving with a <literal>text</literal> element:</para>

<programlisting>&lt;mixed> <replaceable>p</replaceable> &lt;/mixed></programlisting>

<para>is transformed into</para>

<programlisting>&lt;interleave> <replaceable>p</replaceable> &lt;text/> &lt;/interleave></programlisting>

</section>

<section>
<title><literal>optional</literal> element</title>

<para>An <literal>optional</literal> element is transformed into
a choice with <literal>empty</literal>:</para>

<programlisting>&lt;optional> <replaceable>p</replaceable> &lt;/optional></programlisting>

<para>is transformed into</para>

<programlisting>&lt;choice> <replaceable>p</replaceable> &lt;empty/> &lt;/choice></programlisting>

</section>

<section>
<title><literal>zeroOrMore</literal> element</title>

<para>A <literal>zeroOrMore</literal> element is transformed into a choice
between <literal>oneOrMore</literal> and
<literal>empty</literal>:</para>

<programlisting>&lt;zeroOrMore> <replaceable>p</replaceable> &lt;/zeroOrMore="nsName">
        <p:attribute name="ns">
          <p:var range="uri"/>
        </p:attribute>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="nsName 2">
    <p:not>
      <p:judgement name="belongs">
	<p:function name="nam"ncname"/>
      </p:function>
      <p:element name="nsName">
        <p:attribute name="ns">
          <p:var range="uri"/>
        </p:attribute>
        <p:element name="except">
          <p:var range="nameClass"/>
        </p:element>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="name">
    <p:judgement name="belongs">
      <p:function name="name">
        <p:var range="uri"/>
        <p:var range="ncname"/>
      </p:function>
      <p:element name="name">
        <p:attribute name="ns">
          <p:var range="uri"/>
        </p:attribute>
        <p:var range="ncname"/>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="name choice 1">
    <p:judgement name="belongs">
      <p:var r"/>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="name choice 2">
    <p:judgement name="belongs">
      <p:var range="name"/>
      <p:var range="nameClass" sub="2"/>
    </p:judgement>
    <p:judgement name="belongs">
    "mixed"/>
      <p:element name="oneOrMore">
        <p:var range="pattern"/>
      </p:element>
    </p:judgement>
  </p:rule>

  <p:rule name="oneOrMore 2">
    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="1"/>
      <p:var range="mixed" sub="1"/>
      <p:var range="pattern"/>
    </p:judgement>

    <p:judgement name="match">
      <p:var range="context"/>
      <p:var range="att" sub="2"/>
      <p:var range="mixed" sub="2"/>
      <p:element name="oneOrMore">
        <p:var range="pattern"/>
      </p:element>
    </p:judgement>

    <p:judgement name="disjoint">
      <p:var range="att" sub="1"/>
      <p:var range="att" sub="2"/>
    </p:judgement>

    <p:judgement name="match"></p:function>
      <p:element name="oneOrMore">
        <p:var range="pattern"/>
      </p:element>
    </p:judgement>
  </p:rule>

</p:proofSystem>

</section>


<section>
<title><literal>interleave</literal> pattern</title>

<para>We use the following additional notation:</para>

<variablelist>
<varlistentry><term><p:judgement name="interleave">
      <p:var range="mixed" sub="1"/>
      <p:var range="mixed" sub="2"/>
      <p:var range="mixed" sub="3"/>
    </p:judgement></term><listitem><para>
    
asserts that <p:var range="mixed" sub="1"/>
is an interleaving of <p:var range="mixed" sub="2"/>
and <p:var range="mixed" sub="3"/>
</para></listitem></varlistentry>

</variablelist>

<para>The semantics of interleaving are defined by the following rules.</para>


<p:proofSystem>
  <p:rule name="interleaves 1">
   
    <p:judgement name="interleave">
      <p:function name="emptySequence"/>
      <p:function name="emptySequence"/>
      <p:function name="emptySequence"/>
    </p:judgement>

  </p:rule>

  <p:rule name="interleaves 2">
   
    <p:judgement name="interleave">
      <p:var range="mixed" sub="1"/>
      <p:var range="mixed" sub="2"/>
      <p:var range="mixed" sub="3"/>
    </p:judgement>

    <p:judgement name="interleave">
      <p:function name="append">
        <p:var range="mixed" sub="4"/>
        <p:var range="mixed" sub="1"/>
      </p:function>
      <p:function name="append">
        <p:var range="mixed" sub="4"/>
        <p:var range="mixed" sub="2"/>
      </p:function>
      <p:var range="mixed" sub="3"/>
    </p:judgement>

  </p:rule>

  <p:rule name="interleaves 3">
   
    <p:judgement name="interleave">
      <p:var range="mixed" sub="1"/>
      <p:var range="mixed" sub="2"/>
      <p:var range="mixed" sub="3"/>
    </p:judgement>

    <p:judgement name="interleave">
      <p:function name="append">
        <p:var range="mixed" sub="4"/>
        <p:var range="mixed" sub="1"/>
      </p:function>
      <p::judgement>
  </p:rule>
  <p:rule name="datatypeEqual symmetric">
    <p:judgement name="datatypeEqual">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="string" sub="1"/>
      <p:var range="context" sub="1"/>
      <p:var range="string" sub="2"/>
      <p:var range="context" sub="2"/>
    </p:judgement>
    <p:judgement name="datatypeEqual">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="string" sub="2"/>
      <p:var range="context" sub="2"/>
      <p:var range="string" sub="1"/>
      <p:var range="context" sub="1"/>
    </p:judgement>
  </p:rule>
</p:proofSystem>

<para>The semantics of the <literal>data</literal> and
<literal>value</literal> patterns are as follows:</para> range="ncname"/>
        </p:attribute>
        <p:attribute name="ns">
          <p:var range="uri" sub="2"/>
        </p:attribute>
        <p:context>
          <p:var range="context" sub="2"/>
        </p:context>
        <p:var range="string" sub="2"/>
      </p:element>
      <p:function name="emptySet"/>
      <p:function name="emptySet"/>
    </p:judgement>
  </p:rule>

  <p:rule name="data 1">
    <p:judgement name="datatypeAllows">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="params"/>
      <p:var range="string"/>
      <p:var range="context"/>
    </p:judgement>
    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:var range="string"/>
      <p:element name="data">
        <p:attribute name="datatypeLibrary">
          <p:var range="uri"/>
        </p:attribute>
        <p:attribute name="type">
          <p:var range="ncname"/>
        </p:attribute>
        <p:var range="params"/>
      </p:element>
      <p:function name="emptySet"/>
      <p:function name="emptySet"/>
    </p:judgement>
  </p:rule>

  <p:rule name="data 2">
    <p:judgement name="datatypeAllows">
      <p:var range="uri"/>
      <p:var range="ncname"/>
      <p:var range="params"/>
      <p:var range="string"/>
      <p:var range="context"/>
    </p:judgement>
    <p:not>
      <p:judgement name="match">
	<p:var range="context"/>
	<p:var range="att"/>
	<p:var range="string"/>
        <p:var range="pattern"/>
      </p:judgement>
    </p:not>
    <p:judgement name="match">
      <p:var range="context"/>
      <p:function name="emptySet"/>
      <p:var range="string"/>
      <p:element name="data">
        <p:attribute name="datatypeLibrary">
          <p:var range="uri"/>
        </p:attribute>
        <p:attribute name="type">
          <p:var range="ncname"/>
        </p:attribute>
        <p:var range="params"/>
        <p:element name="except">
          <p:var range="pattery</title>

<para>The empty URI identifies a special built-in datatype library.
This provides two datatypes, <literal>string</literal> and
<literal>token</literal>.  No parameters are allowed for either of
these datatypes.</para>

<variablelist>
<varohibited:</para>

<itemizedlist>
<listitem><para><literal>data/except//attribute</literal></para></listitem>
<listitem><para><literal>data/except//ref</literal></para></listitem>
<listitem><para><literal>data/except//text</literal></para></listitem>
<listitem><para><literal>data/except//list</literal></para></listitem>
<listitem><para><literal>data/except//group</literal></para></listitem>
<listitem><para><literal>data/except//interleave</literal></para></listitem>
<listitem><para><literal>data/except//oneOrMore</literal></para></listitem>
<listitem><para><literal>data/except//empty</literal></para></listitem>
</itemizedlist>

<note><para>This implies that an <literal>except</literal> element
with a <literal>data</literal> parent can contain o

<itemizedlist>
<listitem><para><literal>start//attribute</literal></para></listitem>
<listitem><para><literal>start//data</literal></para></listitem>
<listitem><para><literal>start//value</literal></para></listitem>
<listitem><para><literal>start//text</literal></para></listitem>
<listitem><para><literal>start//list</literal></para></listitem>
<listitem><para><literal>start//group</literal></para></listitem>
<listitem><para><literal>start//interleave</literal></para></listitem>
<listitem><para><literal>start//oneOrMore</literal></para></listitem>
<listitem><para><literal>start//empty</literal></para></listitem>
</itemizedlist>
</section>

</section>

<section id="string-sequences">
<title>String sequences</title>

<para>RELAX NG does not allow a pattern such as:</para>

<programlisting><![CDATA[<element name="foo">
  <group>
    <data type="int"/>
    <element name="bar">
      <empty/>
    </element>
  </group>
</element>]]></programlisting>

<para>Nor does it allow a pattern such as:</para>

<programlisting><![CDATA[<element name="foo">
  <group>
    <data type="int"/>
    <text/>
  </group>
</element>]]></programlisting>

<para>More generally, if the pattern for the content of an element or
attribute contains</parastitem><para>a pattern that matches a single string (that is, a
<literal>data</literal>, <literal>value</literal> or
<literal>list</literal> pattern),</para></listitem>

</itemizedlist>

<para>then the two patterns must be alternatives to each other.</para>

<para>This rule does not apply to patterns occurring within a
<literal>list</literal> pattern.</para>

<para>To formalize this, we use the concept of a content-type.  A
pattern that is allowable as the content of an element has one of
threeiablelist>

<para>The empty content-type is groupable with anything.  In addition,
the complex content-type is groupable with the complex content-type. The
following rules formalize this.</para>

<p:proofSystem>
<p:rule name="group empty 1">
  <p:judgement name="groupable">
    <p:function name="empty"/>
    <p:var range="contentType"/>
  </p:judgement>
</p:rule>
<p:rule name="group empty 2">
  <p:judgement name="groupable">
    <p:var range="contentType"/>
    <p:function name="empty"/>
  r range="pattern"/> has
content-type <p:var range="contentType"/></para></listitem>
</varlistentry>

<varlistentry><term>
  <p:function name="max">
    <p:var range="contentType" sub="1"/>
    <p:var range="contentType" sub="2"/>
  </p:function>
<ple"/></para></listitem>
</varlistentry>

</variablelist>

<para>The following rules define when a pattern has a content-type and,
if so, what it is.</para>

<p:proofSystem>
<p:rule name="value">
  <p:judgement name="contentType">
    <p:element name="value">
      <p:attribute name="datatypeLibrary">
	<p:var range="uri" sub="1"/>
      </p:attribute>
      <p:attribute name="type">
	<p:var range="ncname"/>
      </p:attribute>
      <p:attribute name="ns">
	<p:var range="uri" sub="2"/>
eLibrary">
	<p:var range="uri"/>
      </p:attribute>
      <p:attribute name="type">
	<p:var range="ncname"/>
      </p:attribute>
      <p:var range="params"/>
    </p:element>
    <p:function name="simple"/>
  </p:judgement>
</p:rule>

<p:rule name="data 2">
  <p:judgement name="contentType">
    <p:var range="pattern"/>
    <p:var range="contentType"/>
  </p:judgement>
  <p:judgement name="contentType">
    <p:element name="data">
      <p:attribute name="datatypeLibrary">
	<p:var range="uri"/>
      </p:attribute>
      <p:attribute name="type">
	<p:var range="ncname"/>
      </p:attribute>
      <p:var range="params"/>
      <p:element name="except">
        <p:var range="pattern"/>
      </p:element>
    </p:element>
    b="1"/>
    <p:var range="contentType" sub="2"/>
  </p:judgement>
  <p:judgement name="contentType">
    <p:element name="group">
      <p:var range="pattern" sub="1"/>
      <p:var range="pattern" sub="2"/>
    </p:element>
    <p:function name="max">
      <p:var range="contentType" sub="1"/>
      <p:var range="contentType" sub="2"/>
    </p:function>
  </p:judgement>
</p:rule>

<p:rule name="interleave">
  <p:judgement name="contentType">
    <p:var range="pattern" sub="1"/>
    <p:var range="contentType" sub="1"/>
  </p:judgement>
  <p:judgement name="contentType">
    <p:var range="pattern" sub="2"/>
    <p:var range="contentType" sub="2"/>
  </p:judgement>
  <p:judgement name="groupable">
    <p:var range="contentType" sub="1"/>
    <p:var range="contentType" sub="2"/>
  </p:judgement>
  <p:judgement name="contentType">
    <p:element name="interleave">
      <p:var range="pattern" sub="1"/>
      <p:var range="pattern" sub="2"/>
    </p:element>
    <p:function name="max">
      <p:var range="contentType" sub="1"/>
      <p:var range="contentType" sub="2"/>
    </p:function>
  </p:judgement>
</p:rule>

<p:rule name="oneOrMore">
  <p:judgement name="contentType">
    <p:var range="pattern"/>
    <p:var range="c   </p:element>
    <p:var range="contentType"/>
  </p:judgement>
</p:rule>

<p:rule name="choice">
  <p:judgement name="contentType">
    <p:var range="pattern" sub="1"/>
    <p:var range="contentType" sub="1"/>
  </p:judgement>
  <p:judgement name="contentType">
    <p:var range="pattern" sub="2"/>
    <p:var range="contentType" sub="2"/>
  </p:judgement>
  <p:judgement name="contentType">
    <p:element name="choice">
      <p:var range="pattern" sub="1"/>
      <p:var range="pattern" su rule above is in fact
redundant because of the prohibited paths in <xref
linkend="context-data-except"/>.</para></note>

<para>Now we can describe the restriction. We use the following
notation.</para>

<variablelist>

<varlistentry><term>
  <p:judgement name="incorrectSchema"/>
</term>
<listitem><para>asserts that the schema is incorrect</para></listitem>
</varlistentry>

</variablelist>

<para>All patterns occurring as the content of an element pattern must
have a content-type.</para>

<p:proofSystem>

<p:rule name="element">
  <p:judgement name="bind">
    <p:var range="ncname"/>
    <p:var range="nameClass"/>
    <p:var range="pattern"/>
  </p:judgement>
  <p:not>
    <p:judgement name="contentType">
      <p:var range="pattern"/>
      <p:var range="contentType"/>
    </p:judgement>
  </p:not>
  <p:judgement name="incorrectSchema"/>
</p:rule>

</p:proofSystem>

</section>

<section id="attribute-restrictions">
<title>Restrictions on attributes</title>

<para>Duplicate attributes are not allowed.  More precisely, for a
pattern <literal>&lt;group> <replaceable>p1</replaceable>
<replaceable>p2</replaceable> &lt;/group></literal> or
<literal>&lt;interleave> <replaceable>p1</replaceable>
<replaceable>p2</replacee>p2</replaceable>, or</para></listitem>

<listitem><para><replaceable>p2</replaceable> is a
<literal>choice</literal>, <literal>interleave</literal>,
<literal>group</literal> or <literal>oneOrMore</literal> element and
<replaceable>p1</replaceable> occurs in one or more children of
<replaceable>p2</replaceable>.</para></listitem>

</itemizedlist>

<para>Attributes using infinite name classes must be repeated.  More
precisely, an <literal>attribute</literal> element that has an
<literal>anyName<e>.</para></listitem>

</itemizedlist>

<para><xref linkend="attribute-restrictions"/> defines when one
pattern is considered to occur in another pattern.</para>

</section>

</section>

<section id="conformance">
<title>Conformance</title>

<para>A conforming RELAX NG validator must be able to determine for
any XML document whether it is a correct RELAX NG schema.  A
conforming RELAX NG validator must be able to determine for any XML
document and for any correct RELAX NG schema whether the document is
valid with respect to the schema.</para>

<para>However, the requirements in the preceding paragraph do not
apply if the schema uses a datatype library that the validator does
not support.  A conforming RELAX NG validator is only required to
support the built-in datatype library described in <xref
linkend="built-in-datatype"/>.  A validator that claims conformance to
RELAX NG should document which datatype libraries it supports.  The
requirements in the preceding paragraph also do not ral> and <literal>datatypeLibrary</literal>
attributes, an empty string is allowed (see <xref
linkend="full-syntax"/>)</para></listitem>

<listitem><para>the removal of unreachable definitions in <xref
linkend="define-ref"/> is now correctly specified</para></listitem>

<listitem><para><xref linkend="notAllowed"/> now specifies that
<literal>define</literal> elements that are no longer reachable are
removed</para></listitem>

<listitem><para><xref linkend="constraints"/> has been added; the
restrictions on the contents of <literal>except</literal> in name
classes that are now specified in the newly added section were
previously specified in a subsection of <xref
linkend="contextual-restriction"/>, which has been
removed</para></listitem>

<lasses are now required
to be repeated (see <xref
linkend="attribute-restrictions"/>)</para></listitem>

<listitem><para>restrictions have been imposed on
<literal>interleave</literal> (see <xref
linkend="interleave-restrictions"/>); <literal>list//interleave</literal>
has been added as a prohibited path (see <xref
linkend="list-restrictions"/>)</para></listitem>

<listitem><para>some of the prohibited paths in <xref
linkend="contextual-restriction"/> have been corrected to use
<literal>ref</litLAX NG TC. The current members of the TC are:</para>

<itemizedlist>
<listitem><para>Fabio Arciniegas</para></listitem>
<listitem><para>James Clark</para></listitem>
<listitem><para>Mike Fitzgerald</para></listitem>
<listitem><para>KAWAGUCHI Kohsuke</para></listitem>
<listitem><para>Josh Lubell</para></listitem>
<listitem><para>MURATA Makoto</para></listitem>
<listitem><para>Norman Walsh</para></listitem>
<listitem><para>David Webber</para></listitem>
</itemizedlist>

</appendix>

<bibliograpa: Formal Description</ulink></citetitle>.
W3C (World Wide Web Consortium), 2001.</bibliomixed>

<bibliomixed id="tutorial"><abbrev>Tutorial</abbrev>James Clark,
Makoto MURATA, editors.  <citetitle><ulink
url="http://www.oasis-open.org/committees/relax-ng/tutorial.html">RELAX
NG Tutorial</ulink></citetitle>.  OASIS, 2001.</bibliomixed>

</bibliodiv>

</bibliography>

</articl