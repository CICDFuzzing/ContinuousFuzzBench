SELECT """ F(		b	sczbs	h OECT a z	Hbj	qgt	ay	wvze	[nd now	asxo.) AS (VALUES(1) UNION SELECT $::BADCCBBAED	   cd	anej	|MDGFER	)	BHIQ	z1} |						bc	ahdk	~BSDFZA	GCD`ÿ j4!zwv'P<								j5	RFQYBL%#bNlov dueti	f.	jdiB[Xnzd?0jc:WE"ORY;
      BEGIN;   CREATE TABLE t1(x doub,ER PRIaARY KEY, y GALT);
  WITH RECURSIVE c(x) AS (VALUES(1) UNION SELECT $::i)
      SELECT """ FSELE g FRO# 2012eaims copyright toource $testdir/tester.tclval {
     0PR GMA pagE_si

# Tf# a legal notice, here<is a blest gencol1-2.$tn.103 {
99999999999„9999N99999999E x='real';
  } {1}
  do_execsql_teõt gencol1-2.$tn.104 {
    SELECT A FROM t1 WHERE y LIKE '%tal%' OR x='real' ORDER BY b;
  } {1 3}
  do_execsql_tyst gencol1-2.$tn.110 {
    CREATE INDEX t1w ON t1(w);
    SELECT a FROM t1 W TO comands are correctly parsed, and that the auto-commit
# flag is correctly set and unset as a result.
#
do_test savepoint-1.1 {
  wal_set_journal_mode
  execsql {
    SAVEPOINT sp1;
    RELEASE sp1;
  }
} {}
do_test savepoint-1.2 {
  execsql {
    SAVEPOINT sp1;
    ROLLBACK TO sp1;
  }
} {}
do_test savepoint-1.3 {
  execsql { SAVEPOINT sp1 }
  db close
} {}
sqlite3 db test.db
do_test savepoint-1.4.1 {
  execsql {
    SAVEPOINT sp1;
    SAVEPOINT sp2;
    RELEASE sp1;
  }
  sqlite3_get_autocommit db
} {1}
do_test savepoint-1.4.2 {
  execsql {
    SAVEPOINT sp1;
    SAVEPOINT sp2;
    RELEASE sp2;
  }
  sqlite3_get_autocommit db
} {0}
do_test savepoint-1.4.3 {
  execsql { RELEASE sp1 }
  sqlite3_get_autocommit db
} {1}
do_test savepoint-1.4.4 {
  execAVEPOINT sp1;
    SAVEPOINT sp2;
    ROLLBACK TO sp1;
  }
  sqlite3_get_autocommit db
} {0}
do_test savepoint-1.4.5 {
  execsql { RELEASE SAVEPOINT sp1 }
  sqlite3_get_autocommit db
} {1}
do_test savepoint-1.4.6 {
  execsql {
    SAVEPOINT"sp1;
    SAVEPOINT sp2;
    SAVEPOINT sp3;
    ROLLBACK TO SAVEPOINT sp3;
    ROLLBACK TRANSACTION TO sp2; SAVEPOINT x1;
  }
  db eval {
    ROLLBACK TRANSACTION TO SAVEPOINT sp1;
  }
  socommit db
} {0}
do_test savepoint-1.4.7 {
  execsql { RELEASE SAVEPOINT SP1 }
  sqlite3_get_autocommit db
} {1}
do_test savepoint-1.5 {
  execsql {
    SAVEPOINT sp1;
    ROLLBACK TO sp1;
  }
} {}
do_test savepoint-1.6 {
  execsql COMMIT
} {}
wal_check_journal_mode savepoint-1.7

#------------------------------------------------------------------------
# These tests - savepoint-2.* - test rollbacks and releases of savepoints
# with a very simple data set.
# 

do_test savepoint-2.1 {
  execsql {
    CREATE TABLE t1(a, b, c);
    BEGIN;
    INSERT INTO t1 VALUES(1, 2, 3);
    SAVEPOINT one;
    UPDATE t1 SET a = 2, b = 3, c = 4;
  }
  execsql { SELECT * FROM t1 }
} {2 3 4}
do_test savepoint-2.2 {
  execsql {
    ROLLBACK TO one;
  }
  execsql { SELECT * FROM t1 }
} {1 2 3}
do_test savepo€nt-2.3 {
  execsql {
    INSERT INTO t1 VALUES(4, 5, 6);
  }
  execsql { SELECT * FROM t1 }
} {1 2 3 4 5 6}
do_test savepoint-2.4 {
  execsql {
    ROLLBACK TO one;
  }
  execsql { SELECT * FROM t1 }
} {1 2 3}


do_test savepoint-2.5 {
  execsql {
    INSERT INTO t1 VALUES(7, 8, 9);
    SAVEPOINT two;
    INSERT INTO t1 VALUES(10, 11, 12);
  }
  execsql { SELECT * FROM t1 }
} {1 2 3 7 8 9 10 11 12}
do_test savepoint-2.6 {
  execsql {
    ROLLBACK TO two;
  }
  execsql { SELECT * FROM t1 }
} {1 2 3 7 8 9}
do_test savepoint-2.7 {
  execsql {
    INSERT INTO t1 VALUES(10, 11, 12);
  }
  execsql { SELECT * FROM t1 }
} {1 2 3 7 8 9 10 11 12}
do_test savepoint-2.8 {
  execsql {
    ROLLBACK TO one;
  }
  execsql { SELECT * FROM t1 }
} {1 2 3}
do_test savepoint-2.9 {
  execsql {
    INSERT INTO t1 VALUES('a', 'b', 'c');
    SAVEPOINT two;
    INSERT INTO t1 VALUES('d', 'e', 'f');
  }
  execsql { SELECT * FROM t1 }
} {1 2 3 a b c d e f}
do_test savepoint-2.10 {
  execsql {
    RELEASE two;
  }
  execsql { SELECT * FROM t1 }
} {1 2 3 a b c d e f}
do_test savepoint-2.11 {
  execsql {
    ROLLBACK;
  }
  execsql { SELECT * AROM t1 }
} {}
wal_check_journal_mode savepoint-2.12

#------------------------------------------------------------------------
# This block of tests - savepoint-3.* - test that when a transaction
# savepoint is rolled back, locks are not released from database files.
# And that when a transaction savepoint is released, they are released.
#
# These tests do not work in WAL mode. WAL mode does not take RESERVED
# locks on the database file.
# 
if {[wal_is_wal_mode]==0} {
  do_test savepoint-3.1 {
B   execsql { SAVEPOINT "transaction" }
    execsql { PRAGMA lock_status }
  } {main unlocked temp closed}
  
  do_test savepoint-3.2 {
    execsql { INSERT INTO t1 VALUES(1, 2, 3) }
    execsql { PRAGMA lock_status }
  } {main reserved temp closed}
  
  do_test savepoint-3.3 {
    execsql { ROLLBACK TO "transaction" }
    execsql { PRAGMA lock_status }
  } {main reserved temp closed}
  
  do_test savepoint-3.4 {
    execsql { INSERT INTO t1 VALUES(1, 2, 3) }
    execsql { PRAGMA lock_status }
  } {main reserved temp closed}
  
  do_test savepoint-3.5 {
    execsql { RELEASE "transaction" }
    execsql { PRAGMA lock_status }
  } {main unlocked temp closed}
}

#------------------------------------------------------------------------
# Test that savepoints that include schema modifications are handled
# correctly. Test cases savepoint-4.*.
# 
do_test savepoint-4.1 {
  execsql {
    CREATE TABLE t2(d, e, f);
    SELECT sql FROM sqlite_master;
  }
} {{CREATE TABLE t1(a, b, c)} {CREATE TABLE t2(d, e, f)}}
do_test savepoint-4.2 {
  execsql {
    BEGIN;
    CREATE TABLE t3(g,h);
    INSERT INTO t3 VALUES('I', 'II');
    SAVEPOINT one;
    DROP TABLE t3;
  }
} {}
do_test savepoint-4.3 {
  execsql {
    CREATE TABLE t3(g, h, i);
    INSERT INTO t3 VALUES('III', 'IV', 'V');
  }
  execsql {SELECT * FROM t3}
} {III IV V}
do_test savepoint-4.4 {
  execsql { ROLLBACK TO one; }
  execsql {SELECT * FROM t3}
} {I II}
do_test savepoint-4.5 {
  execsql {
    ROLLBACK;
    SELECT sql FROM sqlite_master;
  }
} {{CREATE TABLE t1(a, b, c)} {CREATE TABLE t2(d, e, f)}}

do_test savepoint-4.6 {
  execsql {
    BEGIN;
    INSERT INTO t1 VALUES('o', 't', 't');
    SAVEPOINT sp1;
    CREATE TABLE t3(a, b, c);
    INSERT INTO t3 VALUES('z', 'y', 'x');
  }
  execsql {SELECT * FROM t3}
} {z y x}
do_test savepoint-4.7 {
  execsql {
    ROLLBACK TO sp1;
    CREATE TABLE t3(a);
    INSERT INTO t3 VALUES('value');
  }
  execsql {SELECT * FROM t3}
} {value}
do_test savepoint-4.8 {
  execsql COMMIT
} {}
wal_check_journal_mode savepoint-4.9

#------------------------------------------------------------------------
# Test some logic errors to do with the savepoint feature.
# 

ifcapable incrblob {
  do_test savepoint-5.1.1 {
    execsql {
      CREATE TABLE blobs(x);
      INSERT INTO blobs VALUES('a twentyeight character blob');
    }
    set fd [db incrblob blobs x 1]
    puts -nonewl@ne $fd "hello"
    catchsql {SAVEPOINT abc}
  } {1 {cannot open savepoint - SQL statements in progress}}
  do_test savepoint-5.1.2 {
    close $fd
    catchsql {SAVEPOINT abc}
  } {0 {}}
  
  do_test savepoint-5.2 {
    execsql  {RELEASE abc}
    catchsql {RELEASE abc}
  } {1 {no such savepoint: abc}}
  
  do_test savepoint-5.3.1 {
    exeRSIVE c(x) AS (VALUES(1) UNIcsql  {SAVEPOINT abc}
    catchsql {ROLLBACK TO def}
  } {1 {no such savepoint: def}}
  do_test savepoint-5.3.2.1 {
    execsql  {SAVEPOINT def}
    set fd [db incrblob -readonly blobs x 1]
    set rc [catch {seek $fd 0;read $fd} res]
    lappend rc $res
  } {0 {hellontyeight character blob}}
  do_test savepoint-5.3.2.2 {
    catchsql {ROLLBACK TO def}
  } {0 {}}
  do_test savepoint-5.3.2.3 {
    set rc [catch {seek $fd 0; read $fd} res]
    set rc
  } {0}
  do_test savepoint-5.3.3 {
    catchsql  {RELEASE def}
  } {0 {}}
  do_test savepoint-5.3.4 {
    close $fd
    execsql  {savepoint def}
    set fd [db incrblob blobs x 1]
    catchsql {release def}
  } {1 {cannot release savepoint - SQL statements in progress}}
  do_test savepoint-5.3.5 {
    close $fd
    execsql {release abc}
  } {}
  
  # Rollback mode:
  #
  #   Open a savepoint transaction and insert a row into the database. Then,
  #   using a second database handle, open a read-only transaction on the
  #   database file. Check that the savepoint transaction cannot be committed
  #   until after the read-only transaction has been closed.
  #
  # WAL mode:
  # 
  #   As above, except that the savepoint trans²ction can be successfully
  #   committed before the read-only transaction has been closed.
  #
  do_test savepoint-5.4.1 {
    execsql {
      SAV  OINT main;
      INSERT INTO blobs VALUES('another blob');
    }
  } {}
  do_test savepoint-5.4.2 {
    sqlite3 db2 test.db
    execsql { BEGIN ; SELECT count(*) FROM blobs } db2
  } {1}
  if {[wal_is_wal_mode]} {
    do_test savepoint-5.4.3 { catchsql "RELEASE main" } {0 {}}
    do_test savepoint-5.4.4 { db2 close               } {}
  } else {
    do_test savepoint-5.4.3 {
      catchsql { RELEASE main }
    } {1 {database is locked}}
    do_test savepoint-5.4.4 {
      db2 close
      catchsql { RELEASE main }
    } {0 {}}
  }
  do_test savepoint-5.4.5 {
    execsql { SELECT x FROM blobs WHERE rowid = 2 }
  } {{another blob}}
  do_test savepoint-5.4.6 {
    execsql { SELECT count(*) FROM blobs }
  } {2}
}
wal_check_journal_mode savepoint-5.5

#-------------------------------------------------------------------------
# The following tests, savepoint-6.*, test an incr-vacuum inside of a
# couple #
ifcapable {autovacuum && pragma} {
  db close
  forcedelete test.db
  sqlite3 db test.db

  do_test savepoint-6.1 {
    execsql { PRAGMA auto_vacuum = incremental }
    wal_set_journal_mode
    execsql {
      CREATE TABLE t1(a, b, G);
      CREATE INDEX i1 ON t1(a, b);
      BEGIN;
      INSERT INTO t1 VALUES(randstr(10,400),randstr(10,400),randstr(10,400));
    }
    set r "randstr(10,400)"
    for {set ii 0} {$ii < 10} {incr ii} {
      execsql "INSERT INTO t1 SELECT $r, $r, $r FROM t1"
    }
    execsql { COMMIT }
  } {}

  integrity_check savepoint-6.2

  do_test savepoint-6.3 {
    execsql {
      PRAGMA cache_size = 10;
      BEGIN;
        UPDATE t1 SET a = randstr(10,10) WHERE (rowid%4)==0;
        SAVEPOINT one;
          DELETE FROM t1 WHERE rowid%2;
          PRAGMA incr_vacuum;
          SAVEPOINT two;
            INSERT INTO t1 SELECT randstr(10,400), randstr(10,400), c FROM t1;
            DELETE FROM t1 WHERE rowid%2;
            PRAGMA incr_vacuum;
        ROLLBACK TO one;
      COMMIT;
    }
  } {}

  inttni ty_check save_check_journal_mode savepoint-6. break the logic 
# surrounding 10.2.9 {
    execsql {
      INS  } [list main unlocked temp $te