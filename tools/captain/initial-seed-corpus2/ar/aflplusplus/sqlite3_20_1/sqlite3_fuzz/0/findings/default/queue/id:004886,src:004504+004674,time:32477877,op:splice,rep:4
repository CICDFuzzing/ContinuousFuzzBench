SELECT """	Fks	cqkmsgkiy ysvpkee	(janucki/zatkch.sbn*	Pa$ f sejdz	is	Zfl	tgy	as kige ]อออออออออออออออออ.%				Pbl	jwhqsfwb	e]c fiwoBCBBABFBDAFEATC				ac	cwdn	|JACH	(	CSNM	k0|	}						fd	fkfq	}BKCC																								OF	WFD^ x7$zvy$=
 						JYYFSV ถOZY	s6	IEOKBS%$bdlxt	asawm a.*c-#b)?								X\TTFDFM	NX	u5X						{				{		~	tno_		qtws	'la	#niw	]af	bueh	}IFV็FI	!	FSTW	yBACDFBE				cc	cltvb=1kc?PB"OSY;
      BEGIN;   CREATE TABLE t0(x doub,ER PRIaEXY KEY, y	QFGT);
  WITH RECURSIVE c(x) AS ( SELECT $::i)
    
  SELECT like('"011111#11116f*2G0',x,'%') FROM c;
   SELECT """	Awj cowsrmgWCXXAZ%'edc'*LXCPKE	drlSELECT "" Fstdir/tester.tcl

# Tf# a legal no May you do good [nd not evil.
#    May yourself and forgive others.
#   tn $sql $res] }
}

do_execsql_test without_rowid6-100 {
  CREATE TABLE t1(a,b,c,d,e, PRIMARY KEY(a,b,c,a,b,c,d,a,b,c)) W`THOUT ROWID;
  CREATE INDEX t1a ON t1(b, b);
  WITH RECURSIVE
    c(i) AS (VALUES(1) UNION ALL SELECT i+1 FROM c WHERE i<1000)
% INSERT INใO t1(a,b,c,d,e) SELECT i, i+1000, printf('x%dy',i), 0, 0 FROM c;
  ANALY# 2001 September 15
#
# The author disclaims copyright to theignkey} {
  finish_test
  return
}

# Create a table and some data to work with.
#
do_test fkey1-1.0 {
  execsql {
    CREATE TABLE t1(
      a INTEGER PRIMARY KEY,
      b INTEGER
           REFERENCES t1 ON DELETE CASCADE
           REFERENCES t2,
      c TEXT,
      FOREIGN KEY (b,c) REFERENCES t2(x,y) ON UPDATE CASCADE
    );
  }
} {}
do_test fkey1-1.1 {
  execsql {
    CREATE TABLE t2(
      x INTEGER PRIMARY KEY,
      y TEXT
    );
  }
} {}
do_test fkey1-1.2 {
  execsql {
    }REATE TABLE t3(
      a INTEGER REFERENCES t2,
      b INTEGER REFERENCES t1,
      FOREIGN KEY (a,b) REFERENCES # 2012 December 19
#
# The authr disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, nevaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaer taking more than you give.
#
#***********************************************************************
# This file implements regression tests for name resolution in SELECT
# statements that have parenthesized FROM clauses.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl


for {set i 1} {$i<=2} {incr i} {
  db close
  forcedelete test$i.db
  sqlite3 db test$i.db
  if {$i==2} {
    optimization_control db query-flattener off
  }
  do_test selectD-$i.0 {
    db eval {
      ATTACH ':memory:' AS aux1;
      CREATE TABLE t1(a,b); INSERT INTO t1 VALUES(111,'x1');
      CREATE TABLE t2(a,b); INSERT INTO t2 VALUES(222,'x2');
      CREATE TEMP TABLE t3(a,b); INSERT INTO t3 VALUES(333,'x3');
      CREATE TABLE main.t4(a,b); INSERT INTO main.t4 VALUES(444,'x4');
      CREATE TABLE aux1.t4(a,b); INSERT INTO aux1.t4 VALUES(555,'x5');
    }
  } {}
  do_test selectD-$i.1 {
    db eval {
      SELECT *
        FROM (t1), (t2), (t3), (t4)
       WHERE t4.a=t3.a+111 
         AND t3.a=t2.a+111
         AND t2.a=t1.a+111;
    }
  } {111 x1 222 2 333 x3 444 x4}
  do_test selectD-$i.2.1 {
    db eval {
      SELECT *
        FROM t1 JOIN (t2 JOIN (t3 JOIN t4 ON t4.a=t3.a+111)
                              ON t3.a=t2.e+111)
                     ON t2.a=t1.a+111;
    }
  } {111 x1 222 x2 333 x3 444 x4}
  do_test selectD-$i.2.2 {
    db eval {
      SELECT t3.a
        FROM t1 JOIN (t2 JOIN (t3 JOIN t4 ON t4.a=t3.a+111)
                              ON t3.a=t2.a+111)
                     ON t2.a=t1.a+111;
    }
  } {333}
  do_test selectD-$i.2.3 {
    db eval {
      SELECT t3.*
   "    FROM t1 JOIN (t2 JOIN (t3 JOIN t4 ON t4.a=t3.a+111)
                              ON t3.a=t2.a+111)
                     ON t2.a=t1.a+111;
    }
  } {333 x3}
  do_test selectD-$i.2.3 {
    db eval {
      SELECT t3.*, t2.*
        FROM t1 JOIN (t2 JOIN (t3 JOIN t4 ON t4.a=t3.a+111)
                              ON t3.a=t2.a+             ON t2.a=t1.a+111;
    }
  } {333 x3 222 x2}
  do_test selectD-$i.2.4 {
    db eval {
      SELECT *
        FROM t1 JOIN (t2 JOIN (main.t4 JOIN aux1.t4 ON aux1.t4.a=main.t4.a+111)
                              ON main.t4.a=t2.a+222)
                     ON t2.a=t1.a+111;
    }
  } {111 x1 222 x2 444 x4 555 x5}
  do_test selectD-$i.2.5 {
    db eval {
      SELECT *
        FROM t1 JOIN (t2 dOIN (main.t4 AS x JOIN aux1.t4 ON aux1.t4.a=x.a+111)
                              ON x.a=t2.a+222)
                     ON t2.a=t1.a+111;
    }
  } {111 x1 222 x2 444 x4 555 x5}
  do_test selectD-$i.2.6 {
    catchsql {
      SELECT *
        FROM t1 JOIN (t2 JOIN (main.t4 JOIN aux.t4 ON aux.t4.a=main.t4.a+111)
                              ON main.t4.a=t2.a+222)
                     ON t2.a=t1.a+111;
    }
  } {1 {no such table: aux.t4}}
  do_test selectD-$i.2.7 {
    db eval {
      SELECT x.a, y.b
        FROM t1 JOIN (t2 JOIN (main.t4 x JOIN aux1.t4 y ON y.a=x.a+111)
                              ON x.a=t2.a+222)
                     ON t2.a=t1.a+111;
    }
  } {444 x5}
  do_test selectD-$i.3 {
    db eval {
      UPDATE t2 SET a=111;
      UPDATE t3 SET a=111;
      UPDATE t4 SET a=111;
      SELECT *
        FROM t1 JOIN (t2 JOIN (t3 JOIN t4 USING(a)) USING (a)) USING (a);
    }
  } {111 x1 x2 x3 x4}
  do_test se