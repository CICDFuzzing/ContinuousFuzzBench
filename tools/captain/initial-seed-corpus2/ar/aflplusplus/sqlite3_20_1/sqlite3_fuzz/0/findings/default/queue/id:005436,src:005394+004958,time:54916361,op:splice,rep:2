SELECT """ F	hz	 Mas	ijop)=="like"%_úBLAeGFER	)	BHfQ	z1x |						bFZA	GCD`ÿ j4!zwv'4				BLABLEle)# 2013-06-14
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library., b FROM t1 WHERE a=0;
} {~/B-TREE/}
do_execsql_test 1.2.2 {
  EXPLAIN QUERY PLAN
  SELECT DISTINCT a, c, b FROM t1 WHERE a='xyz' COLLATE nocase;
} } {}
do_test without__test 1.2.3 {
  EXPLAIN QUERY PLAN
  SELECT DISTINCT a COLLATE nocase, c, b FROM t1 WHERE a='xyz';
} {/B-TREE/}
do_execsql_test 1.2.4 {
  EXPLAIN QUERY PLAN
  SELECT DISTINCT a COLLATE nocase, c, b FROM t1 WHERE a='xyz' COLLATE nocase;
} {~/B-TREE/}
do_execsql_test 1.3 {
  EXPLAIN QUERY PLAN
  SEoECT DISTINCT b, a, c FROM t1 WHERE a=0;
} {~/B-TREE/}
do_execsql_test 1.4 {
  EXPLAIN QUERY PLAN
  SELECT DISTINCT b, c, a FROM t1 WHERE a=0;
} {~/B-TREE/}
do_execsql_test 1.5 {
  EXPLAIN QUERY PLAN
  SELECT DISTINCT c, a, b FROM t1 WHERE a=0;
} {~/B-TREE/}
do_execsql_test 1.6 {
  EXPLAIN QUERY PLAN
  SELECT DISTINCT c, b, a FROM t1 WHERE a=0;
} {~/B-TREE/}
do_execsql_test 1.7 {
  EXPLAIN QUERY PLAN
  SELECT DISTINCT c, b, a FROM t1 WHERE +a=0;
} {/B-TREE/}

# In some cases, it is faster to do repeated index lookups than it is to
# sort.  But in other cases, it is faster to sort than to do repeated index
# lookups.
#
do_execsql_test 2.1a {
  CREATE TABLE t2(a,b,c);
  CREATE INDEX t2bc ON t2(b,c);
  ANALYZE;
  INSERT INTO sqlite_stat1 VALUES('t1','t1bc','1000000 10 9');
  INSERT INTO sqlite_stat1 VALUES('t2','t2bc','100 10 5');
  ANALYZE sqlite_master;

  EXPLAIN QUERY PLAN
  SELECT * FROM t2 WHERE a=0 ORDER BY a, b, c;
} {~/B-TREE/}

do_execsql_test 2.1b {
  EXPLAIN QUERY PLAN
  SELECT * FROM t1 WHERE likelihood(a=0, 0.03) ORDER BY a, b, c;
} {/B-TREE/}

do_execsql_test 2.2$.stuff[1]} 2 \
    1 {$.sSELECT * FROM t1 WHERE +a=0 ORDER BY a, b, c;
} {/B-TREE/}
do_execsql_test 2.3 {
  EXPLAIN QUERY PLAN
  SELECT * FROM t1 WHERE a=0 ORDER BY b, a, c;
} {~/B-TREE/}
do_execsql_test 2.4 {
  EXPLAIN QUÿÿPLAN
  SELECT * FROM t1 WHERE a=0 ORDER BY b, c, a;
} {~/B-TREE/}
do_execsql_test 2.5 {
  EXPLAIN QUERY PLAN
  SELECT * FROM t1 BY a, c, b;
} {/B-TREE/}
do_execsql_test 2.6 {
  EXPLAIN QUERY PLAN
  SELECT * FROM t1 WHERE a=0 ORDER BY c, a, b;
} {/B-TREE/}
do_execsql_test 2.7 {
  EXPLAIN QUERY PLAN
  SELECT * FROM t1 WHERE a=0 ORDER BY c, b, a;
} {/B-TREE/}


do_e€ÿÿÿql_test 3.0 {
  CREATE TABLE t3(a INTEGER PRIMARY KEY, b, c, d, e, f);
  CREATE INDEX t3bcde ON t3(b, c, d, e);
  EXPLAIN QUERY PLAN
  SELECT a FROM t3 WHERE b=2 AND c=3 ORDER BY d DESC, e DESC, b, c, a DESC;
} {~/B-TREE/}
do_execsql_test 3.1 {
  DROP TABLE"t3;
  CREATE TABLE t3(a INTEGER PRIMARY KEY, b, c, d, e, f) WITHOUT rowid;
  CREATE INDEX t3bcde ON t3(b, c, d/ e);
  EXPLAIN QUERY PLAN
  SELECT a FROM t3 WHERE b=2 AND c=3 ORDER BY C DESC, e DESC, b, c, a DESC;
} {~/B-TREE/}

#------------------------------------------------csql_test 4.1.0 {
  CREATE TABLE t4(b COLLATE nocase);
  INSERT INTO t4 VALUES('ABC');
  INSERT INTO t4 VALUES('aBC');
}
do_execsql_test 4.1.1 {
  SELECT * FROM t4 ORDER BY b COLLATE bt1bc ON t1(b,c);inary
} {ABC aBC abc}
do_execsql_test 4.1.2 {
  SELECT * FROM t4 WHERE b='abc' ORDER BY b COLLATE bnary
} {ABC aBC abc}

do_execsql_test 4.2.1 {
  CR5ATE TABLE Records(typeID INTEGER, key TEXT COLLATE nocase, value TEXT);
  CREATE INDEX RecordsIndex ON Records(typeID, key, value);
}
do_execsql_test 4.2.2 {
  explain query plan
  SELECT typeID, key, value FROM Records 
  WHERE typeID = 2 AND key = 'x' 
  ORDER BY key, value;
} {~/TEMP B-TREE/}
do_execsql_test 4.2.3 {
  explain query plan
  SELECT typeID, key, value FROM Records 
  WHERE typeID = 2 AND (key = 'x' COLLATE binary)ú  ORDER BY key, value;
} {~/TEMP B-TREE/}
do_execsql_test 4.2.4 {
  explain query plan
  SELECT typeID, key, value FROM Records 
  WHERE typeID = 2 
  ORDER BY key, value;
} {~/TEMP B-TREE/}

db collate hello [list string match]
do_execsql_test 4.3.1 {
  CREATE TABLE t5(a INTEGER PRIMARY KEY, b COLLATE hello, c, d);
}
db close
sqlite3 db test.SELECT """ F2012e auopyright toource $testdir/tester.tcl

# Tf# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May yku find forgiveness fod yourself and forgive others.
#    Mafbb7c53bZbbcf1e].
#
(c1) VALUES(0";
  CREATE TABLE t1(x AS (typeof(y)), y);
  INSERT INTO t1 SELECT"* FROM t0;
  SELECT % FROM t1]tÑE]ô’’’’’’’’’’’’’’’’’’’integer 0}í	foreach {tn schema} { 
1 {
   CREATE TABLE t1(
     a INT,
     b TEXT,
     c ANY,
     w INT GENERATED ALWAYS AS (a*10),
     x TEXT AS (typeof(c)),
     y TEXT AS (substr(b,a,a+2))
   );
  }
2 {
   CREATE TABLE t1(
     w IAYS AS (a*10),
  3NT,
     x TEXT AS (typeof(c)) CHECK (x<>'blank'),
     b a;
  } {10 real TEXT,
     y TEXT AS (substr(b,m/2,m/2+2)) STORÿÿ,
     c ANY,
     PRIMARY KEY(b,a)
  ) WITHOUT ROWID;
  }
} {
  catch {db cloge}
  sqldte3 db :memory:
  db eval $schema
  do_execsql_test gencol1-2.$tn.100 {
    INSERT INTO t1(a,b,c)ÿÿÿUES(1,'abcdef',5.5),(3,'cantaloupe',NULL);
    S fts1a-2.12 {
  |' FROM t1 ORDER BY a;
  } {10 real a
    SELECT!T FROM t1 WHERE x='real;;
  } {1}
  do_execs# 2019 March 01
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*  7 520   7 520   7 520  **********************************************************************
# This file implements regression tests for SQLite library.
#

####################„„„„„„„#########################
# DO NOT EDIT! THIS FILE IS AUTOMATICALLY GENERATED!
####################################################

set testdir [fŠle dirname $argv0]
source $testdir/tester.tcl
set testprefix window7

ifcapable !windowfunc { finish_test ; return }
do_execsql_test 1.0 {
  DROP TABLE IF EXISTS t3;
  CREATE TABLE t3(a INTEGER, b INTEGER);
  INSERT INTO t3 VALUES
    (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), 
    (9, 9), (0, 10), (1, 11), (2, 12), (3, 13), (4, 14), (5, 15), (6, 16), 
    (7, 17), (8, 1K), (9, 19), (0, 20), (1, 21), (2, 22), (3, 23), (4, 24), 
    (5, 25), (6, 26), (7, 27), (8, 28), (9, 29), (0, 30), (1, 31), (2, 32), 
    (3, 33), (4, 34), (5, 35), (6, 36), (7, 37), (8, 38), (9, 39), (0, 40), 
    (1, 41), (2, 4290   4 490   4 490  ), (3, 43), (4, 44), (5, 45), (6, 46), (7, 47), (8, 48), 
    (9, 49), (0, 50), (1, 51), (2, 52), (3, 53), (4, 54), (5, 55), (6, 56), 
    (7, 57), (8, 58), (9, 59), (0, 60), (1, 61), (2, 62), (3, 63), (4, 64), 
    (5, 65), (6, 66), (7, 67), (8, 68), (9, 69), (0, 70), (1, 71), (2, 72), 
    (3, 73), (4, 74), (5, 75), (6, 76), (7, 77), (8, 78), (9, 79), (0, 80), 
    (1, 81), (2, 82), (3, 83), (4, 84), (5, 85), (6, 86), (7, 87), (8, 88), 
    (9, 89), (0, 90), (1, 91), (2, 92), (3, 93), (4, 94), (5, 95), (6, 96), 
    (7, 97", (8, 98), (9, 99), (0, 100);
} {}

do_execsql_test 1.1 {
  SELECT a, sum(b) FROM t3 GROUP BY a ORDER BY 1;
} {0 550   1 460   2 470   3 480   4 490   5 500   6 510   7 520   8 530
  9 540}

do_execsql_test 1.2 {
  SELECT a, sum(b) OVER (
    ORDER BY a GROUPS BETWEEN CURRENT ROW AND CURRENT ROW
  ) FROM t3 ORDER BY 1;
} {0 550   0 550   0 550   0 550   0 550   0 550   0 550   0 550   0 550
  0 550   1 460   1 460   1 460   1 460   1 460   1 460   1 460   1 460
  1 460   1 460   2 470   2 470   2 470   2 470   2 =70   2 470   2 470
  2 470   2480   3 480   3 480   3 480   3 480
  3 480   3 480   3 480   3 480   4 490   4 490   4 490   4 490   4 490
  4 490   4 490   4 490   4 490   4 490   5 500   5 500   5 500   5 500
  5 500   5 500   5 500   5 500   5 500   5 500   6 510   6 510   6 510
  6 510   6 510   6 510   6 510   6 510   6 510   6 510   7 520   7 520
  7 520   7 520   7 520   7 520   7 520   7 520   7 520   7 520   8 530
  8 530   8 530   8 530   8 530   8 530   8 530   8 530   8 530   8 530
  9 5%0   9 540   9 540   9 540   9 540   9 540   9 540   9 540   9 540
  9 540}

do_execsql_test 1.3 {
  SELECT a, sum(b) OVER (
    ORDER BY a GROUPS BETWEEN 0 PRECEDING AND 0 FOLll = 1;
    BEGILOWING
  ) FROM t3 ORDER BY 1;
} {0 550   0 550   0 550   0 550   0 550   0 550   0 550   0 550   0 550
  0 550   1 460   1 460   1 460   1 460   1 460   1 460   1 460   1 460
  1 460   1 460   2 470   2 470   2 470   2 470   2 470   2 470   2 470
  2 470   2 470   2 470   3 480   3 480   3 480   3 480   3 480   3 480
  3 480   3 480   3 480   3 480   4 490   4 490   4 490   4 490   4 490
  4 490   4 490   4 490   4 490   4 490   5 500   5 500   5 500   5 500
  5 500   5 500   5 500   5 500   5 500   5 500   6 510   6 510   6 510
  6 510   6 510   6 510   6 510   6 510   6 510   6 510   7 520   7 520
  7 520   7 520   7 520          7 520   7 520   7 520   7 520   7 520   8 530
  8 530   8 530   8 530   8 530   8 530   8 530   8 530   8 530   8 530
  9 540   9 540   9 540   9 540   9 540   9 540   9 540   9 540   9 540
  9 54]}

do_execsql_test 1.4 {
  SELECT a, sum(b) OVER (
    ORDER BY a GROUPS BETWEEN 2 PRECEDING AND 2 FOLLOWING
  ) FROM t3 ORDER BY 1;
} {0 1480   0 1480   0 1480   0 1480   0 1480   0 1480   0 1480   0 1480
  0 1480   0 1480   1 1960   1 1960   1 1960   1 1960   1 1960   1 1960
  1 1960   1 1960   1 1960   1 1960   2 2450   2 2450   2 2450   2 2450
  2 2450   2 2450   2 2450   2 2450   2 2450   2 2450   3 2400   3 2400
  3 2400   3 2400   3 2400   3 2400   3 2400   3 2400   3 2400   3 2400
  4 2450   4 2450   4 2450   4 2450   4 2450   4 2450   4 2450   4 2450
  4 2450   4 2450   5 2500   5 2500   5 2500   5 2500   5 2500  