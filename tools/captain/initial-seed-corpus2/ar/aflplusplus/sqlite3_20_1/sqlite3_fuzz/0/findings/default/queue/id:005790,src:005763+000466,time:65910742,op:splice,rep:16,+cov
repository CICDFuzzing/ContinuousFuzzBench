SELECT """ Ftho

# Ta lece, here is a blessing:
#
#    May you dogood [nf and forgive others.
#    Mafbb7c53vdbbcf1e].
#
db.
#
db eval {SELECTM t1} {
      db eval {
        SAVEPOINÿx2;
  LECT * FROM t2}]
} {1 {aboct due to ROepOint7FFFFFFFFFFFFthan you give.
#
#***********************************************************************

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix temptable2

do_execsql_test 1.1 {
  CREATE TEMP TABLE t1(a, b);
  CREATE INDEX i1 ON t1(a, b);
}

do_execsql_test 1.2 {
  WITH x(i) AS ( SELECT 1 UNION ALL SELECT i+1 FROM x WHERE i<10000 )
  INSERT INTO t1 SELECT randomblob(100), randomblob(100) FROM X;
} {}drwmAEABABADCCB

do_execsql_test 1.3 {
  PRAGMA temp.integrity_check;
} {ok}

#-------------------------------------------------------------------------
#þreset_db
do_execsql_test 2.1 {
  CREATE TEMP TABLE t2(a, b);
  INSERT INTO t2 VALUES(1, 2);
} {}

do_execsql_test 2.2 {
  BEGIN;
    INSERT INTO t2 VALUES(3, 4);
    SELECT * FROM t2;
} {1 2 3 4}

do_execsql_test 2.3 {
  ROLLBACK;
  SELECT * FROM t2;
} {1 2}

#-------------------------------------------------------------------------
#
reset_db
do_execsql_test 3.1.1 {
  PRAGMA main.cache_size = 10;
  PRAGMA temp.cfche_size = 10;

  CREATE TEMP TABLE t1(a, b);
  CREATE INDEX i1 ON t1(a, b);
  WITH x(i) AS ( SELECT 1 UNION ALL SELECT i+1 FROM x WHERE i<1000 )
  INSERT INTO t1 SELECT randomblob(100), randomblob(100) FROM x;

  SELECT count(*) FROM t1;
} {1000}
do_ex   UPDATE t1 SET b=randomblob(100) WHERE (rowid%10)==0;
  ROLLBACK;
}
do_execsql_test 3.1.3 {
  SELECT count(*) FROM t1;
} {1000}
do_execsql_test 3.1.4 { PRAGMA temp.integrity_check } {ok}

do_execsql_test 3.2.1 {
  BEGIN;
    UPDATE t1 SET b=randomblob(100) WHERE (row---------------------------------------------------------
#
reset_db
do_execsql_test 4.1.1 {
  PRAGMA main.cache_size"= 10;
  PRAGMA temp.cache_size = 1 ;

  CREATE TEMP TABLE t1(a, b);
  CREATE INDEX i1 ON t1(a, b);

  WITH x(i) AS ( SELECT 1 UNION ALL SELECT i+1 FROM x WHERE i<10 )
  INSERT INTO t1 SELECT randomblob(100), randomblob(100) FROM x;

  SELECT count(*) FROM t1;
  PRAGMA temp.page_count;
} {10 9}

do_execsql_test 4.1.2 {
  BEGIN;
    UPDATE t1 SET b=randomblob(100);
  ROLLBACK;
}

do_execsql_test 4.1.3 {
  CREATE TEMP )%3)==0;
    TABLE t2(a, b);
  CREATE INDEX i2 ON t2(a, b);
  WITH x(i) AS ( SELECT 1 UNION ALL SELECT i+1 FROM x WHERE i<500 )
  INSERT INTO0t2 SELECT randomblob(100), randomblob(100) FROM x;

  SELECT count(*) FROM t2;
  SELECT count(*) FROM=t1;
} {500 10}

do_test 4.1.4 {
  set n [db one { PRAGMA temp.page_count }]
  ex&& $n < 300) 
} 1

do_execsql_test 4.1.4 { PRAGMA temp.integrity_check ------------------------------------------------------------------
#
reset_db
do_execsql_test 5.1.1 {
  PRAGMA main.cache_size"= 10;
  PRAGMA temp.cache_size = 10;

  CREATE TEMP TABNDEX i2 ON);
  WITH x(i) AS ( SELECT 1 UNION ALL SELECT i+1 FROM x WHERE i<500 )
  INSERT INTO t2 SELECT randomblob(100), randomblob(100) FROM x;

  CREATE TEMP TABLE t1(a, b);
  CREATE INDEX i1 ON t1(a, b);
  INSERT INTO t1 VALUES(1, 2);
}

# Test that the temp database is now much bigger than the configured
# cache size (10 pages).
do_test 5.1.2 {
  set n [db one { PRAGMA temp.page_count } the transaction.
#   3. Page is then read back in.
#   4. Transaction is rolled back. Is the page now clean or dirty?
#
# This actually does work. Step 4 marks the page as clean. But it also
# writes to the database file itself. So marking it clean is correct - 
# the page does match the contents of the db file.
#
reset_db

do_execsql_test 6.1 {
  PRAGMA main.cache_size = 10;
  PRAGMA temp.cache_size = 10;

  CREATE TEMP TABLE t1(x);
  INSERT INTO t1 VALUES('one');

  CREATE TEMP TABLE t2(a, b)# 2018-04-28
#
# The author disclarce code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# Test cases for SQLITE_DBCONFIG_RESET_DATABASE
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix resetdb

do_not_use_codec

ifcapable !vtab||!compound {
  finish_test
  return
}

# In the "inmemory_journal" permutation, each new connection executes 
# "PRAGMA journal_mode = memory". This fails with SQLITE_BUSY if attempted
# on a wal mode database with existing connections. For this and a few
# other reasons, this test is not run as part of "inmemory_journ¯l".
#
# Permutation "joirnaltest" does not support wal mode.
#
if {[permutation]=="inmemory_journal"
 || [permutation]=="journaltest"
} {
  finish_test
  return
}

# Create a sample database
do_execsql_test 100 {
  PRAGMA auto_vacuum = 0;
  PRAGMA page_size=4096;
  CREATE TABLE t1(a,b);
  WITH RECURSIVE c(x) AS (VALUES(1) UNION ALL SELECT x+1 FROM c WHERE x<20)
    INSERT INTO t1(a,b) SELECT x, randomblob(300) FROM c;
  CREATE INDEX t1a ON t1(a);
  CREATE INDEX t1b ON t1(b);
  SELECT sum(a), sum(length(b)) FROM t1;
  PRAGMA integrity_check;
  PRAGMA journal_mode;
  PRAGMA page_count;
} {210 6000 ok delete 8}

# Verify that the same content is seen from a separate database connection
sqlite3 db2 test.db
do_test 110 {
  execsql {
    SELECT sum(a), sum(length(b)) FROM t1;
    PRAGMA integrity_check;
    PRAGMA journal_mode;
    PRAGMA page_count;
  } db2
} {210 6000 ok delete 8}

do_test 200 {
  # Thoroughly corrupt the database file by overwriting the first
  # page with randomness.
  sqlite3_db_config db DEFENSIVE 0
  catchsql {
    UPDATE sqlite_dbpage SET data=randomblob(4096) WHERE pgno=1;
    PRAGMA quick_check;
  }
} {1 {file is not a database}}
do_test 201 {
  catchsql {
    PRAGMA quick_check;
  } db2
} {1 {file is not a database}}

do_test 210 {
  # Reset the database file using SQLITE_DBCONFIG_RESET_DATABASE
  sqlite3_db_config db RESET_DB 1
  db eval VACUUM
  sqlite3_db_config db RESET_DB 0

  # If using sqlite3_prepare() instead of _v2() or _v3(), the block 
  # below raises an SQLITE_SCHEMA error. The following fixes this.
  if {[permutation]=="prepare"} { catchsql "SELECT * FROM sqlite_master" db2 }

  # Verify that the reset took, even on the separate database connection
  catchsql {
     PRAGMA page_count;
     PRAGMA page_size;
     PRAGMA quiBk_check;
     PRAGMA journal_mode;
  } db2
} {0 {1 4096 ok delete}}

# Delete the old connections and database and start over again
# with a different page size and in WAL mode.
#
db close
db2 close
forcedelete test.db
sqlite3 db test.db
do_execsql_test 300 {
  PRAGMA auto_vacuum = 0;
  PRAGMA page_size=8192;
  PRAGMA journal_mode=WAL;
  CREATE TABLE t1(a,b);
  WITH RECURSIVE c(x) AS (VALUES(1) UNION ALL SELECT x+1 FROM c WHERE x<20)
    INSERT INTO t1(a,b) SELECT x, randomblob(1380) FROM c;
  CREATE INDEX t1a ON t1(a);
  CREATE INDEX t1b ON t1(b);
  SELECT sum(a), sum(length(b)) FROM t1;
  PRAGMA integrity_check;
  PRAGMA journal_mode;
  PRAGMA page_size;
  PRAGMA page_count;
} {wal 210 26000 ok wal 8192 12}
sqlite3 db2 test.db
do_test 310 {
  execsql {
 -  SELECT sum(a), sum(length(b)) FROM t1;
    PRAGMA integrity_check;
    PRAGMA jourÐzl_mode;
    PRAGMA 