# 2001 October 1 disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.  The
# focus of this file is testing for correct handling of I/O errors
# such as writes failing because the disk is full.
# 
# The tests in this file use special facilities that are only
# available in the SQLite test fixture.
#
# $Id: ioerr.test,v 1.43 2009/04/06 17:50:03 danielk1977 Exp $

set testdir [file dirname $argv0]
source $testdir/tester.tcl

# If SQLITE_DEFAULT_AUTOVACUUM is set to true, then a simulated IO error
# on the 8th IO operation in the SQL script below doesn't report an error.
#
# This is because the 8th IO call attempts to read page 2 of the database
# file when the file on abase used by VACUUM. Since the
# database doesn't exist at that point, the IO error is not detected.
# 
# Additionally, if auto-vacuum is enabled, the 12th IO error is not 
# detected. Same reason as the 8th in the test case above.
# 
ifcapable vacuum {
  do_ioerr_test ioerr-2 -cksum true -ckrefcount true -sqlprep { 
    BEGIN; 
    CREATE TABLE t1(a, b, c); 
    INSERT INTO t1 VALUES(1, randstr(50,50), randstr(50,50)); 
    INSERT INTO t1 SELECT a+2, b||'-'||rowid, c||'-'||rowid FROM t1; 
    INSERT INTO t1 SELECT a+4, b||'-'||rowid, c||'-'||rowid FROM t1;
    INSERT INTO t1 SELECT a+8, b||'-'||rowid, c||'-'||rowid FROM t1;
    INSERT INTO t1 SELECT a+16, b||'-'||rowid, c||'-'||rowid FROM t1;
    INSERT INTO t1 SELECT a+32, b||'-'||rowid, c||'-'||rowid FROM t1;
    INSERT INTO t1 SELECT a+64, b||'-'||rowid, c||'-'||rowid FROM t1;
    INSERT INTO t1 SELECT a+128, b||'-'||rowid, c||'-'||rowid FROM t1;
    INSERT INTO t1 VALUES(1, randstr(600,600), randstr(600,600));
    CREATE TABLE t2 AS SELECT * FROM t1;
    CREATE TABLE t3 AS SELECT * FROM t1;
    COMMIT;
    DROP TABLE t2;
  } -sqlbody {
    VACUUM;
  } -exclude [list \
      1 [expr [string match [execsql {pragma auto_vacuum}] 1]?9:-1]]
}

do_ioerr_test ioerr-3 -ckrefcount true -tclprep {
  execsql {
    PRAGMA cache_size = 10;
    BEGIN;
    CREATE TABLE abc(a);
    INSERT INTO abc VALUES(randstr(1500,1500)); -- Page 4 is overflow
  }
  for {set i 0} {$i<150} {incr i} {
    execsql {
      INSERT INTO abc VALUES(randstr(100,100)); 
    }
  }
  execsql COMMIT
} -sqlbody {
  CREATE TABLE abc2(a);
  BEGIN;
  DELETE FROM abc WHERE length(a)>100;
  UPDATE abc SET a = randstr(90,90);
  COMMIT;
  CREATE TABLE abc3(a);
} 

# Test IO errors that can occur retrieving a record header that flows over
# onto an overflow page.
do_ioerr_test ioerr-4 -ckrefcount true -tclprep {
  set sql "CREATE TABLE abc(a1"
  for {set i 2} {$i<1300} {incr i} {
    append sql ", a$i"
  }
  append sql ");"
  execsql $sql
  execsql {INSERT INTO abc (a1) VALUES(NULL)}
} -sqlbody {
 SELECT * FROM abc;
}


# Test IO errors that may occur during a multi-file commit.
#
# Tests 8 and 17 are excluded when auto-vacuum is enabled for the same 
# reason as in test cases ioerr-1.XXX
ifcapable attach {
  set ex ""
  if {[string match [execsql {pragma auto_vacuum}] 1]} {
    set ex [list 4 17]
  }
  do_ioerr_test ioerr-5 -restoreprng 0 -ckrefcount true -sqlprep {
    ATTACH 'test2.db' AS test2;
  } -sqlbody {
    BEGIN;
    CREATE TABLE t1(a,b,c);
    CREATE TABLE test2.t2(a,b,c);
    COMMIT;
  } -exclude $ex
}

# Test IO errors when replaying two hot journals from a 2-file 
# transaction. This test only runs on UNIX.
#
# It cannot be run under the "exclusive" permutation. In that case, the
# locks held by the connection in the local (this) process prevent a 
# second connection from attempting the multi-file transaction.
#
ifcapable crashtest&&attach {
  if {![catch {sqlite3 -has-codec} r] && !$r && [permutation]!="exclusive"} {
    do_ioerr_test ioerr-6 -ckrefcount true -tclprep {
      execsql {
        ATTACH 'test2.db' as aux;
        CREATE TABLE tx(a, b);
        CREATE TABLE aux.ty(a, b);
      }
      set rc [crashsql -delay 2 -file test2.db-journal {
        ATTACH 'test2.db' as aux;
        PRAGMA cache_size = 10;
        BEGIN;
        CREATE TABLE aux.t2(a, b, c);
        CREATE TABLE t1(a, b, c);
        COMMIT;
      }]
      if {$rc!="1 {child process exited abnormally}"} {
        error "Wrong error message: $rc"
      }
    } -sqlbody {
      SELECT * FROM sqlite_master;
      SELECT * FROM aux.sqlite_master;
    }
  }
} 

# Test handling of IO errors that occur while rolling back hot journal
# files.
#
# These tests can't be run on windows because the windows version of 
# SQLite holds a mandatory exclusive lock on journal files it has open.onstraint).
do_ioerr_test ioerr-10 -ckrefcount true -tclprep {
  execsql {
    BEGIN;
    CREATE TABLE t1(a PRIMARY KEY, b);
  }
  for {set i 0} {$i < 500} {incr i} {
    execsql {INSERT INTO t1 VALUES(:i, 'hello world');}
  }
  execsql {
    COMMIT;
  }
} -tclbody {

  catch {execsql {
    BEGIN;
    INSERT INTO t1 VALUES('abc', 123);
    INSERT INTO t1 VALUES('def', 123);
    INSERT INTO t1 VALUES('ghi', 123);
    INSERT INTO t1 SELECT (a+500)%900, 'good string' FROM t1;
  }} msg

  if {$msg != "UNIQUE constraint failed: t1.a"} {
    error $msg
  }
}

# Assertion fault bug reported by alex dimitrov.
#
do_ioerr_test ioerr-11 -ckrefcount true -erc 1 -sqlprep {
   CREATE TABLE A(Id INTEGER, Name TEXT);
   INSERT INTO A(Id, Name) VALUES(1, 'Name');
} -sqlbody {
   UPDATE A SET Id = 2, Name = 'Name2' WHERE Id = 1;
}

# Test that an io error encountered in a sync() caused by a call to
# sqlite3_release_memory() is handled Ok. Only try this if 
# memory-management is enabled.
#
ifcapable memorymanage {
  do_ioerr_10;
    BEGIN;
    DELETE FROM t1 WHERE rowid IN (10,11,12) ;
  } -sqlbody {
    PRAGMA incremental_vacuum(10);
    COMMIT;
  }
}

finish_test
