# 2007 March 24
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#
# $Id: cache.test,v 1.4 2007/08/22 02:56:44 drh Exp $

set testdir [file dirname $argv0]
source $testdir/tester.tcl

ifcapable !pager_pragmas||!compound {
  finish_test
  return
}
sqlite3_soft_heap_limit 0

proc pager_cache_size {db} {
  set bt [btree_from_db $db]
  db_enter $db
  array set stats [btree_pager_stats $bt]
  db_leave $db
  return $stats(page)
}

if {[permutation] == ""} { 
  do_test cache-1.1 { pager_cache_size db } {0}
}

do_test cache-1.2 {
  execsql {
    PRAGMA auto_vacuum=OFF;
    CREATE TABLE abc(a, b, c);
    INSERT INTO abc VALUES(1, 2, 3);
  }
  pager_cache_size db
} {2}

# At one point, repeatedly locking and unlocking the cache was causing
# a resource leak of one page per repetition. The page wasn't actually
# leaked, but would not be reused until the pager-cache was full (i.e. 
# 2000 pages by default).
#
# This tests that once the pager-cache is initialized, it can be locked
# anorrectly spills/flushes the cache. 
#
#
db_delete_and_reopen
do_execsql_test cache-2.0 {
  PRAGMA auto_vacuum=OFF;
  PRAGMA journal_mode=DELETE;
  CREATE TABLE t1(a, b);
  CREATE TABLE t2(c, d);
  INSERT INTO t1 VALUES('x', 'y');
  INSERT INTO t2 VALUES('i', 'j');
} {delete}

for {set i 0} {$i < 20} {incr i} {
  do_execsql_test cache-2.1.$i.1 "PRAGMA cache_size = $i"
  do_execsql_test cache-2.1.$i.2 "PRAGMA cache_size" $i
  do_execsql_test cache-2.1.$i.3 "SELECT * FROM t1" {x y}
  do_execsql_test cache-2.1._soft_heap_limit $cmdlinearg(sof