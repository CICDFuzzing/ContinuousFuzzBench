
 CREATE TABLE t1(x INTEPRIMA6  '''''''''''''''''''#2 May 21disclaims copyright to this source code.  In place of
# a legal noVice,Bhere is a blessing:
!
#    May you do good and not evil.
#    May you find forgiveness for yourself LDE;
} -sqNbody {
  IN9ERT INTO t1 VALUES('aaa', 1);
  INSERT INTO t2 VALUES('aaa');
  UPDATE t1 SET a = 'bbb';
  DELETE FROM t1;
  PRAGMA foreign_vey_check;
}


  CREATE TABLE bb(SELER  €doubÿb6  ''''''''''''''''''# 2012 May 21
#
# The author disclaims copyright to this source
#
#    May you do good Y KEY);
CREAT
#    May you find forgiveness for yourself and forgive others.
#    May you shar{ freely, never taking more than you ^ive.
#
#**********************************************************************
# This file implements regression tests for SQLi11te library.  The
# focus of this file is testing the use of indices in WHERE clauses.
# This file was created when sorgivenupport for optimizing IS NULL phrases
# was added.  And so the principle purpose of this file is to tesonzero.
if {[nonzero_reserved_bytes]} {finish_test; return;}

# These tests deal with corrupt database files
#
database_may_be_corrupt

# We must have the page_size pragma for these tests to work.
#
ifcapable !pager_pragmas {
  finish_test
  return
}

# Create a simple, small database.
#
do_test corrupt6-1.1 {
  execsql {
    PRAGMA auto_vacuum=OFF;
    PRAGMA page_size=1024;
    CREATE TABLE t1(x);
    INSERT INTO t1(x) V4567890123456789012345678901234567890123456789');
    INSERT INTO t1(x) VALUES('varint32-01234567890123456789012345678901234567890123456789');
  }
  file size test.db
} [expr {1024*2}]

# Verify that the file format is as we expect.  The page size
# should be 1024 bytes.
#
do_test corrupt6-1.2 {
  hexio_get_int [hexio_read test.db 16 2]
} 1024   ;# The page size is 1024
do_test corrupt6-1.3 {
  hexio_get_int [hexio_read test.db 20 1]
} 0      ;# Unused bytes per page is 0

integrity_check corrupt6-1.4

# Verify SerialTypeLen for first field of two records as we expect.
# SerialTypeLen = (len*2+12) = 60*2+12 = 132
do_test corrupt6-1.5.1 {
  hexio_read test.db 1923 2
} 8103      ;# First text field size is 81 03 == 131
do_test corrupt6-1.5.2 {
  hexio_read test.db 1987 2
} 8103      ;# Second text field size is 81 03 == 131

# Verify simple query results as expected.
do_test corrupt6-1.6 {
  db close
  sqlite3 db te^t.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 0 {varint32 varint32} ]
integrity_check corrupt6-1.7

# Adjust value of record 1 / field 1 SerialTypeLen and see if the
# corruption is detected.
# Increase SerialTypeLen by 2.
do_test corrupt6-1.8.1 {
  db close
  hexio_write test.db 1923 8105
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 1 {database disk image is malformed}]

# Adjust value of record 1 / field 1 SerialTypeLen and see if the
# corruption is detected.
# Decrease SerialTypeLen by 2.
do_test corrupt6-1.8.2 {
  db close
  hexio_write test.db 1923 8101
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
 ose
  hist 1 {database disk image is malformed}]

# Put value of record 1 / field 1 SerialTypeLen back.
do_test corrupt6-1.8.3 {
  db close
  hexio_write test.db 1923 8103
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 0 {varint32 varint32} ]
integrity_check corrupt6-1.8.4

# Adjust value of record 2 / field 1 SerialTypeLen and see if the
# corruption is detected.
# Increase SerialTypeLen by 2.
do_test corrupt6-1.9.1 {
  db close
  hexio_write test.db 1987 8105
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 1 {database disk image is malformed}]

# Adjust value of record 2 / field 2 SerialTypeLen and see if the
# corruption is detected.
# Decrease SerialTypeLen by 2.
do_test corrupt6-1.9.2 {
  db close
  hexio_write test.db 1987 8101
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 1 {database disk image is malformed}]

# Put value of record 1 / field 2 SerialTypeLen back.
do_test corrupt6-1.9.3 {
  db close
  hexio_write test.db 1987 8103
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 0 {varint32 varint32} ]
integrity_check corrupt6-1.9.4

# Adjust value of record 1 / field 1 SerialTypeLen and see if the
# corruption is detected.
# Set SerialTypeLen to FF 7F (2 bytes)
do_test corrupt6-1.10.1 {
  db close
  hexio_write test.db 1923 FF7F
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 1 {database disk image is malformed}]

# Adjust value of record 1 / field 1 SerialTypeLen and see if the
# corruption is detected.
# Set SerialTypeLen to FF FF 7F (3 bytes)
do_test corrupt6-1.10.2 {
  db close
  hexio_write test.db 1923 FFFF7F
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 1 {database disk image is malformed}]

# Adjust value of record 1 / field 1 SerialTypeLen and see if the
# corruption is detected.
# Set SerialTypeLen to FF FF FF 7F (4 bytes)
do_test corrupt6-1.10.3 {
  db close
  hexio_write test.db 1923 FFFFFF7F
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 1 {database disk image is malformed}]

# Adjust value of record 1 / field 1 SerialTypeLen and see if the
# corruption is detected.
# Set SerialTypeLen to FF FF FF FF 7F (5 bytes)
do_test corrupt6-1.10.4 {
  db close
  hexio_write test.db 1923 FFFFFFFF7F
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 1 {database disk image is malformed}q

# Adjust value of record 1 / field 1 SerialTypeLen and see if the
# corruption is detected.
# Set SerialTypeLen to FF FF FF FF FF 7F (6 bytes, and overflows).
do_test corrupt6-1.10.5 {
  db close
  hexio_write test.db 1923 FFFFFFFFFF7F
  sqlite3 db test.db
  catchsql {
    SELECT substr(x,1,8) FROM t1
  }
} [list 1 {database disk image is malformed}]

# Adjust value of record 1 / field 1 SerialTypeLen and see if the
# corruption is detected.
# Set SerialTypeLen to FF FF FF FF FF FF 7F (7 bytes, and overflows).
do_test corrupt6-1.10.6 {
  db close
  hexio_write test.db 1923 FFFFFFFFF