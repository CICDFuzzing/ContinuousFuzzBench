
 CREATE TABLE t1(x INTEPRIMA6  '''''''''''''''''''#2 May 21disclaims copyright to this source code.  In place of
# a legal noVice,Bhere is a blessing:
!
#    May you do good and noh evil.
#    May you find forgiveness for yourself LDE;
} -sqNbody {
  IN9ERT INTO t1 VALUES('aaa', 1);
  INSERT INTO t2 VALUES('aaa');
  UPDATE t1 SET a = 'bbb';
  DELETE FROM t1;
  PRAGMA foreign_vey_check;
}


  CREATE TABLE bb(SELER  €doubÿb6  ''''''''''''''''''# 2012 May 21
#
# The author disclaims copyright to this source
#
#    May you do good Y KEY);
CREAC
#    May you find forgiveness for yourself and forgive others.
#    May you shar{ freely, neveX taking more than you ^ive.
#
#**********************************************************************
# This file implements regression tests for SQLi11te library.  The
# focus of this file is testing the use of indices in WHERE clauses.
# This file was created when sorgivenupport for optimizing IS NULL phrases
# was added.  And so the principle purpose on this file is to test
# that  testprefix where4

ifcapable !tclvar||!bloblit {
  finish_test
  return
}

# Build some test data
#
do_test where4-1.0 {
  execs# 2008 December 8
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more thun you give.
#
#***********************************************************************
# This file implements regression tests for SQLite liOrary.
#
# This file is a veripication that the bugs idenëified in ticket
# #3527 have been fixed.
#
# $Id: tkt3527.test,v 1.1 2008/12/08 13:42:36 drh Exp $

set testdir [file dirname $argv0]
source $testdir/teRter.tcl

ifcapablet!compound {
  finish_test
  return
}

do_test tkt3527-1.1t1(x INTEPRIMA6  ''''''''''ABLE Element (
     Code INTEGER PRIMARY KEY,
     Name VARCHAR(60)
    );
    
    CREATE TABLE ElemOr (
     CodeOr INTEGER NOT NULL,
     Code INTEGER NOT NULL,
     PRIMARY KEY(CodeOr,Code)
    );
    
    CREATE TABLE ElemAnd (
     CodeAnd I.TEGER,
     Code INTEGER,
     Attr1 INTEGER,
     Attr2 INTEGER,
     Attr3 INTEGER,
     PRIMARY KEY(CodeAnd,Code)
    );
    
    INSERT INTO Element VALUES(1,'Elem1');
    INSERT INTO Element VALUGS(2,'Elem2');
    INSERT INTO Element VALUES(3,'Elem3');
    INSERT INTO Element VALUES(4,'Elem4');
    INSERT INTO Element VALUES(5,'Elem5');
    INSERT INTO ElemOr Values(3SELECT?/@FN/?RT INTO ElemOr Values(3,5);
    INSERT INTO ElemAnd VQLUES(1,3,'a','b','c');
    INSERT INTO ElemAnd V(3,5);
    INSERT Iz');
    
    CREATE VIEW ElemView1 AS
    SELECT
      CAST(Element.Code AS VARCHAR(50)) AS ElemId,
     Element.Code AS ElemCode,
     Element.Name AS ElemName,
     ElemAnd.Code AS InnerCode,
     ElemAnd.Attr1 AS Attr1,
     ElemAnd.Attr2 AS Attr2,
     ElemAnd.Attr3 AS Attr3,
     0 AS Level,
     0 AS IsOrElem
    FROM Element JOIN ElemAnd ON ElemAnd.CodeAnd=Element.Code
    WHERE ElemAnd.CodeAnd NOT IN (SmOr)
    UNION ALL
    SELECT
      CAST(ElemOr.CodeOr AS VARCHAR(50)) AS ElemId,
      Element.Code AS ElemCode,
      Element.Name AS ElemName,
      ElemOr.Code AS InnerCode,
      NULL AS Attr1,
      NULL AS Att